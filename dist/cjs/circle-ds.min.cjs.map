{"version":3,"file":"circle-ds.min.cjs","sources":["../../src/types/boundedEvent.ts","../../__vite-browser-external","../../src/circle/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/circle/circularDeque.ts","../../src/circle/circularLinkedDeque.ts","../../src/utils/math.ts","../../src/circle/circularLinkedList.ts","../../src/circle/circularLinkedQueue.ts","../../src/circle/circularLinkedStack.ts","../../src/circle/circularMap.ts","../../src/circle/circularQueue.ts","../../src/circle/circularSet.ts","../../src/circle/circularStack.ts"],"sourcesContent":["/**\n * An enumeration of event types supported by {@link Bounded} collections.\n *\n * This object defines a set of constants representing event names that can\n * be emitted by instances of collections implementing the {@link Bounded} interface.\n * These events signify specific actions or changes in the state of the collection.\n *\n * Defined events include:\n * - `Overflow`: Indicates that the collection has reached its capacity, and\n *   as a result, one or more elements have been removed to accommodate new elements.\n *   This event is triggered during operations that add elements to the collection when\n *   it exceeds its capacity, or when capacity is updated below the collection's current\n *   size. Listeners attached to this event will receive an array of elements that were\n *   removed due to the overflow. Removed elements may be sent across 1 or more event\n *   instances.\n *\n * This object is marked as `const` to ensure that its properties are read-only,\n * preventing modification of event names which could lead to inconsistencies in\n * event handling across the application.\n */\nexport const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","export default {}","import EventEmitter from \"events\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport class CircularBase<T> {\n  /**\n   * The event emitter.\n   * @internal\n   */\n  protected emitter: EventEmitter;\n\n  constructor(emitter = new EventEmitter()) {\n    this.emitter = emitter;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for\n   * the {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * Alternatively, the `addListener()` method can be used to add\n   * the event listener to the end of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  prependListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.prependListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * Represents the maximum number of arguments that can be passed to a function.\n *\n * While ECMAScript specifications do not explicitly limit the number of function arguments,\n * practical limits are imposed by JavaScript engine implementations. Different engines can\n * have different maximums, so a conservative value is used to prevent runtime errors.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-list-and-record-specification-type | ECMAScript Specification},\n * section \"6.2.2 The List and Record Specification Types\".\n */\nexport const ARGS_MAX_LENGTH = 16383; // 2**14 - 1\n\n/**\n * Defines the maximum allowable length of an array.\n *\n * According to the ECMAScript specification, the length property of an array is\n * an unsigned 32-bit integer, so its range is 0 to 2**32 - 1, inclusive. Beyond this,\n * operations that modify the array length (e.g., `push`, `pop`, `unshift`, `shift`)\n * may fail or behave unexpectedly.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-arraycreate | ECMAScript Specification},\n * section \"10.4.2.2 ArrayCreate\".\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1;\n","import { ARRAY_MAX_LENGTH } from \"./constants\";\n\n/**\n * Checks if a given value is an integer within a valid array length range.\n *\n * This function is useful for validating array lengths before attempting operations\n * that could result in a `RangeError` due to invalid array size.\n *\n * @param value - The value to check.\n * @returns `true` if the value is an integer within the `[0, ARRAY_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a function.\n *\n * @param value - The value to check.\n * @returns `true` if the value is a function, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n/**\n * Checks if a given value is positive infinity.\n *\n * @param value - The value to check.\n * @returns `true` if the value is positive infinity, `false` otherwise.\n */\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n/**\n * Determines whether the provided value is iterable.\n *\n * This is useful for determining if a value can be used\n * in a `for...of` loop or with spread syntax.\n *\n * @param value - The value to check.\n * @returns `true` if the value implements the iterable protocol, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\n/**\n * Determines whether the provided value is a number.\n *\n * This includes `NaN` and `Infinity`, so consider additional\n * checks if those values are not desirable.\n *\n * @param value - The value to check.\n * @returns `true` if the value is of type number, `false` otherwise.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Checks if a given value is a safe integer greater than or equal to 0.\n *\n * This is useful for validating counts or sizes that must be within the safe\n * integer range to prevent precision loss.\n *\n * @param value - The value to check.\n * @returns `true` if the value is a safe integer and non-negative, `false` otherwise.\n */\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\n/**\n * Determines whether the provided value is a symbol.\n *\n * @param value - The value to check.\n * @returns `true` if the value is a symbol, `false` otherwise.\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\nimport { Deque } from \"..\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Deque<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new deque. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new deque with the given capacity.\n   *\n   * @param capacity - the deque's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new deque from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the deque.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularDeque.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size < 1) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Get the first element in the deque.\n   *\n   * Alias for {@link front | front()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the deque.\n   *\n   * Alias for {@link first | first()}.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Get the last element in the deque.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.top();\n  }\n\n  /**\n   * Removes the last element from the deque.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    const tail = this.next > 0 ? this.next - 1 : this.head + this._size - 1;\n\n    --this._size;\n    this.next = tail;\n    const value = this.vals[tail];\n    this.vals[tail] = undefined as T;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the deque.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the deque.\n   */\n  push(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._push(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._push(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evictHead(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(0, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._push(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the deque.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    --this._size;\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined as T;\n    if (++this.head >= this._capacity) {\n      this.head = 0;\n      this.vals.length = this.next;\n    }\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Inserts new elements at the end of the deque.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the deque.\n   */\n  unshift(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._unshift(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._unshift(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evictTail(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(N - diff, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._unshift(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Get the last element in the deque.\n   *\n   * Alias for {@link last | last()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    return this.vals[(this.head + this._size - 1) % this._capacity];\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Emit an event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected emit(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes a given number of elements from the deque.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evictHead(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      this.emit(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n  }\n\n  /**\n   * Removes a given number of elements from the deque.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evictTail(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const isNonsequential = !this.isSequential();\n    if (isNonsequential && this.next > count) {\n      this.emit(this.vals.slice(this.next - count, this.next));\n      this.vals.fill(undefined as T, this.next - count, this.next);\n      this.next -= count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(0, this.next));\n      this.vals.fill(undefined as T, 0, this.next);\n      this._size -= this.next;\n      count -= this.next;\n      this.next = 0;\n      if (count <= 0) {\n        return;\n      }\n    }\n\n    const tail = this.head + this._size;\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, tail));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(tail - count, tail));\n    this.next = tail - count;\n    this.vals.length = this.next;\n    this._size -= count;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if deque is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the deque is stored sequentially in memory.\n   * @internal\n   *\n   * @returns `true` if the deque is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param max - The number of elements to append.\n   */\n  protected _push(elems: T[], max: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let tail = this.next;\n    for (let i = 0; i < max; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    this.next = tail;\n    this._size += max;\n  }\n\n  /**\n   * Adjusts the deque to fit within the given capacity.\n   * @internal\n   *\n   * Assumes the deque is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the deque was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If deque fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If deque must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If deque must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    this.evictHead(this._size - capacity);\n\n    // Check if deque is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of deque: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param num - The number of elements to append.\n   */\n  protected _unshift(elems: T[], num: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let head = this.head;\n    const min = elems.length - num;\n    for (let i = elems.length - 1; i >= min; --i) {\n      if (--head < 0) {\n        head += capacity;\n      }\n      vals[head] = elems[i];\n    }\n\n    this.head = head;\n    this._size += num;\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Deque } from \"../types/deque\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { DoublyLinkedNode as Node } from \"../types/doublyLinkedNode\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Deque<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the collection.\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n    this._size = 0;\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root.prev;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { next: this.root, prev: tail, value };\n      tail = tail.next;\n      this.root.prev = tail;\n      ++this._size;\n    }\n    this._capacity = this._size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedDeque.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink stack\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    head.prev = this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Removes the top element from the stack and returns it.\n   *\n   * @returns the top element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.prev;\n    this.root.prev = node.prev;\n    node.prev.next = this.root;\n    --this._size;\n    return node.value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, elems);\n      return this._size;\n    }\n\n    const N = elems.length;\n    const root = this.root;\n    const evicted: T[] = [];\n\n    let tail = root.prev;\n    for (let i = 0; i < N; ++i) {\n      tail.next = { next: root, prev: tail, value: elems[i] };\n      tail = tail.next;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n    root.prev = tail;\n    root.next.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const head = this.root.next.next;\n    const value = head.prev.value;\n    this.root.next = head;\n    head.prev = this.root;\n    --this._size;\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Inserts new elements at the front of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  unshift(...elems: T[]): number {\n    // Case 1: No values\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, elems);\n      return this._size;\n    }\n\n    const root = this.root;\n    const evicted: T[] = [];\n\n    let head = root.next;\n    for (let i = elems.length - 1; i >= 0; --i) {\n      head = { next: head, prev: root, value: elems[i] };\n      head.next.prev = head;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.prev.value);\n        root.prev = root.prev.prev;\n      }\n    }\n    root.next = head;\n    root.prev.next = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted.reverse());\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n}\n","/**\n * Restricts a given numerical value within a specified range [min, max].\n *\n * If the provided value is less than the minimum, the minimum is returned.\n * If it is greater than the maximum, the maximum is returned. If the value\n * is within the range, the value itself is returned. An error is thrown if\n * the minimum range value is greater than the maximum range value, as this\n * represents an invalid range.\n *\n * @param value - The numerical value to clamp.\n * @param min - The minimum allowable value of the range.\n * @param max - The maximum allowable value of the range.\n * @returns The clamped value within the specified range.\n * @throws `RangeError` If `min` is greater than `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError(\"Invalid clamp range; min must be <= max\");\n  }\n  if (value <= min) {\n    return min;\n  }\n  return value <= max ? value : max;\n}\n\n/**\n * Calculates the logarithm of a given value with the specified base.\n *\n * This function uses natural logarithms (`Math.log`) for its calculations.\n * If either the value or the base is less than or equal to 0, `NaN` is returned\n * to indicate an invalid operation, as logarithms are not defined for non-positive\n * values and bases.\n *\n * @param value - The numerical value for which to calculate the logarithm. Must be positive.\n * @param base - The base of the logarithm. Must be positive.\n * @returns The calculated logarithm of the value with the given base, or `NaN` for invalid inputs.\n */\nexport function log(value: number, base: number): number {\n  return value >= 0 && base > 0 ? Math.log(value) / Math.log(base) : NaN;\n}\n\n/**\n * Generates a number representing the length of a consecutive run based on a\n * probability threshold.\n *\n * This function iteratively increments a counter as long as the randomly\n * generated numbers from `randomFn` are less than the specified probability\n * threshold `p`, or until the counter reaches the maximum `max`.\n *\n * The function is useful for simulations or models that require a random yet\n * probabilistically constrained sequence length, such as simulating streaks or\n * runs in games of chance.\n *\n * @param p - The probability threshold. Defaults to 0.5.\n * @param max - The maximum value the of the run. Defaults to Infinity.\n * @param min - The starting value of the run. Defaults to 0.\n * @param randomFn - A function that generates a random number. Defaults to `Math.random`.\n *\n * @returns - The length of the run.\n */\nexport function randomRun(\n  p = 0.5,\n  max = Infinity,\n  min = 0,\n  randomFn = Math.random\n): number {\n  while (min < max && randomFn() < p) {\n    ++min;\n  }\n  return min;\n}\n\n/**\n * Attempts to convert a given value to an integer.\n *\n * The function first tries to convert the value to a number. If the result\n * is not valid (i.e. `NaN`), the given `defaultValue` is returned. Otherwise,\n * the function truncates the number to an integer using `Math.trunc`.\n *\n * This is useful for ensuring numerical operations are performed on integers,\n * with a controllable fallback for invalid inputs.\n *\n * @param value - The value to convert to an integer. This can be of any type.\n * @param defaultValue - The fallback value to return if conversion fails. Defaults to 0.\n * @returns The converted integer, or `defaultValue` if conversion is not possible.\n */\nexport function toInteger(value?: unknown, defaultValue = 0): number {\n  value = +value!;\n  return isNaN(value as number) ? defaultValue : Math.trunc(value as number);\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { DoublyLinkedNode as Node } from \"../types/doublyLinkedNode\";\nimport { List } from \"../types/list\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { clamp, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n  /**\n   * @internal\n   */\n  protected root!: Node<T>;\n  /**\n   * @internal\n   */\n  protected _size!: number;\n\n  /**\n   * Creates a new queue with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { prev: tail, value } as Node<T>;\n      tail = tail.next;\n      ++this._size;\n    }\n    tail.next = this.root;\n    this.root.prev = tail;\n    this._capacity = this._size;\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    head.prev = this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  at(index: number): T | undefined {\n    const i = this.tryIndex(index);\n    return i == undefined ? undefined : this.getNode(i).value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  delete(index: number): boolean {\n    index = this.tryIndex(index)!;\n    if (index == undefined) {\n      return false;\n    }\n    this.remove(this.getNode(index));\n    return true;\n  }\n\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(end, -size, size);\n    end += end >= 0 ? 0 : size;\n\n    // Update values\n    for (let node = this.getNode(start); start < end; ++start) {\n      node.value = value;\n      node = node.next;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    const N = this._size;\n    let node = this.root;\n    for (let i = 0; i < N; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.prev;\n    this.remove(node);\n    return node.value;\n  }\n\n  push(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.append(this.root.prev, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    const i = this.tryIndex(index);\n    if (i == undefined) {\n      return undefined;\n    }\n    const node = this.getNode(i);\n    const prevValue = node.value;\n    node.value = value;\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.next;\n    this.remove(node);\n    return node.value;\n  }\n\n  slice(start?: number, end?: number): CircularLinkedList<T> {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(end, -size, size);\n    end += end >= 0 ? 0 : size;\n\n    const out = new CircularLinkedList<T>();\n    for (let prev = this.getNode(start - 1); start < end; ++start) {\n      out.push(prev.next.value);\n      prev = prev.next;\n    }\n\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularLinkedList<T> {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, size - start);\n\n    // Create output list\n    const out = new CircularLinkedList<T>();\n\n    // Replace values\n    const itemCount = items.length;\n    let prev = this.getNode(start - 1);\n    const replaceCount = Math.min(deleteCount, itemCount);\n    for (let i = 0; i < replaceCount; ++i) {\n      prev = prev.next;\n      out.push(prev.value);\n      prev.value = items[i];\n    }\n\n    // Add values\n    if (deleteCount <= replaceCount) {\n      this.append(prev, items, replaceCount);\n      return out;\n    }\n\n    // Attach out tail to segment head\n    let tail = out.root.prev;\n    prev.next.prev = tail;\n    tail.next = prev.next;\n\n    // Find segment tail\n    const diff = deleteCount - replaceCount;\n    tail = this.moveRight(prev, diff);\n\n    // Delete segment from list\n    prev.next = tail.next;\n    tail.next.prev = prev;\n    this._size -= diff;\n\n    // Attach segment tail to out root\n    tail.next = out.root;\n    out.root.prev = tail;\n    out._size += diff;\n\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.prepend(this.root.next, values);\n\n    // Return size\n    return this._size;\n  }\n\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected append(prev: Node<T>, values: T[], minIndex = 0): Node<T> {\n    const root = this.root;\n    const next = prev.next;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = minIndex; i < N; ++i) {\n      const curr = { prev, value: values[i] } as Node<T>;\n      prev.next = curr;\n      prev = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n    prev.next = next;\n    next.prev = prev;\n    root.next.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return prev;\n  }\n\n  /**\n   * @internal\n   */\n  protected getNode(index: number): Node<T> {\n    const node = this.root;\n    const half = this._size / 2;\n    return index <= half\n      ? this.moveRight(node, index + 1)\n      : this.moveLeft(node, this._size - index);\n  }\n\n  /**\n   * @internal\n   */\n  protected moveLeft(node: Node<T>, steps: number): Node<T> {\n    for (let i = 0; i < steps; ++i) {\n      node = node.prev;\n    }\n    return node;\n  }\n\n  /**\n   * @internal\n   */\n  protected moveRight(node: Node<T>, steps: number): Node<T> {\n    for (let i = 0; i < steps; ++i) {\n      node = node.next;\n    }\n    return node;\n  }\n\n  /**\n   * @internal\n   */\n  protected prepend(next: Node<T>, values: T[]): Node<T> {\n    const root = this.root;\n    const prev = next.prev;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    for (let i = values.length - 1; i >= 0; --i) {\n      const curr = { next, value: values[i] } as Node<T>;\n      next.prev = curr;\n      next = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.prev.value);\n        root.prev = root.prev.prev;\n      }\n    }\n    next.prev = prev;\n    prev.next = next;\n    root.prev.next = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted.reverse());\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return next;\n  }\n\n  /**\n   * @internal\n   */\n  protected remove(node: Node<T>): void {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    --this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected tryIndex(index: number): number | undefined {\n    // Conver to number\n    index = +index;\n\n    // Check if an integer\n    const size = this._size;\n    if (!Number.isInteger(index) || index >= size || index < -size) {\n      return undefined;\n    }\n\n    // If negative, treat as index + size\n    return index < 0 ? index + size : index;\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { LinkedNode as Node } from \"../types/linkedNode\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Queue<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the collection.\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The tail of the collection.\n   * @internal\n   */\n  protected tail: Node<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this._size = 0;\n    this.tail = this.root;\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { next: this.root, value } as Node<T>;\n      tail = tail.next;\n      ++this._size;\n    }\n    this.tail = tail;\n    tail.next = this.root;\n    this._capacity = this._size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedQueue.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink queue\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    this.tail = this._size > 0 ? this.tail : this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.tail = this.root;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, elems);\n      return this._size;\n    }\n\n    const N = elems.length;\n    const root = this.root;\n    const evicted: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      this.tail.next = { next: root, value: elems[i] };\n      this.tail = this.tail.next;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const head = this.root.next;\n    this.root.next = head.next;\n    if (--this._size < 1) {\n      this.tail = this.root;\n    }\n    return head.value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { Stack } from \"../types/stack\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { BoundedEvent } from \"..\";\nimport { Bounded } from \"../types/bounded\";\nimport { DoublyLinkedNode as Node } from \"../types/doublyLinkedNode\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Stack<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the collection.\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n    this._size = 0;\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { prev: tail, value } as Node<T>;\n      tail = tail.next;\n      ++this._size;\n    }\n    tail.next = this.root;\n    this.root.prev = tail;\n    this._capacity = this._size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedStack.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink stack\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    head.prev = this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Removes the top element from the stack and returns it.\n   *\n   * @returns the top element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.prev;\n    this.root.prev = node.prev;\n    node.prev.next = this.root;\n    --this._size;\n    return node.value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    // Case 1: No values\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, elems);\n      return this._size;\n    }\n\n    const root = this.root;\n    const evicted: T[] = [];\n\n    let tail = root.prev;\n    for (let i = 0; i < N; ++i) {\n      tail.next = { next: root, prev: tail, value: elems[i] };\n      tail = tail.next;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n    root.prev = tail;\n    root.next.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal map.\n   * @internal\n   */\n  protected map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.map = new Map(capacity as Iterable<[K, V]>);\n    this._capacity = this.map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of values in the map.\n   */\n  get size(): number {\n    return this.map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.map);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this.map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this.map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this.map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this.map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this.map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this.map.delete(key) && this.size >= this.capacity) {\n      const entry = this.map.entries().next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this.map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this.map.values();\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Queue<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   * @internal\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularQueue.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size < 1) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link front | front()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link first | first()}.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Inserts new elements at the end of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the queue.\n   */\n  push(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._push(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._push(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evict(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(0, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._push(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    --this._size;\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined as T;\n    if (++this.head >= this._capacity) {\n      this.head = 0;\n      this.vals.length = this.next;\n    }\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Emit an event containing the items evicted from the collection.\n   * @internal\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected emit(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes a given number of elements from the queue.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   * @internal\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evict(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      this.emit(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if queue is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the queue is stored sequentially in memory.\n   * @internal\n   *\n   * @returns `true` if the queue is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param max - The number of elements to append.\n   */\n  protected _push(elems: T[], max: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let tail = this.next;\n    for (let i = 0; i < max; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    this.next = tail;\n    this._size += max;\n  }\n\n  /**\n   * Adjusts the queue to fit within the given capacity.\n   * @internal\n   *\n   * Assumes the queue is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the queue was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If queue fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If queue must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If queue must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    this.evict(this._size - capacity);\n\n    // Check if queue is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of queue: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal set.\n   * @internal\n   */\n  protected set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.set = new Set(capacity as Iterable<T>);\n    this._capacity = this.set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of values in the set.\n   */\n  get size(): number {\n    return this.set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.set);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this.set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this.set.delete(value);\n      evicted.push(value);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this.set.delete(value) && this.size >= this.capacity) {\n      const out = this.set.values().next().value;\n      this.set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this.set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this.set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this.set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this.set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this.set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this.set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.set.values();\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Stack } from \"../types/stack\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Stack<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularStack.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size < 1) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  /**\n   * Remove all elements from the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Get the last element in the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.top();\n  }\n\n  /**\n   * Removes the element at the top of the stack.\n   *\n   * @returns the top element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    const tail = this.next > 0 ? this.next - 1 : this.head + this._size - 1;\n\n    --this._size;\n    this.next = tail;\n    const value = this.vals[tail];\n    this.vals[tail] = undefined as T;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the stack.\n   */\n  push(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._push(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._push(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evict(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(0, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._push(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element in the stack.\n   *\n   * Alias for {@link last | last()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    return this.vals[(this.head + this._size - 1) % this._capacity];\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Emit an event containing the items evicted from the collection.\n   * @internal\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected emit(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes a given number of elements from the stack.\n   * @internal\n   *\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evict(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      this.emit(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if stack is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // stack is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the stack is stored sequentially in memory.\n   * @internal\n   *\n   * @returns `true` if the stack is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param max - The number of elements to append.\n   */\n  protected _push(elems: T[], max: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let tail = this.next;\n    for (let i = 0; i < max; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    this.next = tail;\n    this._size += max;\n  }\n\n  /**\n   * Adjusts the stack to fit within the given capacity.\n   * @internal\n   *\n   * Assumes the stack is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - the new capacity.\n   *\n   * @returns `true` if the stack was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If stack fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If stack must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If stack must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    this.evict(this._size - capacity);\n\n    // Check if stack is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of stack: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n}\n"],"names":["BoundedEvent","EventEmitter","CircularBase","emitter","__publicField","event","listener","ARRAY_MAX_LENGTH","isArrayLength","value","isInfinity","isNumber","isSafeCount","CircularDeque","capacity","ext","callbackfn","thisArg","N","tail","elems","free","diff","evicted","count","len","isNonsequential","temp","max","vals","i","num","head","min","CircularLinkedDeque","items","node","root","clamp","toInteger","defaultValue","CircularLinkedList","index","start","end","size","values","prevValue","out","prev","deleteCount","itemCount","replaceCount","minIndex","next","curr","half","steps","CircularLinkedQueue","CircularLinkedStack","CircularMap","iter","n","entry","key","CircularQueue","CircularSet","CircularStack"],"mappings":"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"}