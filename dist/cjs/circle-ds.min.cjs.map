{"version":3,"file":"circle-ds.min.cjs","sources":["../../src/types/boundedEvent.ts","../../__vite-browser-external","../../src/collections/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/utils/math.ts","../../src/utils/iterable.ts","../../src/collections/list/circularArrayList.ts","../../src/collections/deque/circularDeque.ts","../../src/utils/linkedNode.ts","../../src/utils/doublyLinkedNode.ts","../../src/collections/list/circularDoublyLinkedList.ts","../../src/collections/deque/circularLinkedDeque.ts","../../src/collections/list/circularLinkedList.ts","../../src/utils/skipNode.ts","../../src/utils/skipStack.ts","../../src/collections/list/circularSkipList.ts","../../src/collections/map/circularMap.ts","../../src/collections/queue/circularLinkedQueue.ts","../../src/collections/queue/circularQueue.ts","../../src/collections/set/circularSet.ts","../../src/collections/stack/circularLinkedStack.ts","../../src/collections/stack/circularStack.ts"],"sourcesContent":["/**\n * An enumeration of event types supported by {@link Bounded} collections.\n *\n * This object defines a set of constants representing event names that can\n * be emitted by instances of collections implementing the {@link Bounded} interface.\n * These events signify specific actions or changes in the state of the collection.\n *\n * Defined events include:\n * - `Overflow`: Indicates that the collection has reached its capacity, and\n *   as a result, one or more elements have been removed to accommodate new elements.\n *   This event is triggered during operations that add elements to the collection when\n *   it exceeds its capacity, or when capacity is updated below the collection's current\n *   size. Listeners attached to this event will receive an array of elements that were\n *   removed due to the overflow. Removed elements may be sent across 1 or more event\n *   instances.\n *\n * This object is marked as `const` to ensure that its properties are read-only,\n * preventing modification of event names which could lead to inconsistencies in\n * event handling across the application.\n */\nexport const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","export default {}","import EventEmitter from \"events\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport class CircularBase<T> {\n  /**\n   * @internal\n   * The event emitter.\n   *\n   */\n  protected _emitter: EventEmitter;\n\n  constructor(emitter = new EventEmitter()) {\n    this._emitter = emitter;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for\n   * the {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * Alternatively, the `addListener()` method can be used to add\n   * the event listener to the end of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  prependListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.prependListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * The maximum number of arguments that can be passed to a function.\n *\n * While ECMAScript specifications do not explicitly limit the number of\n * function arguments, practical limits are imposed by JavaScript engine\n * implementations. Different engines can have different maximums, so a\n * conservative value is used to prevent runtime errors.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-list-and-record-specification-type | ECMAScript Specification},\n * section \"6.2.2 The List and Record Specification Types\".\n */\nexport const ARGS_MAX_LENGTH = 16383; // 2**14 - 1\n\n/**\n * The maximum length of an array.\n *\n * According to the ECMAScript specification, the length property of an array\n * is an unsigned 32-bit integer, so its range is 0 to 2**32 - 1, inclusive.\n * Beyond this, operations that modify the array length (e.g., `push`, `pop`,\n * `unshift`, `shift`) may fail or behave unexpectedly.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-arraycreate | ECMAScript Specification},\n * section \"10.4.2.2 ArrayCreate\".\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1\n\n/**\n * The maximum safe length for a linked structure.\n *\n * This constant is defined as the largest integer value that can be safely\n * represented in JavaScript (`Number.MAX_SAFE_INTEGER`), preventing integer\n * precision loss in length-related operations. Operations with values beyond\n * this number may not behave as expected due to limitations in JavaScript's\n * number representation.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-number.max_safe_integer | ECMAScript Specification},\n * section \"21.1.2.6 Number.MAX_SAFE_INTEGER\".\n */\nexport const LINKED_MAX_LENGTH = Number.MAX_SAFE_INTEGER; // 2**53 - 1\n","import { ARRAY_MAX_LENGTH, LINKED_MAX_LENGTH } from \"./constants\";\n\n/**\n * Checks if a given value is an integer within a valid array length range.\n *\n * This function is useful for validating array lengths before attempting operations\n * that could result in a `RangeError` due to invalid array size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, ARRAY_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a function.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a function, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n/**\n * Checks if a given value is positive infinity.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is positive infinity, `false` otherwise.\n */\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n/**\n * Determines whether the provided value is iterable.\n *\n * This is useful for determining if a value can be used\n * in a `for...of` loop or with spread syntax.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value implements the iterable protocol, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if a given value is an integer within a valid linked length range.\n *\n * This function is useful for validating linked lengths before attempting operations\n * that could result in a `RangeError` due to invalid linked list size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, LINKED_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isLinkedLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= LINKED_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a number.\n *\n * This includes `NaN` and `Infinity`, so consider additional\n * checks if those values are not desirable.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type number, `false` otherwise.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Checks if a given value is a safe integer greater than or equal to 0.\n *\n * This is useful for validating counts or sizes that must be within the safe\n * integer range to prevent precision loss.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a safe integer and non-negative, `false` otherwise.\n */\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\n/**\n * Determines whether the provided value is a symbol.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a symbol, `false` otherwise.\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","/**\n * Adds a specified addend to a value if the value is below a given target.\n *\n * @param value - The initial number.\n * @param addend - The number added if the value is below the target.\n * @param target - The target number for comparison. If the value is below this\n * number, the addend will be added. Defaults to 0 if not specified.\n */\nexport function addIfBelow(value: number, addend: number, target = 0): number {\n  return value >= target ? value : value + addend;\n}\n\n/**\n * Restricts a given numerical value within a specified range [min, max].\n *\n * If the provided value is less than the minimum, the minimum is returned.\n * If it is greater than the maximum, the maximum is returned. If the value\n * is within the range, the value itself is returned. An error is thrown if\n * the minimum range value is greater than the maximum range value, as this\n * represents an invalid range.\n *\n * @param value - The numerical value to clamp.\n * @param min - The minimum allowable value of the range.\n * @param max - The maximum allowable value of the range.\n *\n * @returns The clamped value within the specified range.\n *\n * @throws `RangeError` If `min` is greater than `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError(\"Invalid clamp range; min must be <= max\");\n  }\n  if (value <= min) {\n    return min;\n  }\n  return value <= max ? value : max;\n}\n\n/**\n * Checks if a given numeric value falls within a specified range.\n *\n * @param value - The numeric value to check.\n * @param min - The inclusive lower bound of the range.\n * @param max - The exclusive upper bound of the range.\n *\n * @returns - `true` if `value` is within the range `[min, max)`, `false` otherwise.\n */\nexport function isInRange(value: number, min: number, max: number): boolean {\n  return value >= min && value < max;\n}\n\n/**\n * Calculates the logarithm of a given value with the specified base.\n *\n * This function uses natural logarithms (`Math.log`) for its calculations.\n * If either the value or the base is less than or equal to 0, `NaN` is returned\n * to indicate an invalid operation, as logarithms are not defined for non-positive\n * values and bases.\n *\n * @param value - The numerical value for which to calculate the logarithm. Must be positive.\n * @param base - The base of the logarithm. Must be positive.\n *\n * @returns The calculated logarithm of the value with the given base, or `NaN` for invalid inputs.\n */\nexport function log(value: number, base: number): number {\n  return value >= 0 && base > 0 ? Math.log(value) / Math.log(base) : NaN;\n}\n\n/**\n * Generates a number representing the length of a consecutive run based on a\n * probability threshold.\n *\n * This function iteratively increments a counter as long as the randomly\n * generated numbers from `randomFn` are less than the specified probability\n * threshold, or until the counter reaches the maximum.\n *\n * The function is useful for simulations or models that require a random yet\n * probabilistically constrained sequence length, such as consecutive coin\n * flips.\n *\n * @param probability - The probability threshold.\n * @param max - The maximum value the of the run. Defaults to Infinity.\n * @param randomFn - A function that generates a random number. Defaults to `Math.random`.\n *\n * @returns The length of the run.\n */\nexport function randomRun(\n  probability: number,\n  max = Infinity,\n  randomFn = Math.random\n): number {\n  let count = 0;\n  while (count < max && randomFn() < probability) {\n    ++count;\n  }\n  return count;\n}\n\n/**\n * Attempts to convert a given value to an integer.\n *\n * The function first tries to convert the value to a number. If the result\n * is not valid (i.e. `NaN`), the given `defaultValue` is returned. Otherwise,\n * the function truncates the number to an integer using `Math.trunc`.\n *\n * This is useful for ensuring numerical operations are performed on integers,\n * with a controllable fallback for invalid inputs.\n *\n * @param value - The value to convert to an integer. This can be of any type.\n * @param defaultValue - The fallback value to return if conversion fails. Defaults to 0.\n *\n * @returns The converted integer, or `defaultValue` if conversion is not possible.\n */\nexport function toInteger(value?: unknown, defaultValue = 0): number {\n  value = +value!;\n  return isNaN(value as number) ? defaultValue : Math.trunc(value as number);\n}\n","/**\n * Generates an iterable that yields chunks (arrays) of elements from the input iterable,\n * with each chunk containing up to a specified maximum number of elements. This function\n * is useful for processing or handling large collections of items in smaller, more\n * manageable segments.\n *\n * `chunkSize` is truncated to an integer to ensure expected behavior.\n * If `chunkSize` is less than 1, an empty iterable is generated.\n *\n * Example usage:\n * ```typescript\n * const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n * for (const chunk of chunk(nums, 3)) {\n *   console.log(chunk); // Outputs: [1, 2, 3], [4, 5, 6], [7, 8, 9]\n * }\n * ```\n *\n * @param source - The original iterable to be chunked. Can be any iterable object (e.g., Array, Set, or a custom iterable).\n * @param chunkSize - The maximum size of each chunk. Must be a positive integer; non-integer values are truncated.\n *\n * @returns An iterable iterator that yields each chunk as an array of elements.\n */\nexport function* chunk<T>(\n  source: Iterable<T>,\n  chunkSize: number\n): IterableIterator<T[]> {\n  if (chunkSize < 1) {\n    return;\n  }\n  let chunk: T[] = [];\n  chunkSize = Math.trunc(chunkSize);\n  for (const value of source) {\n    if (chunk.push(value) >= chunkSize) {\n      yield chunk;\n      chunk = [];\n    }\n  }\n  if (chunk.length > 0) {\n    yield chunk;\n  }\n}\n","import { CircularBase } from \"../circularBase\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport { isArrayLength, isInfinity, isNumber } from \"../../utils/is\";\nimport { Bounded } from \"../../types/bounded\";\nimport { ARGS_MAX_LENGTH, ARRAY_MAX_LENGTH } from \"../../utils/constants\";\nimport { List } from \"../../types/list\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../../utils/math\";\nimport { chunk } from \"../../utils/iterable\";\n\nexport class CircularArrayList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The index representing the first element.\n   */\n  protected _head: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The index one more than the last element.\n   */\n  protected _next: number;\n\n  /**\n   * @internal\n   * The number of elements.\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The stored values.\n   */\n  protected _vals: T[];\n\n  /**\n   * Creates a new list. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new list from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this._head = 0;\n    this._isFinite = false;\n    this._size = 0;\n    this._next = 0;\n    this._vals = [];\n\n    // Case 1: input is null or undefined\n    if (capacity == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(capacity)) {\n      this.capacity = capacity;\n      return;\n    }\n\n    // Case 3: input is an iterable\n    for (const vals of chunk(capacity, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularArrayList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size <= 0) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  at(index?: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._vals[this.toIndex(index)];\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._head = 0;\n    this._next = 0;\n    this._vals.length = 0;\n  }\n\n  /*\n  copyWithin(target: number, start: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    target = clamp(addIfBelow(toInteger(target, 0), size), 0, size);\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    const temp = target > start ? target - start : 0;\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size - temp);\n\n    // Copy within\n    this._copyWithin(target, start, end);\n\n    // Return list\n    return this;\n  }\n  */\n\n  /**\n   * @internal\n   */\n  protected _copyWithin(target: number, start: number, end: number): void {\n    // If copying in-place or nothing to copy\n    if (target == start || start >= end) {\n      return;\n    }\n\n    // Get source data segments\n    const capacity = this._capacity - 1;\n    const vals = this._vals;\n    const ranges = this.toRanges(start, end);\n\n    if (target <= start || end <= target) {\n      // Copy from left to right\n      target = this.toIndex(target);\n      for (const [min, max] of ranges) {\n        for (let i = min; i < max; ++i) {\n          vals[target] = vals[i];\n          target = target < capacity ? target + 1 : 0;\n        }\n      }\n    } else {\n      // Copy from right to left\n      target = this.toIndex(target + (end - start));\n      for (const [min, max] of ranges.reverse()) {\n        for (let i = max - 1; i >= min; --i) {\n          target = target > 0 ? target - 1 : capacity;\n          vals[target] = vals[i];\n        }\n      }\n    }\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._delete(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  protected _delete(index: number, deleteCount: number): void {\n    this._copyWithin(index, index + deleteCount, this._size);\n    this._pop(deleteCount);\n  }\n\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this._vals[this.toIndex(ext)]];\n    }\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Fill values\n    this._fill(value, start, end);\n\n    // Return list\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  protected _fill(value: T, start: number, end: number): void {\n    for (const [min, max] of this.toRanges(start, end)) {\n      this._vals.fill(value, min, max);\n    }\n  }\n\n  first(): T | undefined {\n    return this._size > 0 ? this._vals[this._head] : undefined;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this._vals[this.toIndex(ext)];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  has(value: T): boolean {\n    const vals = this._vals;\n    for (const [min, max] of this.toRanges(0, this._size)) {\n      for (let i = min; i < max; ++i) {\n        if (value === vals[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  last(): T | undefined {\n    return this._size > 0\n      ? this._vals[this.toIndex(this._size - 1)]\n      : undefined;\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get and remove first value\n    const value = this._vals[this.toIndex(this._size - 1)];\n    this._pop(1);\n\n    // Return value\n    return value;\n  }\n\n  /**\n   * @internal\n   */\n  protected _pop(N: number): void {\n    // Remove values\n    const newSize = this._size - N;\n    this._fill(undefined as T, newSize, this._size);\n\n    // Update state\n    this._next = this.toIndex(newSize);\n    this._size = newSize;\n  }\n\n  push(...items: T[]): number {\n    // If no items\n    if (items.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(items);\n      return this._size;\n    }\n\n    // Push items\n    this._insert(this._size, items);\n\n    // Return new size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update value\n    index = this.toIndex(index);\n    const prevValue = this._vals[index];\n    this._vals[index] = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get and remove first value\n    const value = this._vals[this._head];\n    this._shift(1);\n\n    // Return value\n    return value;\n  }\n\n  /**\n   * @internal\n   */\n  protected _shift(N: number): void {\n    // Remove items\n    this._fill(undefined as T, 0, N);\n\n    // Update state\n    this._head = this.toIndex(N);\n    this._size -= N;\n  }\n\n  slice(start?: number, end?: number): CircularArrayList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Return slice\n    return this.toList(this._slice(start, end));\n  }\n\n  /**\n   * @internal\n   */\n  protected _slice(start: number, end: number): T[] {\n    const from = this._vals;\n    const to = new Array<T>(end - start);\n\n    let j = 0;\n    for ([start, end] of this.toRanges(start, end)) {\n      for (let i = start; i < end; ++i) {\n        to[j++] = from[i];\n      }\n    }\n\n    return to;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularArrayList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Create output\n    const out = this.toList(this._slice(start, start + deleteCount));\n\n    // Update list\n    this._splice(start, deleteCount, items);\n\n    // Return output\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected _splice(start: number, deleteCount: number, items: T[] = []): void {\n    const addCount = items.length;\n    const replaceCount = Math.min(deleteCount, addCount);\n    const vals = this._vals;\n\n    // Replace values\n    let j = 0;\n    for (const [a, b] of this.toRanges(start, start + replaceCount)) {\n      for (let i = a; i < b; ++i) {\n        vals[i] = items[j++];\n      }\n    }\n\n    // If done\n    if (deleteCount == addCount) {\n      return;\n    }\n\n    // Insert remaining values or finish deletions\n    start += replaceCount;\n    deleteCount < addCount\n      ? this._insert(start, items, replaceCount)\n      : this._delete(start, deleteCount - addCount);\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(\n    start: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(start, items, min, min + free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (start > 0) {\n      const shifted = Math.min(start, N - free);\n      this._overflow(this._slice(0, shifted));\n      this._shift(shifted);\n      start -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = max - free;\n    this._overflow(items.slice(min, mid));\n    this._safePresert(0, items, mid, max);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(\n    vIndex: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n    const vals = this._vals;\n\n    // Make space\n    this._copyWithin(vIndex + N, vIndex, this._size);\n\n    // Insert into space\n    for (const [start, end] of this.toRanges(vIndex, vIndex + N)) {\n      for (let i = start; i < end; ++i) {\n        vals[i] = items[min++];\n      }\n    }\n\n    // Update state\n    this._size += N;\n    this._next = this.toIndex(this._size);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...items: T[]): number {\n    // If no items\n    if (items.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(items);\n      return this._size;\n    }\n\n    // Presert items\n    this._presert(0, items);\n\n    // Return new size\n    return this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(\n    end: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safePresert(end, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safePresert(end, items, max - free, max);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (end < this._size) {\n      const popped = Math.min(this._size - end, N - free);\n      this._overflow(this._slice(this._size - popped, this._size));\n      this._pop(popped);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safePresert(end, items, min, max);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = min + free;\n    this._overflow(items.slice(mid, max));\n    this._safeInsert(this._size, items, min, mid);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safePresert(\n    vIndex: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const capacity = this._capacity;\n    const N = max - min;\n    const vals = this._vals;\n\n    // Make space\n    const newHead = capacity - N;\n    this._copyWithin(newHead, 0, vIndex);\n\n    // Insert into space\n    vIndex += newHead;\n    for (const [start, end] of this.toRanges(vIndex, vIndex + N)) {\n      for (let i = start; i < end; ++i) {\n        vals[i] = items[min++];\n      }\n    }\n\n    // Update state\n    this._size += N;\n    this._head = this.toIndex(newHead);\n  }\n\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this._vals[this.toIndex(ext)];\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: T[]): void {\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * @internal\n   *\n   * Grow capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if list is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n    if (this._size <= this._head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this._next;\n      this._vals.copyWithin(temp, 0, this._next);\n      this._vals.copyWithin(0, this._head, this._head + temp);\n      this._vals.length = this._size;\n      this._head = 0;\n      this._next = this._size;\n    } else if (this._head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this._vals.length = this._head + this._size;\n      this._vals.copyWithin(this._capacity, 0, this._next);\n      this._vals.fill(undefined as T, 0, this._next);\n      this._next = (this._head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this._vals.length = capacity;\n      this._vals.copyWithin(this._capacity, 0, diff);\n      this._vals.copyWithin(0, diff, this._next);\n      const temp = Math.max(diff, this._next - diff);\n      this._vals.fill(undefined as T, temp, this._next);\n      this._next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   *\n   * Returns whether the list is stored sequentially in memory.\n   *\n   * @returns `true` if the list is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this._head < this._next || this._next <= 0;\n  }\n\n  /**\n   * @internal\n   *\n   * Adjusts the list to fit within the given capacity.\n   *\n   * Assumes the list:\n   * - is sequential in memory.\n   * - fits in the given capacity (size \\<= capacity).\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the list was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this._head + this._size;\n\n    // If list fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this._vals.length = tail;\n      this._next = this._vals.length % capacity;\n\n      // If list must be fully moved: [H------T    ]\n    } else if (this._head >= capacity) {\n      this._vals.copyWithin(0, this._head, tail);\n      this._vals.length = this._size;\n      this._head = 0;\n      this._next = this._size % capacity;\n\n      // If list must be partially moved: [--T  H----]\n    } else {\n      this._vals.copyWithin(0, capacity, tail);\n      this._vals.length = capacity;\n      this._next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * @internal\n   *\n   * Shrink capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    if (this._size > capacity) {\n      const shifted = this._size - capacity;\n      this._overflow(this._slice(0, shifted));\n      this._shift(shifted);\n    }\n\n    // Check if list is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of list: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this._vals.copyWithin(this._head - diff, this._head, this._capacity);\n    this._vals.length = capacity;\n    this._head -= diff;\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected toIndex(externalIndex: number): number {\n    return (this._head + externalIndex) % this._capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected toList(items: T[]): CircularArrayList<T> {\n    const out = new CircularArrayList<T>(0);\n    out._vals = items;\n    out._size = items.length;\n    out._capacity = items.length;\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected toRanges(min: number, max: number): [number, number][] {\n    const head = this._head;\n    const mid = this._capacity - head;\n    if (max <= mid) {\n      return [[head + min, head + max]];\n    }\n    if (min >= mid) {\n      return [[min - mid, max - mid]];\n    }\n    return [\n      [head + min, this._capacity],\n      [0, max - mid],\n    ];\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Bounded } from \"../../types/bounded\";\nimport { Deque } from \"../..\";\nimport { CircularArrayList } from \"../list/circularArrayList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularArrayList<T>;\n\n  /**\n   * Creates a new deque. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new deque with the given capacity.\n   *\n   * @param capacity - the deque's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new deque from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the deque.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this._list.first();\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.last();\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  top(): T | undefined {\n    return this._list.last();\n  }\n\n  unshift(...elems: T[]): number {\n    return this._list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { LinkedCore, LinkedNode } from \"../types/linkedNode\";\n\n/**\n * Creates a copy of a segment from a linked list.\n *\n * @param node - The first {@link LinkedNode} of the original list from which\n *               the copy operation begins.\n * @param count - The number of nodes to copy. If the count exceeds the number\n *                of nodes available, only the available nodes are copied.\n *\n * @returns A tuple containing:\n *          - The head {@link LinkedNode} of the new list.\n *          - The tail {@link LinkedNode} of the new list.\n *          - An integer representing the total number of nodes copied.\n */\nexport function copy<T>(\n  node: LinkedNode<T> | undefined,\n  distance: number\n): LinkedCore<T> {\n  // Create new root\n  const root: LinkedNode<T> = { value: undefined as T };\n\n  // For each node\n  let size = 0;\n  let tail = root;\n  while (node != null && size < distance) {\n    // Create a duplicate\n    const dupe: LinkedNode<T> = { value: node.value };\n\n    // Attach the duplicate\n    tail.next = dupe;\n    tail = dupe;\n\n    // Update size\n    ++size;\n\n    // Move to the next node\n    node = node.next;\n  }\n\n  // Return copy\n  tail.next = undefined;\n  return { root, size, tail };\n}\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<T>(\n  prev: LinkedNode<T> | undefined,\n  count: number\n): LinkedCore<T> {\n  // Create new root\n  const root: LinkedNode<T> = { value: undefined as T };\n\n  // Check inputs\n  if (prev == null || count <= 0) {\n    return { root, size: 0, tail: root };\n  }\n\n  // Cut segment\n  const head = prev.next!;\n  const tail = get(head, count - 1)!;\n  prev.next = tail.next;\n  tail.next = undefined;\n\n  // Return cut segment\n  root.next = head;\n  return { root, size: count, tail };\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* entries<T>(node?: LinkedNode<T>): Generator<[number, T]> {\n  for (let i = 0; node != null; ++i) {\n    yield [i, node!.value];\n    node = node!.next;\n  }\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends LinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n  for (let i = 0; node != null && i < index; ++i) {\n    node = node.next;\n  }\n  return node;\n}\n\n/**\n * Determines whether a linked list contains a node with a specified value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * @param node - The node from which to start searching.\n * @param value - The value to search for.\n * @param end - An optional node at which to end the search (exclusive).\n * If not provided, the search continues until the end of the list.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n *\n */\nexport function has<T>(node: LinkedNode<T> | undefined, value: T): boolean {\n  while (node != null) {\n    if (node!.value === value) {\n      return true;\n    }\n    node = node!.next;\n  }\n  return false;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: LinkedNode<T>,\n  values: Iterable<T>\n): LinkedNode<T> {\n  // Convert values to list\n  const { root, size, tail } = toList(values);\n\n  // If no values\n  if (size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  tail!.next = prev.next;\n  prev.next = root.next;\n\n  return tail!;\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list).\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* keys<T>(node?: LinkedNode<T>): Generator<number> {\n  for (let i = 0; node != null; ++i) {\n    yield i;\n    node = node!.next;\n  }\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(values: Iterable<T>): LinkedCore<T> {\n  const root: LinkedNode<T> = { value: undefined as T };\n\n  let size = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { value };\n    tail = tail.next;\n    ++size;\n  }\n  tail.next = undefined;\n\n  return { root, size, tail };\n}\n\n/**\n * Iterates through a linked list, yielding each node's value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* values<T>(node?: LinkedNode<T>): Generator<T> {\n  while (node != null) {\n    yield node!.value;\n    node = node!.next;\n  }\n}\n","import { DoublyLinkedCore, DoublyLinkedNode } from \"../types/doublyLinkedNode\";\n\nimport { get as singlyGet, cut as singlyCut } from \"./linkedNode\";\n\n/**\n * Creates a copy of a segment from a doubly linked list.\n *\n * @param node - The first {@link DoublyLinkedNode} of the original list from\n *               which the copy operation begins.\n * @param count - The number of nodes to copy. If the count exceeds the number\n *                of nodes available, only the available nodes are copied.\n *\n * @returns A tuple containing:\n *          - The head {@link DoublyLinkedNode} of the new list.\n *          - The tail {@link DoublyLinkedNode} of the new list.\n *          - An integer representing the total number of nodes copied.\n */\nexport function copy<T>(\n  node: DoublyLinkedNode<T> | undefined,\n  distance: number\n): DoublyLinkedCore<T> {\n  // Create new root\n  const root: DoublyLinkedNode<T> = { value: undefined as T };\n\n  // Check distance\n  if (node == null || distance <= 0) {\n    return { root, size: 0, tail: root };\n  }\n\n  // For each node\n  let size = 0;\n  let tail = root;\n  while (node != null && size < distance) {\n    // Create a duplicate\n    const dupe: DoublyLinkedNode<T> = { value: node.value };\n\n    // Attach the duplicate\n    tail.next = dupe;\n    dupe.prev = tail;\n    tail = dupe;\n\n    // Update size\n    ++size;\n\n    // Move to the next node\n    node = node.next;\n  }\n\n  // Return copy\n  root.prev = undefined;\n  tail.next = undefined;\n  return { root, size, tail };\n}\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<T>(\n  node: DoublyLinkedNode<T>,\n  count: number\n): DoublyLinkedCore<T> {\n  const seg = singlyCut(node, count) as DoublyLinkedCore<T>;\n  if (seg.size <= 0) {\n    return seg;\n  }\n  seg.root.next!.prev = seg.root;\n  const next = node.next;\n  if (next != null) {\n    next.prev = node;\n  }\n  return seg;\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends DoublyLinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index >= 0) {\n    return singlyGet(node, index);\n  }\n  for (let i = 0; node != null && i > index; --i) {\n    node = node.prev;\n  }\n  return node;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n *\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: DoublyLinkedNode<T>,\n  values: T[]\n): DoublyLinkedNode<T> {\n  // Convert values to list\n  const list = toList(values);\n\n  // If no values\n  if (list.size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  const head = list.root.next!;\n  const tail = list.tail;\n  const next = prev.next;\n  head.prev = prev;\n  tail.next = next;\n  prev.next = head;\n  if (next != null) {\n    next.prev = tail;\n  }\n\n  return tail!;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A {@link DoublyLinkedCore}.\n */\nexport function toList<T>(values: Iterable<T>): DoublyLinkedCore<T> {\n  const root: DoublyLinkedNode<T> = { value: undefined as T };\n\n  let size = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { prev: tail, value } as DoublyLinkedNode<T>;\n    tail = tail.next;\n    ++size;\n  }\n\n  root.prev = undefined;\n  tail.next = undefined;\n  return { root, size, tail };\n}\n","import { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport {\n  DoublyLinkedCore,\n  DoublyLinkedNode,\n  DoublyLinkedNode as Node,\n} from \"../../types/doublyLinkedNode\";\nimport { List } from \"../../types/list\";\n\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../../utils/constants\";\nimport { copy, cut, get, toList } from \"../../utils/doublyLinkedNode\";\nimport { isInfinity, isLinkedLength, isNumber } from \"../../utils/is\";\nimport { chunk } from \"../../utils/iterable\";\nimport {\n  entries,\n  has,\n  keys,\n  values as getValues,\n} from \"../../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../../utils/math\";\n\nimport { CircularBase } from \"../circularBase\";\n\nexport class CircularDoublyLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The root of the linked list\n   */\n  protected _root: Node<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last node in the linked list.\n   */\n  protected _tail: DoublyLinkedNode<T>;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._root = { value: undefined } as Node<T>;\n    this._size = 0;\n    this._tail = this._root;\n\n    // Case 1: input is null or undefined\n    if (capacity == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(capacity)) {\n      this.capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const vals of chunk(capacity, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDoublyLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const { root } = cut(this._root, diff);\n    this._size -= diff;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = this._root;\n    }\n\n    // Emit discarded items\n    for (const array of chunk(getValues(root.next), ARGS_MAX_LENGTH)) {\n      this._overflow(array);\n    }\n  }\n\n  at(index: number): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._get(index).value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tail = this._root;\n    this._root.next = undefined;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    const node = this._get(index);\n    node.prev!.next = node.next;\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    --this._size;\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Update values\n    let node = this._get(start);\n    while (start < end) {\n      node.value = value;\n      node = node.next!;\n      ++start;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  push(...values: T[]): number {\n    // Add values\n    this._insert(this._size, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update node\n    const node = this._get(index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularDoublyLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Check if empty\n    if (start >= end) {\n      return new CircularDoublyLinkedList<T>(0);\n    }\n\n    // Create segment copy\n    const node = this._get(start);\n    const core = copy(node, end - start);\n\n    // Return copied segment as a list\n    const list = new CircularDoublyLinkedList<T>(core.size);\n    list._root = core.root;\n    list._size = core.size;\n    list._tail = core.tail;\n\n    // Return new list\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularDoublyLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items, if any\n    let list: CircularDoublyLinkedList<T>;\n    if (deleteCount <= 0) {\n      list = new CircularDoublyLinkedList<T>(0);\n    } else {\n      const { root, size, tail } = this._cut(start, deleteCount);\n      list = new CircularDoublyLinkedList<T>(size);\n      list._root = root;\n      list._size = size;\n      list._tail = tail;\n    }\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return getValues(this._root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Add values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return getValues(this._root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): DoublyLinkedCore<T> {\n    // Get previous\n    const prev = this._get(start - 1)!;\n\n    // Cut and get removed segment\n    const seg = cut(prev, count);\n\n    // Update size\n    this._size -= count;\n\n    // Update tail\n    if (start >= this._size) {\n      this._tail = prev;\n    }\n\n    // Return cut segment\n    return seg;\n  }\n\n  /**\n   * @internal\n   */\n  protected _get(index: number): Node<T> {\n    const mid = this._size / 2;\n    return ++index <= mid\n      ? get(this._root, index)!\n      : get(this._tail, index - this._size)!;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(getValues(root.next));\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: Iterable<T>): void {\n    if (!Array.isArray(evicted)) {\n      evicted = Array.from(evicted);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(getValues(root.next));\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Sanitize input\n    if (values.length <= 0) {\n      return;\n    }\n\n    // Create segment\n    const { root, size, tail } = toList(values);\n    const head = root.next!;\n\n    // Insert segment\n    const prev = this._get(index - 1);\n    const next = prev.next;\n    head.prev = prev;\n    tail.next = next;\n    prev.next = head;\n    if (next != null) {\n      next.prev = tail;\n    }\n\n    // Update list state\n    this._tail = index < this._size ? this._tail : tail!;\n    this._size += size;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Bounded } from \"../../types/bounded\";\nimport { Deque } from \"../../types/deque\";\n\nimport { CircularDoublyLinkedList } from \"../list/circularDoublyLinkedList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  first(): T | undefined {\n    return this._list.at(0);\n  }\n\n  front(): T | undefined {\n    return this._list.at(0);\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  unshift(...elems: T[]): number {\n    return this._list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded, BoundedEvent } from \"../..\";\nimport { LinkedCore, LinkedNode as Node } from \"../../types/linkedNode\";\nimport { List } from \"../../types/list\";\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../../utils/constants\";\nimport { isInfinity, isLinkedLength, isNumber } from \"../../utils/is\";\nimport { chunk } from \"../../utils/iterable\";\nimport {\n  copy,\n  cut,\n  entries,\n  get,\n  has,\n  keys,\n  toList,\n  values,\n} from \"../../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../../utils/math\";\nimport { CircularBase } from \"../circularBase\";\n\n// splice, unshift\n\nexport class CircularLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The root of the linked list\n   */\n  protected _root: Node<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last node in the linked list.\n   */\n  protected _tail: Node<T>;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._root = { value: undefined } as Node<T>;\n    this._size = 0;\n    this._tail = this._root;\n\n    // Case 1: input is null or undefined\n    if (capacity == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(capacity)) {\n      this.capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const vals of chunk(capacity, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const { root } = cut(this._root, diff);\n    this._size -= diff;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = this._root;\n    }\n\n    // Emit discarded items\n    this._overflow(root.next);\n  }\n\n  at(index?: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._get(index)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tail = this._root;\n    this._root.next = undefined;\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._cut(index, 1);\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n    if (start >= end) {\n      return this;\n    }\n\n    // Fill values\n    let node = this._get(start)!;\n    for (let i = start; i < end; ++i) {\n      node.value = value;\n      node = node.next!;\n    }\n\n    // Return list\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  push(...values: T[]): number {\n    // Add values\n    this._insert(this._size, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Set value\n    const node = this._get(index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Check if empty\n    if (start >= end) {\n      return new CircularLinkedList<T>(0);\n    }\n\n    // Create segment copy\n    const node = this._get(start);\n    const core = copy(node, end - start);\n\n    // Return copied segment as a list\n    const list = new CircularLinkedList<T>(core.size);\n    list._root = core.root;\n    list._size = core.size;\n    list._tail = core.tail;\n\n    // Return new list\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items, if any\n    let list: CircularLinkedList<T>;\n    if (deleteCount <= 0) {\n      list = new CircularLinkedList<T>(0);\n    } else {\n      const { root, size, tail } = this._cut(start, deleteCount);\n      list = new CircularLinkedList<T>(deleteCount);\n      list._root = root;\n      list._size = size;\n      list._tail = tail;\n    }\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this._root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Add values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this._root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): LinkedCore<T> {\n    // Get previous\n    const prev = this._get(start - 1)!;\n\n    // Cut and get removed segment\n    const core = cut(prev, count);\n\n    // Update size\n    this._size -= count;\n\n    // Update tail\n    if (start >= this._size) {\n      this._tail = prev;\n    }\n\n    // Return cut segment\n    return core;\n  }\n\n  /**\n   * @internal\n   */\n  protected _get(index: number): Node<T> {\n    return ++index == this._size ? this._tail : get(this._root, index)!;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(root.next);\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted?: T[] | Node<T>): void {\n    if (evicted == null) {\n      return;\n    }\n    if (Array.isArray(evicted)) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n    for (const array of chunk(values(evicted), ARGS_MAX_LENGTH)) {\n      this._emitter.emit(BoundedEvent.Overflow, array);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(root.next);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Sanitize input\n    if (values.length <= 0) {\n      return;\n    }\n\n    // Create segment\n    const { root, size, tail } = toList(values);\n\n    // Insert segment\n    const prev = this._get(index - 1);\n    tail!.next = prev.next;\n    prev.next = root.next;\n\n    // Update list state\n    this._tail = index < this._size ? this._tail : tail!;\n    this._size += size;\n  }\n}\n","import { SkipLink, SkipCore, SkipNode } from \"../types/skipList\";\nimport { log } from \"./math\";\n\n/**\n * Calculates the maximum level for a skip list based on the given probability\n * factor and expected size.\n *\n * The maximum level determines how many forward pointers each element in the\n * skip list can have, which impacts the overall speed of search, insertion,\n * and deletion operations within the list.\n *\n * @param p - The probability factor used for determining the level. It should\n *          be a number between 0 and 1 (exclusive). The probability factor\n *          affects the sparsity of the skip list; a lower value results in a\n *          shorter, less dense list, while a higher value results in a\n *          taller, denser list.\n * @param expectedSize - The expected number of elements in the skip list. It\n *                     should be a positive integer. The expected size\n *                     influences the optimal maximum level for the list.\n *\n * @returns The calculated optimal maximum level for the skip list. Returns 1\n *          if the probability factor is less than or equal to 0 or the\n *          expected size is less than or equal to 1. Returns Infinity if the\n *          probability factor is 1 or more, indicating an unbounded number of\n *          levels, and likely an error in inputs.\n */\nexport function calcMaxLevel(p: number, expectedSize: number): number {\n  if (p <= 0 || expectedSize <= 1) {\n    return 1;\n  }\n  if (p >= 1) {\n    return Infinity;\n  }\n  return Math.ceil(log(expectedSize, 1 / p));\n}\n\n/**\n * Creates a copy of a segment from a skip list, starting at a specified\n * position and including a specified number of nodes.\n *\n * The copied segment is initialized with its own root node and returns\n * the new list's root, tail nodes at each level, and the total number\n * of nodes copied.\n *\n * @param root - The root {@link SkipNode} of the original skip list from\n *               which the copy operation begins.\n * @param start - The zero-based position in the original list from which to\n *                start copying nodes.\n * @param count - The number of nodes to copy from the start position. If the\n *                count exceeds the number of nodes available, only the\n *                available nodes are copied.\n * @returns A tuple containing:\n *          - The root {@link SkipNode} of the newly created skip list.\n *          - An array of {@link SkipNode}s representing the tail nodes at\n *            each level of the new skip list.\n *          - An integer representing the total number of nodes copied.\n */\nexport function copy<T>(\n  root: SkipNode<T>,\n  start: number,\n  distance: number\n): SkipCore<T> {\n  // Create new root\n  let levels = root.levels.length;\n  const segRoot = gen(undefined as T, levels);\n\n  // Check distance\n  if (distance <= 0) {\n    return { root: segRoot, size: 0, tails: [segRoot] };\n  }\n\n  // Initialize new list\n  const tails = new Array<SkipNode<T>>(levels).fill(segRoot);\n  const indexes = new Array<number>(levels).fill(-1);\n\n  // Get initial node\n  let node: SkipNode<T> | undefined = getClosest(root, start)[0];\n  node = node.levels[0].next;\n\n  // For each node\n  levels = 1;\n  let size = 0;\n  let index = 0;\n  while (node != null && index < distance) {\n    // Update maximum level\n    const L = node.levels.length;\n    levels = levels >= L ? levels : L;\n\n    // Create the duplicate node\n    const dupe = gen(node.value, L);\n\n    // Attach the duplicate at each level\n    for (let lvl = 0; lvl < L; ++lvl) {\n      tails[lvl].levels[lvl] = { next: dupe, span: index - indexes[lvl] };\n      tails[lvl] = dupe;\n      indexes[lvl] = index;\n    }\n\n    // Move to the next node\n    const { next, span } = node.levels[0];\n    index += span;\n    node = next;\n    ++size;\n  }\n\n  // Truncate the output list to the maximum level\n  tails.length = levels;\n  segRoot.levels.length = levels;\n\n  // Update the tail pointers\n  index = indexes[0] + 1;\n  for (let i = 0; i < levels; ++i) {\n    tails[i].levels[i] = { next: undefined, span: index - indexes[i] };\n  }\n\n  // Return the copy\n  return { root: segRoot, size, tails };\n}\n\n/**\n * Iterates through a skip list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the given node and continues the end of the list.\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* entries<T>(node?: SkipNode<T>): Generator<[number, T]> {\n  for (let i = 0; node != null; ++i) {\n    yield [i, node.value];\n    node = node.levels[0].next;\n  }\n}\n\n/**\n * Generates a new skip list node.\n *\n * @param value - The value to be stored in the new skip list node.\n * @param levels - The number of levels the node participates in within the skip list. Defaults to `1`.\n * @param span - The uniform distance to the next node at each level. Defaults to `1`.\n * @param next - The uniform next node at each level. Defaults to `undefined`.\n *\n * @returns A {@link SkipNode} object populated with the specified value and levels array. Each\n *          level in the array is initialized with a `next` pointer and `span` distance set to\n *          the specified values.\n */\nexport function gen<T>(\n  value: T,\n  levels = 1,\n  span = 1,\n  next?: SkipNode<T>\n): SkipNode<T> {\n  const array = new Array<SkipLink<T>>(levels);\n  for (let i = 0; i < levels; ++i) {\n    array[i] = { next, span };\n  }\n  return { value, levels: array };\n}\n\n/**\n * Retrieves the node at the specified distance (span) from the given node.\n *\n * @param node - The node from which to start.\n * @param distance - The distance (span) of the node to retrieve.\n *\n * @returns The node at the specified distance, or `undefined` if not found.\n */\nexport function get<T>(\n  node: SkipNode<T>,\n  distance: number\n): SkipNode<T> | undefined {\n  [node, distance] = getClosest(node, distance);\n  return distance === 0 ? node : undefined;\n}\n\n/**\n * Retrieves the node at the specified distance (span) from the given\n * node, or the closest node within the intended distance.\n *\n * @param node - The node from which to start.\n * @param distance - The distance (span) of the node to retrieve.\n *\n * @returns A tuple of the resulting node and remaining distance.\n * If the intended node was found, the tuple is `[intended node, 0]`.\n * Otherwise, the tuple is `[closest node, remaining distance]`.\n */\nexport function getClosest<T>(\n  node: SkipNode<T>,\n  distance: number\n): [SkipNode<T>, number] {\n  // Check distance\n  if (distance <= 0) {\n    return [node, distance];\n  }\n\n  // Find node\n  let lvl = node.levels.length - 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { next, span } = node.levels[lvl];\n    if (span <= distance && next != null) {\n      // Do nothing\n    } else if (--lvl < 0) {\n      return [node, distance];\n    } else {\n      continue;\n    }\n\n    if (span == distance) {\n      return [next, 0];\n    }\n\n    distance -= span;\n    node = next;\n  }\n}\n\n/**\n * Creates a generator that yields each node in a skip list at a specified level.\n *\n * Iteration begins from a given node up to, but not including, an optional end node. Defaults to level `0`.\n *\n * @param node - The starting {@link SkipNode} from which the iteration begins. If not defined, no nodes are yielded.\n * @param end - An optional {@link SkipNode} at which to end the iteration, exclusive. If provided, the iteration\n *              will halt before yielding this node. If `end` is `undefined`, the iteration will continue until\n *              the end of the list.\n * @param level - The level at which to traverse the skip list, starting from 0 for the base level. Defaults to `0`\n *                if not specified. If a negative value is given, or if the start `node` does not reach this level,\n *                no nodes are yielded.\n */\nexport function* getNodes<T>(\n  node?: SkipNode<T>,\n  level = 0\n): Generator<SkipNode<T>> {\n  if (node == null || level < 0 || node.levels.length <= level) {\n    return;\n  }\n  while (node != null) {\n    yield node;\n    node = node.levels[level].next;\n  }\n}\n\n/**\n * Determines whether a skip list contains a node with a specified value.\n *\n * @param node - The node from which to start searching.\n * @param value - The value to search for.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n */\nexport function has<T>(node: SkipNode<T> | undefined, value: T): boolean {\n  while (node != null) {\n    if (node.value === value) {\n      return true;\n    }\n    node = node.levels[0].next;\n  }\n  return false;\n}\n\n/**\n * Iterates through a skip list, yielding each node's index\n * (position in the list).\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* keys<T>(node?: SkipNode<T>): Generator<number> {\n  for (let i = 0; node != null; ++i) {\n    yield i;\n    node = node!.levels[0].next;\n  }\n}\n\n/**\n * Iterates through a skip list, yielding each node's height.\n *\n * Iteration starts from the `node` node and continues until\n * the end of the list.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* levels<T>(node?: SkipNode<T>): Generator<number> {\n  while (node != null) {\n    yield node.levels.length;\n    node = node.levels[0].next;\n  }\n}\n\n/**\n * Constructs a skip list from an array of levels and an array of values.\n *\n * @param levels - An array of integers that determines the number of\n *                 levels of the corresponding value in the `values` array.\n * @param values - An array of values to be stored in the skip list. Each\n *                 value is assigned to a new node in the list.\n *\n * @returns A tuple containing three elements:\n *          - The first element is the root {@link SkipNode} of the skip list. This is a dummy node immediately\n *            prior to the first value.\n *          - The second element is an array of {@link SkipNode}s representing the tail nodes at each level.\n *          - The third element is an integer `X` representing the number of nodes successfully added to the list,\n *            not including the root node.\n *\n * @remarks\n * - If the lengths of the input arrays do not match, the function operates on the smallest length.\n * - A dummy root node is created and updated to have up to the maximum level in the `levels` array.\n */\nexport function toList<T>(levels: number[], values: T[]): SkipCore<T> {\n  // Get # of values (X) and max level (Y)\n  let Y = -Infinity;\n  const X = Math.min(levels.length, values.length);\n  for (let x = 0; x < X; ++x) {\n    if (Y < levels[x]) {\n      Y = levels[x];\n    }\n  }\n\n  // Check inputs\n  if (Y <= 0 || X <= 0) {\n    const root = gen(undefined as T);\n    return { root, size: 0, tails: [root] };\n  }\n\n  // Create root node and tails array\n  const root: SkipNode<T> = gen(undefined as T, Y, X + 1);\n  const tails = new Array(Y).fill(root);\n\n  // For each value\n  for (let x = 0; x < X; ++x) {\n    // Create node\n    const span = X - x;\n    const nextY = levels[x];\n    const next = gen(values[x], nextY, span);\n\n    // Add node to list\n    for (let y = 0; y < nextY; ++y) {\n      const levels = tails[y].levels;\n      levels[y] = { next, span: levels[y].span - span };\n      tails[y] = next;\n    }\n  }\n\n  // Return root, tails and list length\n  return { root, size: X, tails };\n}\n\n/**\n * Reduces the height of the skip list to the specified level.\n *\n * @param root - The root node of the skip list.\n * @param level - The target level.\n */\nexport function truncateLevels<T>(\n  root: SkipNode<T> | undefined,\n  level: number\n): void {\n  // Check inputs\n  if (root == null || root.levels.length <= level) {\n    return;\n  }\n\n  // Truncate nodes\n  let node: SkipNode<T> = root;\n  while (node != null) {\n    const next = node.levels[level].next;\n    node.levels.length = level;\n    node = next!;\n  }\n}\n\n/**\n * Iterates through a skip list, yielding each node's value.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* values<T>(node?: SkipNode<T>): Generator<T> {\n  while (node != null) {\n    yield node.value;\n    node = node.levels[0].next;\n  }\n}\n","import { SkipCore, SkipNode, SkipStack } from \"../types/skipList\";\n\nimport { gen as genNode } from \"./skipNode\";\n\n/**\n * Creates a copy of the provided skip stack.\n *\n * @param stack - The {@link SkipStack} to be cloned.\n * @returns The copy of the input {@link SkipStack}.\n */\nexport function clone<T>(stack: SkipStack<T>): SkipStack<T> {\n  const N = stack.length;\n  const dupe: SkipStack<T> = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    const { index, node } = stack[i];\n    dupe[i] = { index, node };\n  }\n  return dupe;\n}\n\n/**\n * Cuts a segment from a given skip list.\n *\n * The cut starts at the specified position and spans the given distance. The\n * cut segment is returned as a new skip list.\n *\n * @param core - The {@link SkipCore} representing the skip list from which to cut the segment.\n *               This skip list will be modified to reflect the removal.\n * @param start - The zero-based index indicating the start position of the cut, inclusive.\n * @param distance - The number of elements to be included in the cut segment.\n *\n * @returns A new {@link SkipCore} representing the skip list segment that has been cut.\n *\n * @remarks\n * - The height (levels) of the original list may be reduced if segment removal results in empty levels.\n * - The cut segment's height (levels) may be less than the original list. It will only contain\n *   levels that include nodes within the segment.\n */\nexport function cut<T>(\n  core: SkipCore<T>,\n  start: number,\n  distance: number\n): SkipCore<T> {\n  // Initialize output list\n  const segRoot = genNode(undefined as T);\n  const seg: SkipCore<T> = { root: segRoot, size: 0, tails: [segRoot] };\n\n  // Check inputs\n  if (distance <= 0) {\n    return seg;\n  }\n\n  // Initialize constants\n  const prevStack = getClosest(gen(core.root, -1), start);\n  const tailStack = getClosest(clone(prevStack), distance);\n  const end = tailStack[0].index + tailStack[0].node.levels[0].span;\n\n  // Update inputs\n  let levels = core.root.levels.length;\n  start = prevStack[0].index + prevStack[0].node.levels[0].span;\n  distance = end - start;\n\n  // Detach segment from participating levels\n  let lvl: number;\n  for (lvl = 0; lvl < levels; ++lvl) {\n    const prev = prevStack[lvl];\n    const tail = tailStack[lvl];\n\n    // Check if segment exists at this level\n    if (prev.index >= tail.index) {\n      break;\n    }\n\n    // Connect segment start to new root\n    let edge = prev.node.levels[lvl];\n    let span = prev.index + edge.span - start;\n    segRoot.levels[lvl] = { next: edge.next, span };\n\n    // Remove segment from list\n    edge = tail.node.levels[lvl];\n    span = tail.index - prev.index + (edge.span - distance);\n    prev.node.levels[lvl] = { next: edge.next, span };\n\n    // Detach segment end\n    tail.node.levels[lvl] = { next: undefined, span: end - tail.index };\n    seg.tails[lvl] = tail.node;\n  }\n\n  if (lvl < levels) {\n    // Remove segment from higher levels\n    while (lvl < levels) {\n      const prev = prevStack[lvl];\n      const { next, span } = prev.node.levels[lvl];\n      prev.node.levels[lvl] = { next: next, span: span - distance };\n      ++lvl;\n    }\n  } else {\n    // Remove empty levels from the source list\n    const links = core.root.levels;\n    while (lvl > 1 && links[lvl - 1].next == null) {\n      --lvl;\n    }\n    levels = lvl;\n    links.length = levels;\n    core.tails.length = levels;\n  }\n\n  // Update tails from source list\n  if (end >= core.size) {\n    for (lvl = 0; lvl < levels; ++lvl) {\n      core.tails[lvl] = prevStack[lvl].node;\n    }\n  }\n\n  // Update source list's size\n  core.size -= distance;\n\n  // Return removed segment\n  seg.size = distance;\n  return seg;\n}\n\n/**\n * Generates a skip stack filled with pointers to the given node and index.\n *\n * @param node - The {@link SkipNode} to which all pointers in the generated stack will point.\n * @param index - The index in the skip list at which the node is located. Defaults to `0`.\n *\n * @returns A {@link SkipStack} array, where each level points to `node` with index `index`.\n *          The length of this array is equal to the number of levels in the input node.\n */\nexport function gen<T>(node: SkipNode<T>, index = 0): SkipStack<T> {\n  const N = node.levels.length;\n  const stack: SkipStack<T> = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    stack[i] = { index, node };\n  }\n  return stack;\n}\n\n/**\n * Moves the input stack to point to the nodes closest to a specified distance.\n *\n * @param stack - The {@link SkipStack} representing the current pointers at various levels of the skip list.\n * @param distance - The forward distance to travel. The starting point is based on `stack`'s lowest level.\n *\n * @returns A {@link SkipStack} with pointers to the nodes closest to the specified distance, based\n *          on the initial positions indicated by the input stack.\n *\n * @remarks\n * - If the specified distance is 0 or negative, the stack is not modified, as no traversal is needed.\n * - If the target distance exceeds the bounds of the skip list, the result will point to the furthest possible\n *   nodes within the list.\n */\nexport function getClosest<T>(\n  stack: SkipStack<T>,\n  distance: number\n): SkipStack<T> {\n  // Check inputs\n  if (distance <= 0 || stack.length <= 0) {\n    return stack;\n  }\n\n  let lvl = stack.length - 1;\n  let ptr = stack[lvl];\n  const target = stack[0].index + distance;\n\n  // Find node\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { next, span } = ptr.node.levels[lvl];\n    const nextIndex = ptr.index + span;\n\n    if (nextIndex <= target && next != null) {\n      // Do nothing\n    } else if (--lvl < 0) {\n      break;\n    } else {\n      ptr = stack[lvl];\n      continue;\n    }\n\n    ptr = { index: nextIndex, node: next };\n    stack[lvl] = ptr;\n\n    if (nextIndex == target) {\n      break;\n    }\n  }\n\n  for (let i = 0; i < lvl; ++i) {\n    stack[i] = { index: ptr.index, node: ptr.node };\n  }\n\n  return stack;\n}\n\n/**\n * Inserts a skip list segment (`src`) into another skip list (`dest`) at a specified index.\n *\n * @param dest - The {@link SkipCore} representing the destination skip list into which the segment is to be\n *               inserted. This skip list will be modified to include the nodes from the source segment.\n * @param index - The zero-based position within the destination list at which the source segment is to be inserted.\n * @param src - The {@link SkipCore} representing the source skip list segment to be inserted into the destination\n *              list. This skip list's tail nodes will be modified to contain links within the destination list.\n *\n * @remarks\n * - The function may increase the height (number of levels) of the destination list if the source segment has\n *   more levels than the destination. This ensures that the merged list can accommodate the full structure of\n *   the segment being inserted.\n */\nexport function insert<T>(\n  dest: SkipCore<T>,\n  index: number,\n  src: SkipCore<T>\n): void {\n  // Check source values\n  if (src.size <= 0) {\n    return;\n  }\n\n  // Increase destination's height if necessary\n  const minY = src.tails.length;\n  for (let y = dest.tails.length; y < minY; ++y) {\n    dest.root.levels[y] = { next: undefined, span: dest.size + 1 };\n    dest.tails[y] = dest.root;\n  }\n\n  // Attach segment at given index\n  const prevs = getClosest(gen(dest.root, -1), index);\n  for (let y = 0; y < minY; ++y) {\n    const prev = prevs[y].node;\n    const prevI = prevs[y].index;\n\n    const prevEdge = prev.levels[y];\n    const tail = src.tails[y];\n    const tailEdge = tail.levels[y];\n    const nextI = prevI + prevEdge.span;\n    const nextD = nextI - index;\n    const tailD = tailEdge.span;\n    tail.levels[y] = { next: prevEdge.next, span: nextD + tailD };\n\n    const rootEdge = src.root.levels[y];\n    const headD = rootEdge.span - 1;\n    const prevD = index - prevI;\n    prev.levels[y] = { next: rootEdge.next, span: prevD + headD };\n  }\n\n  // Update higher levels\n  const maxY = dest.tails.length;\n  for (let y = minY; y < maxY; ++y) {\n    const levels = prevs[y].node.levels;\n    const { next, span } = levels[y];\n    levels[y] = { next, span: span + src.size };\n  }\n\n  // Update tails\n  if (index === dest.size) {\n    for (let y = 0; y < minY; ++y) {\n      dest.tails[y] = src.tails[y];\n    }\n  }\n\n  // Update size\n  dest.size += src.size;\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Bounded, BoundedConfig } from \"../../types/bounded\";\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../../utils/constants\";\nimport {\n  SkipList,\n  SkipListConfig,\n  SkipCore,\n  SkipNode,\n} from \"../../types/skipList\";\n\nimport {\n  isArrayLength,\n  isInfinity,\n  isIterable,\n  isLinkedLength,\n  isNumber,\n} from \"../../utils/is\";\nimport { chunk } from \"../../utils/iterable\";\nimport {\n  addIfBelow,\n  clamp,\n  isInRange,\n  randomRun,\n  toInteger,\n} from \"../../utils/math\";\nimport * as NodeUtils from \"../../utils/skipNode\";\nimport * as StackUtils from \"../../utils/skipStack\";\n\nimport { CircularBase } from \"../circularBase\";\n\nexport interface CircularSkipListConfig extends BoundedConfig, SkipListConfig {}\n\nexport class CircularSkipList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, SkipList<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The maximum number of levels in the skip list.\n   */\n  protected _maxLevel: number;\n\n  /**\n   * @internal\n   * The probability factor used to randomly determine the levels\n   * of new nodes. Should be a value between 0 and 1, where a lower\n   * value results in fewer levels on average.\n   */\n  protected _p: number;\n\n  /**\n   * @internal\n   * The root of the skip list\n   */\n  protected _root: SkipNode<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last nodes in the skip list at each level.\n   */\n  protected _tails: SkipNode<T>[];\n\n  constructor();\n  constructor(capacity?: number | null);\n  constructor(config: CircularSkipListConfig);\n  constructor(items: Iterable<T>);\n  constructor(config?: CircularSkipListConfig | Iterable<T> | null | number) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._p = 0.5;\n    this._maxLevel = NodeUtils.calcMaxLevel(this._p, LINKED_MAX_LENGTH);\n    this._root = NodeUtils.gen(undefined as T);\n    this._size = 0;\n    this._tails = [this._root];\n\n    // Case 1: input is null or undefined\n    if (config == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(config)) {\n      this.capacity = config;\n      return;\n    }\n\n    // Case 3: input is config\n    if (!isIterable(config)) {\n      this.capacity = config.capacity ?? this._capacity;\n      this.p = config.p ?? this._p;\n      const size = config.expectedSize ?? this._capacity;\n      this.maxLevel = config.maxLevel ?? NodeUtils.calcMaxLevel(this._p, size);\n      return;\n    }\n\n    // Case 4: input is an iterable\n    for (const vals of chunk(config, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get levels(): number {\n    return this._root.levels.length;\n  }\n\n  get maxLevel(): number {\n    return this._maxLevel;\n  }\n\n  get p(): number {\n    return this._p;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularSkipList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink list and emit discarded items\n    const { root } = this._cut(0, this._size - capacity);\n    this._overflow(root.levels[0].next);\n  }\n\n  set maxLevel(maxLevel: number) {\n    // Convert input to number\n    maxLevel = +maxLevel;\n\n    // If input is invalid\n    if (!isArrayLength(maxLevel) || maxLevel <= 0) {\n      throw new RangeError(\"Invalid maxLevel\");\n    }\n\n    // Update\n    this._maxLevel = maxLevel;\n\n    // Remove excess levels\n    if (maxLevel < this.levels) {\n      NodeUtils.truncateLevels(this._root, maxLevel);\n    }\n  }\n\n  set p(p: number) {\n    // Convert input to number\n    p = +p;\n\n    // If input is invalid\n    if (isNaN(p) || p < 0 || p > 1) {\n      throw new RangeError(\"Invalid p\");\n    }\n\n    // Update\n    this._p = p;\n  }\n\n  at(index: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return NodeUtils.get(this._root, index + 1)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tails = [this._root];\n    this._root.levels.length = 1;\n    this._root.levels[0] = { next: undefined, span: 1 };\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._cut(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return NodeUtils.entries(this._root.levels[0].next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n    if (start >= end) {\n      return this;\n    }\n\n    // Fill values\n    let node = NodeUtils.get(this._root, start + 1)!;\n    for (let i = start; i < end; ++i) {\n      node.value = value;\n      node = node.levels[0].next!;\n    }\n\n    // Return list\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.levels[0].next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return NodeUtils.has(this._root.levels[0].next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return NodeUtils.keys(this._root.levels[0].next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.levels[0].next!.value;\n  }\n\n  push(...values: T[]): number {\n    // Add values\n    this._insert(this._size, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Set value\n    const node = NodeUtils.get(this._root, index + 1)!;\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.levels[0].next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularSkipList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Create config\n    const config: CircularSkipListConfig = {\n      capacity: 0,\n      p: this._p,\n      maxLevel: this._maxLevel,\n    };\n\n    // Check if empty\n    if (start >= end) {\n      return new CircularSkipList<T>(config);\n    }\n\n    // Create segment copy\n    const core = NodeUtils.copy(this._root, start, end - start);\n\n    // Return copied segment as a list\n    config.capacity = core.size;\n    const list = new CircularSkipList<T>(config);\n    list._root = core.root;\n    list._tails = core.tails;\n    list._size = core.size;\n\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularSkipList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items\n    const core = this._cut(start, deleteCount);\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    const list = new CircularSkipList<T>({\n      capacity: deleteCount,\n      p: this._p,\n      maxLevel: this._maxLevel,\n    });\n    list._root = core.root;\n    list._tails = core.tails;\n    list._size = core.size;\n\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...values: T[]): number {\n    // Add values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return NodeUtils.values(this._root.levels[0].next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): SkipCore<T> {\n    // Create list core\n    const core = { root: this._root, size: this._size, tails: this._tails };\n\n    // Cut and get removed segment\n    const seg = StackUtils.cut(core, start, count);\n\n    // Update list state\n    this._size = core.size;\n    this._tails = core.tails;\n\n    // Return cut segment\n    return seg;\n  }\n\n  /**\n   * @internal\n   */\n  protected _genLevels(N: number): number[] {\n    const levels = new Array<number>(N);\n    const maxLevel = this._maxLevel - 1;\n    for (let i = 0; i < N; ++i) {\n      levels[i] = 1 + randomRun(this._p, maxLevel);\n    }\n    return levels;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(root.levels[0].next);\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted?: T[] | SkipNode<T>): void {\n    if (evicted == null) {\n      return;\n    }\n    if (Array.isArray(evicted)) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n    for (const array of chunk(NodeUtils.values(evicted), ARGS_MAX_LENGTH)) {\n      this._emitter.emit(BoundedEvent.Overflow, array);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(root.levels[0].next);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Create segment\n    const levels = this._genLevels(values.length);\n    const seg = NodeUtils.toList(levels, values);\n\n    // Insert segment\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    StackUtils.insert(core, index, seg);\n\n    // Update list state\n    this._size = core.size;\n    this._tails = core.tails;\n  }\n}\n","import { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Collection } from \"../../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../../utils/is\";\n\nimport { CircularBase } from \"../circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The internal map.\n   */\n  protected _map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this._map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this._map = new Map(capacity as Iterable<[K, V]>);\n    this._capacity = this._map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the map.\n   */\n  get size(): number {\n    return this._map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this._map);\n      this.clear();\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this._map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this._map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this._map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this._map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this._map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this._map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this._map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this._map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this._map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this._emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this._map.delete(key) && this.size >= this.capacity) {\n      const entry = this._map.entries().next().value;\n      this._map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this._map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this._map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this._map.values();\n  }\n}\n","import { Queue } from \"../../types/queue\";\nimport { Bounded } from \"../../types/bounded\";\n\nimport { CircularLinkedList } from \"../list/circularLinkedList\";\nimport { BoundedEvent } from \"../..\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.at(0);\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  front(): T | undefined {\n    return this._list.at(0);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Queue } from \"../../types/queue\";\nimport { Bounded } from \"../../types/bounded\";\nimport { CircularArrayList } from \"../list/circularArrayList\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  first(): T | undefined {\n    return this.list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this.list.first();\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Collection } from \"../../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../../utils/is\";\n\nimport { CircularBase } from \"../circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The internal set.\n   */\n  protected set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.set = new Set(capacity as Iterable<T>);\n    this._capacity = this.set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the set.\n   */\n  get size(): number {\n    return this.set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.set);\n      this.clear();\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this.set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this.set.delete(value);\n      evicted.push(value);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this._emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this.set.delete(value) && this.size >= this.capacity) {\n      const out = this.set.values().next().value;\n      this.set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this.set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this.set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this.set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this.set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this.set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this.set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.set.values();\n  }\n}\n","import { Stack } from \"../../types/stack\";\nimport { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent, CircularDoublyLinkedList } from \"../..\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Stack } from \"../../types/stack\";\nimport { Bounded } from \"../../types/bounded\";\nimport { CircularArrayList } from \"../list/circularArrayList\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.last();\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  top(): T | undefined {\n    return this.list.last();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n"],"names":["BoundedEvent","EventEmitter","CircularBase","emitter","__publicField","event","listener","ARGS_MAX_LENGTH","ARRAY_MAX_LENGTH","LINKED_MAX_LENGTH","isArrayLength","value","isInfinity","isIterable","isLinkedLength","isNumber","isSafeCount","addIfBelow","addend","target","clamp","min","max","isInRange","log","base","randomRun","probability","randomFn","count","toInteger","defaultValue","chunk","source","chunkSize","CircularArrayList","capacity","vals","index","start","end","ranges","i","deleteCount","ext","size","callbackfn","thisArg","N","newSize","items","prevValue","from","to","j","out","addCount","replaceCount","a","b","free","shifted","mid","vIndex","popped","newHead","evicted","temp","diff","tail","externalIndex","head","CircularDeque","v","elems","copy","node","distance","root","dupe","cut","prev","get","entries","has","keys","toList","values","seg","singlyCut","next","singlyGet","CircularDoublyLinkedList","array","getValues","core","list","CircularLinkedDeque","CircularLinkedList","calcMaxLevel","p","expectedSize","levels","segRoot","gen","tails","indexes","getClosest","L","lvl","span","Y","X","x","nextY","y","truncateLevels","level","clone","stack","genNode","prevStack","tailStack","edge","links","ptr","nextIndex","insert","dest","src","minY","prevs","prevI","prevEdge","tailEdge","nextD","tailD","rootEdge","headD","prevD","maxY","CircularSkipList","config","NodeUtils.calcMaxLevel","NodeUtils.gen","maxLevel","NodeUtils.truncateLevels","NodeUtils.get","NodeUtils.entries","NodeUtils.has","NodeUtils.keys","NodeUtils.copy","NodeUtils.values","StackUtils.cut","NodeUtils.toList","StackUtils.insert","CircularMap","iter","n","entry","key","CircularLinkedQueue","CircularQueue","CircularSet","CircularLinkedStack","CircularStack"],"mappings":"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"}