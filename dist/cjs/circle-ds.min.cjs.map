{"version":3,"file":"circle-ds.min.cjs","sources":["../../src/types/boundedEvent.ts","../../__vite-browser-external","../../src/circle/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/utils/math.ts","../../src/circle/circularArrayList.ts","../../src/circle/circularDeque.ts","../../src/utils/linkedNode.ts","../../src/utils/doublyLinkedNode.ts","../../src/circle/circularDoublyLinkedList.ts","../../src/circle/circularLinkedDeque.ts","../../src/circle/circularLinkedList.ts","../../src/circle/circularLinkedQueue.ts","../../src/circle/circularLinkedStack.ts","../../src/circle/circularMap.ts","../../src/circle/circularQueue.ts","../../src/circle/circularSet.ts","../../src/circle/circularStack.ts"],"sourcesContent":["/**\n * An enumeration of event types supported by {@link Bounded} collections.\n *\n * This object defines a set of constants representing event names that can\n * be emitted by instances of collections implementing the {@link Bounded} interface.\n * These events signify specific actions or changes in the state of the collection.\n *\n * Defined events include:\n * - `Overflow`: Indicates that the collection has reached its capacity, and\n *   as a result, one or more elements have been removed to accommodate new elements.\n *   This event is triggered during operations that add elements to the collection when\n *   it exceeds its capacity, or when capacity is updated below the collection's current\n *   size. Listeners attached to this event will receive an array of elements that were\n *   removed due to the overflow. Removed elements may be sent across 1 or more event\n *   instances.\n *\n * This object is marked as `const` to ensure that its properties are read-only,\n * preventing modification of event names which could lead to inconsistencies in\n * event handling across the application.\n */\nexport const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","export default {}","import EventEmitter from \"events\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport class CircularBase<T> {\n  /**\n   * The event emitter.\n   * @internal\n   */\n  protected emitter: EventEmitter;\n\n  constructor(emitter = new EventEmitter()) {\n    this.emitter = emitter;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for\n   * the {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * Alternatively, the `addListener()` method can be used to add\n   * the event listener to the end of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  prependListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.prependListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * Represents the maximum number of arguments that can be passed to a function.\n *\n * While ECMAScript specifications do not explicitly limit the number of function arguments,\n * practical limits are imposed by JavaScript engine implementations. Different engines can\n * have different maximums, so a conservative value is used to prevent runtime errors.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-list-and-record-specification-type | ECMAScript Specification},\n * section \"6.2.2 The List and Record Specification Types\".\n */\nexport const ARGS_MAX_LENGTH = 16383; // 2**14 - 1\n\n/**\n * Defines the maximum allowable length of an array.\n *\n * According to the ECMAScript specification, the length property of an array is\n * an unsigned 32-bit integer, so its range is 0 to 2**32 - 1, inclusive. Beyond this,\n * operations that modify the array length (e.g., `push`, `pop`, `unshift`, `shift`)\n * may fail or behave unexpectedly.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-arraycreate | ECMAScript Specification},\n * section \"10.4.2.2 ArrayCreate\".\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1;\n","import { ARRAY_MAX_LENGTH } from \"./constants\";\n\n/**\n * Checks if a given value is an integer within a valid array length range.\n *\n * This function is useful for validating array lengths before attempting operations\n * that could result in a `RangeError` due to invalid array size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, ARRAY_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a function.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a function, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n/**\n * Checks if a given value is positive infinity.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is positive infinity, `false` otherwise.\n */\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n/**\n * Determines whether the provided value is iterable.\n *\n * This is useful for determining if a value can be used\n * in a `for...of` loop or with spread syntax.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value implements the iterable protocol, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\n/**\n * Determines whether the provided value is a number.\n *\n * This includes `NaN` and `Infinity`, so consider additional\n * checks if those values are not desirable.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type number, `false` otherwise.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Checks if a given value is a safe integer greater than or equal to 0.\n *\n * This is useful for validating counts or sizes that must be within the safe\n * integer range to prevent precision loss.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a safe integer and non-negative, `false` otherwise.\n */\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\n/**\n * Determines whether the provided value is a symbol.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a symbol, `false` otherwise.\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","/**\n * Adds a specified addend to a value if the value is below a given target.\n *\n * @param value - The initial number.\n * @param addend - The number added if the value is below the target.\n * @param target - The target number for comparison. If the value is below this\n * number, the addend will be added. Defaults to 0 if not specified.\n */\nexport function addIfBelow(value: number, addend: number, target = 0): number {\n  return value >= target ? value : value + addend;\n}\n\n/**\n * Restricts a given numerical value within a specified range [min, max].\n *\n * If the provided value is less than the minimum, the minimum is returned.\n * If it is greater than the maximum, the maximum is returned. If the value\n * is within the range, the value itself is returned. An error is thrown if\n * the minimum range value is greater than the maximum range value, as this\n * represents an invalid range.\n *\n * @param value - The numerical value to clamp.\n * @param min - The minimum allowable value of the range.\n * @param max - The maximum allowable value of the range.\n *\n * @returns The clamped value within the specified range.\n *\n * @throws `RangeError` If `min` is greater than `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError(\"Invalid clamp range; min must be <= max\");\n  }\n  if (value <= min) {\n    return min;\n  }\n  return value <= max ? value : max;\n}\n\n/**\n * Checks if a given numeric value falls within a specified range.\n *\n * @param value - The numeric value to check.\n * @param min - The inclusive lower bound of the range.\n * @param max - The exclusive upper bound of the range.\n *\n * @returns - `true` if `value` is within the range `[min, max)`, `false` otherwise.\n */\nexport function isInRange(value: number, min: number, max: number): boolean {\n  return value >= min && value < max;\n}\n\n/**\n * Calculates the logarithm of a given value with the specified base.\n *\n * This function uses natural logarithms (`Math.log`) for its calculations.\n * If either the value or the base is less than or equal to 0, `NaN` is returned\n * to indicate an invalid operation, as logarithms are not defined for non-positive\n * values and bases.\n *\n * @param value - The numerical value for which to calculate the logarithm. Must be positive.\n * @param base - The base of the logarithm. Must be positive.\n *\n * @returns The calculated logarithm of the value with the given base, or `NaN` for invalid inputs.\n */\nexport function log(value: number, base: number): number {\n  return value >= 0 && base > 0 ? Math.log(value) / Math.log(base) : NaN;\n}\n\n/**\n * Generates a number representing the length of a consecutive run based on a\n * probability threshold.\n *\n * This function iteratively increments a counter as long as the randomly\n * generated numbers from `randomFn` are less than the specified probability\n * threshold `p`, or until the counter reaches the maximum `max`.\n *\n * The function is useful for simulations or models that require a random yet\n * probabilistically constrained sequence length, such as simulating streaks or\n * runs in games of chance.\n *\n * @param p - The probability threshold. Defaults to 0.5.\n * @param max - The maximum value the of the run. Defaults to Infinity.\n * @param min - The starting value of the run. Defaults to 0.\n * @param randomFn - A function that generates a random number. Defaults to `Math.random`.\n *\n * @returns The length of the run.\n */\nexport function randomRun(\n  p = 0.5,\n  max = Infinity,\n  min = 0,\n  randomFn = Math.random\n): number {\n  while (min < max && randomFn() < p) {\n    ++min;\n  }\n  return min;\n}\n\n/**\n * Attempts to convert a given value to an integer.\n *\n * The function first tries to convert the value to a number. If the result\n * is not valid (i.e. `NaN`), the given `defaultValue` is returned. Otherwise,\n * the function truncates the number to an integer using `Math.trunc`.\n *\n * This is useful for ensuring numerical operations are performed on integers,\n * with a controllable fallback for invalid inputs.\n *\n * @param value - The value to convert to an integer. This can be of any type.\n * @param defaultValue - The fallback value to return if conversion fails. Defaults to 0.\n *\n * @returns The converted integer, or `defaultValue` if conversion is not possible.\n */\nexport function toInteger(value?: unknown, defaultValue = 0): number {\n  value = +value!;\n  return isNaN(value as number) ? defaultValue : Math.trunc(value as number);\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\nimport { List } from \"../types/list\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../utils/math\";\n\nexport class CircularArrayList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new list. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new list from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    if (capacity == null || isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    this.vals = Array.from(capacity as Iterable<T>);\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularArrayList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size <= 0) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  at(index?: number): T | undefined {\n    // Check input index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this.vals[this.toIndex(index)];\n  }\n\n  clear(): void {\n    this._size = 0;\n    this.head = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  copyWithin(target: number, start?: number, end?: number): this {\n    // Sanitize inputs\n    const size = this._size;\n    target = clamp(addIfBelow(toInteger(target, 0), size), 0, size);\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = addIfBelow(toInteger(end, size), size);\n    end = clamp(end, start, size - Math.min(0, target - start));\n    if (target >= size || start >= end) {\n      return this;\n    }\n\n    // Copy within\n    this._copyWithin(target, start, end);\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  protected _copyWithin(target: number, start: number, end: number): void {\n    if (target == start) {\n      return;\n    }\n\n    const isFwd = target <= start || end <= target;\n    const max = this._capacity - 1;\n    const vals = this.vals;\n\n    let targetEnd = this.toIndex(target + (end - start));\n    end = this.toIndex(end);\n    start = this.toIndex(start);\n    target = this.toIndex(target);\n\n    if (isFwd) {\n      while (start != end) {\n        vals[target] = vals[start];\n        start = start < max ? start + 1 : 0;\n        target = target < max ? target + 1 : 0;\n      }\n    } else {\n      while (start != end) {\n        end = end > 0 ? end - 1 : max;\n        targetEnd = targetEnd > 0 ? targetEnd - 1 : max;\n        vals[targetEnd] = vals[end];\n      }\n    }\n  }\n\n  delete(index: number): boolean {\n    // Check input index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._delete(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  protected _delete(index: number, deleteCount: number): void {\n    this._copyWithin(index, index + deleteCount, this._size);\n    this._pop(deleteCount);\n  }\n\n  *entries(): IterableIterator<[number, T]> {\n    const vals = this.vals;\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, vals[this.toIndex(ext)]];\n    }\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, size), 0, size);\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(addIfBelow(end, size), start, size);\n\n    // Fill values\n    this._fill(value, start, end);\n\n    // Return list\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  protected _fill(value: T, start: number, end: number): void {\n    for (const [min, max] of this.toRanges(start, end)) {\n      this.vals.fill(value, min, max);\n    }\n  }\n\n  first(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    const vals = this.vals;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = vals[this.toIndex(ext)];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  has(value: T): boolean {\n    const N = this._size;\n    const vals = this.vals;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === vals[this.toIndex(ext)]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  last(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get tail\n    const tail = this.next > 0 ? this.next - 1 : this._capacity - 1;\n\n    // Return value\n    return this.vals[tail];\n  }\n\n  pop(): T | undefined {\n    return this._size > 0 ? this._pop(1)[0] : undefined;\n  }\n\n  /**\n   * @internal\n   */\n  protected _pop(N: number): T[] {\n    const capacity = this._capacity;\n    const evicted: T[] = [];\n    const vals = this.vals;\n\n    // Remove values\n    let tail = this.next;\n    for (let i = 0; i < N; ++i) {\n      tail = tail > 0 ? tail - 1 : capacity - 1;\n      evicted.push(vals[tail]);\n      vals[tail] = undefined as T;\n    }\n\n    // Update state\n    this.next = tail;\n    this._size -= N;\n    if (this._size <= 0) {\n      this.clear();\n    }\n\n    return evicted;\n  }\n\n  push(...values: T[]): number {\n    // If no values\n    if (values.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return this._size;\n    }\n\n    // Push values\n    this._push(values);\n    return this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected _push(elems: T[], start = 0): void {\n    const capacity = this._capacity;\n    const evicted: T[] = [];\n    const N = elems.length;\n    const vals = this.vals;\n\n    let next = this.next;\n    for (let i = start; i < N; ++i) {\n      next = ++next < capacity ? next : 0;\n      if (this._size < capacity) {\n        ++this._size;\n      } else if (!this.isFinite) {\n        throw new Error(\"Out of memory\");\n      } else {\n        evicted.push(vals[this.next]);\n        this.head = next;\n      }\n      vals[this.next] = elems[i];\n      this.next = next;\n    }\n\n    if (evicted.length > 0) {\n      this._overflow(evicted);\n    }\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check input index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update value\n    index = this.toIndex(index);\n    const prevValue = this.vals[index];\n    this.vals[index] = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    return this._size > 0 ? this._shift(1)[0] : undefined;\n  }\n\n  /**\n   * @internal\n   */\n  protected _shift(N: number): T[] {\n    const capacity = this._capacity;\n    const evicted: T[] = [];\n    const vals = this.vals;\n\n    for (let i = 0; i < N; ++i) {\n      evicted.push(vals[this.head]);\n      vals[this.head] = undefined as T;\n      --this._size;\n      if (++this.head >= capacity) {\n        this.head = 0;\n        vals.length = this.next;\n      }\n    }\n\n    return evicted;\n  }\n\n  slice(start?: number, end?: number): CircularArrayList<T> {\n    const out = new CircularArrayList<T>(0);\n\n    // Check if empty\n    const size = this._size;\n    if (size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, size), 0, size);\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(addIfBelow(end, size), start, size);\n\n    // Return slice\n    return this.toList(this._slice(start, end));\n  }\n\n  /**\n   * @internal\n   */\n  protected _slice(start: number, end: number): T[] {\n    const from = this.vals;\n    const to = new Array<T>(end - start);\n\n    let target = 0;\n    for ([start, end] of this.toRanges(start, end)) {\n      for (let i = start; i < end; ++i) {\n        to[target++] = from[i];\n      }\n    }\n    return to;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularArrayList<T> {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, size), 0, size);\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, size - start);\n\n    // Create output\n    const out = this.toList(this._slice(start, start + deleteCount));\n\n    // Update list\n    this._splice(start, deleteCount, items);\n\n    // Add values\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected _splice(start: number, deleteCount: number, items: T[] = []): void {\n    const addCount = items.length;\n    const capacity = this._capacity;\n    const replaceCount = Math.min(deleteCount, addCount);\n    const vals = this.vals;\n\n    // Replace values\n    let index = this.toIndex(start);\n    for (let i = 0; i < replaceCount; ++i) {\n      vals[index++] = items[i];\n      index = index < capacity ? index : 0;\n    }\n\n    // If done\n    if (deleteCount == addCount) {\n      return;\n    }\n\n    // Insert or delete values\n    start += replaceCount;\n    deleteCount < addCount\n      ? this._insert(start, items, replaceCount)\n      : this._delete(start, deleteCount - addCount);\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(\n    start: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this.isFinite) {\n      this._safeInsert(start, items, min, min + free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    const shifted = Math.min(start, N);\n    this._overflow(this._shift(shifted));\n    start -= shifted;\n    free += shifted;\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Remove items and insert remaining\n    const mid = max - free;\n    this._overflow(items.slice(min, mid));\n    this._safeUnshift(items, mid, max);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(\n    start: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const capacity = this._capacity;\n    const N = max - min;\n    const vals = this.vals;\n\n    // Make space\n    this._copyWithin(start + N, start, this._size);\n\n    // Insert into space\n    let index = this.toIndex(start);\n    for (let i = min; i < max; ++i) {\n      vals[index++] = items[i];\n      index = index < capacity ? index : 0;\n    }\n\n    // Update state\n    this._size += N;\n    this.next = this.toIndex(this.next + N);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...values: T[]): number {\n    // If no values\n    if (values.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return this._size;\n    }\n\n    this._unshift(values);\n    return this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected _unshift(elems: T[]): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n    const evicted: T[] = [];\n\n    let head = this.head;\n    for (let i = elems.length - 1; i >= 0; --i) {\n      head = head > 0 ? head - 1 : capacity - 1;\n      if (this._size < capacity) {\n        ++this._size;\n      } else if (!this.isFinite) {\n        throw new Error(\"Out of memory\");\n      } else {\n        evicted.push(vals[head]);\n        this.next = head;\n      }\n      vals[head] = elems[i];\n      this.head = head;\n    }\n\n    if (evicted.length > 0) {\n      this._overflow(evicted.reverse());\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeUnshift(elems: T[], min = 0, max = elems.length): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let head = this.head;\n    for (let i = max - 1; i >= min; --i) {\n      head = head > 0 ? head - 1 : capacity - 1;\n      vals[head] = elems[i];\n    }\n\n    this.head = head;\n    this._size += max - min;\n  }\n\n  *values(): IterableIterator<T> {\n    const vals = this.vals;\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield vals[this.toIndex(ext)];\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * @internal\n   *\n   * Grow capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if list is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   *\n   * Returns whether the list is stored sequentially in memory.\n   *\n   * @returns `true` if the list is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next <= 0;\n  }\n\n  /**\n   * @internal\n   *\n   * Adjusts the list to fit within the given capacity.\n   *\n   * Assumes the list:\n   * - is sequential in memory.\n   * - fits in the given capacity (size \\<= capacity).\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the list was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If list fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If list must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If list must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * @internal\n   *\n   * Shrink capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    this._overflow(this._shift(this._size - capacity));\n\n    // Check if list is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of list: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected toIndex(externalIndex: number): number {\n    return (this.head + externalIndex) % this._capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected toList(values: T[]): CircularArrayList<T> {\n    const out = new CircularArrayList<T>(0);\n    out.vals = values;\n    out._size = values.length;\n    out._capacity = values.length;\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected toRanges(min: number, max: number): [number, number][] {\n    const head = this.head;\n    const mid = this._capacity - this.head;\n    if (max <= mid) {\n      return [[head + min, head + max]];\n    }\n    if (min >= mid) {\n      return [[min - mid, max - mid]];\n    }\n    return [\n      [head + min, this._capacity],\n      [0, max - mid],\n    ];\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Bounded } from \"../types/bounded\";\nimport { Deque } from \"..\";\nimport { CircularArrayList } from \"./circularArrayList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new deque. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new deque with the given capacity.\n   *\n   * @param capacity - the deque's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new deque from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the deque.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  first(): T | undefined {\n    return this.list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this.list.first();\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.last();\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  top(): T | undefined {\n    return this.list.last();\n  }\n\n  unshift(...elems: T[]): number {\n    return this.list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { LinkedNode } from \"../types/linkedNode\";\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<N extends LinkedNode<unknown>>(\n  prev: N,\n  count: number\n): [N, N] | [undefined, undefined] {\n  if (count <= 0) {\n    return [undefined, undefined];\n  }\n  const head = prev.next!;\n  const tail = get(head, count - 1)!;\n  prev.next = tail.next;\n  tail.next = undefined;\n  return [head, tail];\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* entries<T>(\n  node?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<[number, T]> {\n  for (let i = 0; node != end; ++i) {\n    yield [i, node!.value];\n    node = node!.next;\n  }\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends LinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n  for (let i = 0; node != null && i < index; ++i) {\n    node = node.next;\n  }\n  return node;\n}\n\n/**\n * Determines whether a linked list contains a node with a specified value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * @param node - The node from which to start searching.\n * @param value - The value to search for.\n * @param end - An optional node at which to end the search (exclusive).\n * If not provided, the search continues until the end of the list.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n *\n */\nexport function has<T>(\n  node: LinkedNode<T> | undefined,\n  value: T,\n  end?: LinkedNode<T>\n): boolean {\n  while (node != end) {\n    if (node!.value === value) {\n      return true;\n    }\n    node = node!.next;\n  }\n  return false;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: LinkedNode<T>,\n  values: Iterable<T>\n): LinkedNode<T> {\n  // Convert values to list\n  const [head, tail, size] = toList(values);\n\n  // If no values\n  if (size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  tail!.next = prev.next;\n  prev.next = head;\n\n  return tail!;\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list).\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* keys<T>(\n  node?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<number> {\n  for (let i = 0; node != end; ++i) {\n    yield i;\n    node = node!.next;\n  }\n}\n\n/**\n * Finds the tail of the linked list and the distance to it.\n *\n * This function iterates through the linked list starting from the `node`\n * node, counting each node until it reaches the tail of the list (\n * where node.next is null or undefined).\n *\n * @param node - The node from which to start counting.\n *\n * @returns a tuple with the tail and distance to it.\n */\nexport function getTail(node?: null): [undefined, -1];\nexport function getTail<N extends LinkedNode<unknown>>(node: N): [N, number];\nexport function getTail<N extends LinkedNode<unknown>>(\n  node?: N | null\n): [N, number] | [undefined, -1];\nexport function getTail<N extends LinkedNode<unknown>>(\n  node?: N | null\n): [N, number] | [undefined, -1] {\n  if (node == null) {\n    return [undefined, -1];\n  }\n  let count = 0;\n  while (node.next != null) {\n    node = node.next;\n    ++count;\n  }\n  return [node, count];\n}\n\n/**\n * Converts a linked list into an array of values.\n *\n * The conversion starts from the `node` node and includes all nodes up to the\n * end of the list, or the `end` node if provided.\n *\n * @param node - The node at which to start converting.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, conversion continues until the end of the list.\n *\n * @returns An array with the values of the list from `node` to `end`.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function toArray<T>(node?: LinkedNode<T>, end?: LinkedNode<T>): T[] {\n  const array: T[] = [];\n\n  while (node != end) {\n    array.push(node!.value);\n    node = node!.next;\n  }\n\n  return array;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(\n  values: Iterable<T>\n): [LinkedNode<T>, LinkedNode<T>, number] | [undefined, undefined, 0] {\n  const root = {} as LinkedNode<T>;\n\n  let count = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { value };\n    tail = tail.next;\n    ++count;\n  }\n\n  return root.next === undefined\n    ? [undefined, undefined, 0]\n    : [root.next, tail, count];\n}\n\n/**\n * Iterates through a linked list, yielding each node's value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* values<T>(\n  head?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<T> {\n  for (let i = 0; head != end; ++i) {\n    yield head!.value;\n    head = head!.next;\n  }\n}\n","import { DoublyLinkedNode } from \"../types/doublyLinkedNode\";\n\nimport { get as singlyGet, cut as singlyCut } from \"./linkedNode\";\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<N extends DoublyLinkedNode<unknown>>(\n  root: N,\n  count: number\n): [N, N] | [undefined, undefined] {\n  if (count <= 0) {\n    return [undefined, undefined];\n  }\n  const [head, tail] = singlyCut(root, count) as [N, N];\n  head.prev = undefined;\n  if (root.next != null) {\n    root.next.prev = root;\n  }\n  return [head, tail];\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends DoublyLinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index >= 0) {\n    return singlyGet(node, index);\n  }\n  for (let i = 0; node != null && i > index; --i) {\n    node = node.prev;\n  }\n  return node;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n *\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: DoublyLinkedNode<T>,\n  values: T[]\n): DoublyLinkedNode<T> {\n  // Convert values to list\n  const [head, tail, size] = toList(values);\n\n  // If no values\n  if (size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  const next = prev.next;\n  prev.next = head;\n  head!.prev = prev;\n  tail!.next = next;\n  if (next != null) {\n    next.prev = tail;\n  }\n\n  return tail!;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(\n  values: Iterable<T>\n):\n  | [DoublyLinkedNode<T>, DoublyLinkedNode<T>, number]\n  | [undefined, undefined, 0] {\n  const root = {} as DoublyLinkedNode<T>;\n\n  let count = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { prev: tail, value } as DoublyLinkedNode<T>;\n    tail = tail.next;\n    ++count;\n  }\n\n  if (count <= 0) {\n    return [undefined, undefined, 0];\n  }\n\n  root.next!.prev = undefined;\n  return [root.next!, tail, count];\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { DoublyLinkedNode as Node } from \"../types/doublyLinkedNode\";\nimport { List } from \"../types/list\";\nimport { cut, get, toList } from \"../utils/doublyLinkedNode\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { entries, has, keys, toArray, values } from \"../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularDoublyLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the linked list\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The current size of the list (0 \\<= size \\<= capacity)\n   * @internal\n   */\n  protected _size!: number;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    const [head, tail, size] = toList(capacity as Iterable<T>);\n    this._capacity = size;\n    if (size > 0) {\n      this.root.next = head!;\n      this.root.prev = tail!;\n      head!.prev = this.root;\n      tail!.next = this.root;\n      this._size = size;\n    }\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDoublyLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const [head, tail] = cut(this.root, diff);\n    this._size -= diff;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, toArray(head, tail!.next));\n  }\n\n  at(index: number): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this.get(index).value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    const node = this.get(index);\n    node.prev!.next = node.next;\n    node.next!.prev = node.prev;\n    --this._size;\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this.root.next, this.root);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Update values\n    let node = this.get(start);\n    while (start < end) {\n      node.value = value;\n      node = node.next!;\n      ++start;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this.root.next, value, this.root);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this.root.next, this.root);\n  }\n\n  pop(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove tail\n    const node = this.root.prev!;\n    node.prev!.next = node.next;\n    node.next!.prev = node.prev;\n    --this._size;\n\n    // Return value\n    return node.value;\n  }\n\n  push(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.append(this.root.prev!, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update node\n    const node = this.get(index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove head\n    const head = this.root.next!;\n    head.prev!.next = head.next;\n    head.next!.prev = head.prev;\n    --this._size;\n\n    // Return value\n    return head.value;\n  }\n\n  slice(start?: number, end?: number): CircularDoublyLinkedList<T> {\n    const out = new CircularDoublyLinkedList<T>();\n\n    // Check if empty\n    if (this._size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Add values to output\n    let prev = this.get(start - 1);\n    while (start < end) {\n      prev = prev.next!;\n      out.push(prev.value);\n      ++start;\n    }\n\n    // Return new list\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularDoublyLinkedList<T> {\n    const out = new CircularDoublyLinkedList<T>();\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, this._size - start);\n\n    // Get prev node\n    const prev = this.get(start - 1);\n\n    // Delete values\n    if (deleteCount > 0) {\n      const [head, tail] = cut(prev, deleteCount);\n      this._size -= deleteCount;\n      head!.prev = out.root;\n      tail!.next = out.root;\n      out.root.next = head;\n      out.root.prev = tail;\n      out._size = deleteCount;\n    }\n\n    // Add values\n    this.append(prev, items);\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this.root.next, this.root);\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.prepend(this.root.next!, values);\n\n    // Return size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this.root.next, this.root);\n  }\n\n  /**\n   * @internal\n   */\n  protected append(tail: Node<T>, values: T[]): Node<T> {\n    const root = this.root;\n    const next = tail.next!;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = 0; i < N; ++i) {\n      const curr = { prev: tail, value: values[i] } as Node<T>;\n      tail.next = curr;\n      tail = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next!.value);\n        root.next = root.next!.next;\n      }\n    }\n    tail.next = next;\n    next.prev = tail;\n    root.next!.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return tail;\n  }\n\n  /**\n   * @internal\n   */\n  protected get(index: number): Node<T> {\n    index -= index <= this._size / 2 ? -1 : this._size;\n    return get(this.root, index)!;\n  }\n\n  /**\n   * @internal\n   */\n  protected prepend(next: Node<T>, values: T[]): Node<T> {\n    const root = this.root;\n    const prev = next.prev!;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    for (let i = values.length - 1; i >= 0; --i) {\n      const curr = { next, value: values[i] } as Node<T>;\n      next.prev = curr;\n      next = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.prev!.value);\n        root.prev = root.prev!.prev;\n      }\n    }\n    next.prev = prev;\n    prev.next = next;\n    root.prev!.next = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted.reverse());\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return next;\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Bounded } from \"../types/bounded\";\nimport { Deque } from \"../types/deque\";\n\nimport { CircularDoublyLinkedList } from \"./circularDoublyLinkedList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  first(): T | undefined {\n    return this.list.at(0);\n  }\n\n  front(): T | undefined {\n    return this.list.at(0);\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  unshift(...elems: T[]): number {\n    return this.list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { LinkedNode as Node } from \"../types/linkedNode\";\nimport { List } from \"../types/list\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport {\n  cut,\n  entries,\n  get,\n  has,\n  keys,\n  toArray,\n  toList,\n  values,\n} from \"../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the linked list\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The current size of the list (0 \\<= size \\<= capacity)\n   * @internal\n   */\n  protected _size!: number;\n\n  /**\n   * The last node in the linked list.\n   * @internal\n   */\n  protected tail!: Node<T>;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    const [head, tail, size] = toList(capacity as Iterable<T>);\n    this._capacity = size;\n    if (size > 0) {\n      this.root.next = head;\n      this.tail = tail!;\n      this._size = size;\n    }\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const [head] = cut(this.root, diff);\n    this._size -= diff;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this.tail = this.root;\n    }\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, toArray(head));\n  }\n\n  at(index?: number): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // If tail\n    if (++index == this._size) {\n      return this.tail.value;\n    }\n\n    // Return value\n    return get(this.root, index)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this.root.next = undefined;\n    this.tail = this.root;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    const prev = get(this.root, index)!;\n    prev.next = prev.next!.next;\n    --this._size;\n\n    // Update tail, if needed\n    if (index == this._size) {\n      this.tail = prev;\n    }\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this.root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Update values\n    let node = get(this.root, start + 1);\n    while (start < end) {\n      node!.value = value;\n      node = node!.next;\n      ++start;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this.root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this.root.next);\n  }\n\n  pop(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove and update tail\n    const value = this.tail.value;\n    this.tail = get(this.root, --this._size)!;\n    this.tail.next = undefined;\n\n    // Return value\n    return value;\n  }\n\n  push(...values: T[]): number {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.tail = this.append(this.tail, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update node\n    const node = get(this.root, index + 1)!;\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove head\n    const head = this.root.next!;\n    this.root.next = head.next;\n    --this._size;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this.tail = this.root;\n    }\n\n    // Return value\n    return head.value;\n  }\n\n  slice(start?: number, end?: number): CircularLinkedList<T> {\n    const out = new CircularLinkedList<T>();\n\n    // Check if empty\n    if (this._size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Add values to output\n    let node = get(this.root, start)!;\n    while (start < end) {\n      node = node.next!;\n      out.push(node.value);\n      ++start;\n    }\n\n    // Return new list\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularLinkedList<T> {\n    const out = new CircularLinkedList<T>();\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, this._size - start);\n\n    // Get prev node\n    let prev = get(this.root, start)!;\n\n    // Delete values\n    if (deleteCount > 0) {\n      const [head, tail] = cut(prev, deleteCount);\n      this._size -= deleteCount;\n      out.root.next = head;\n      out.tail = tail!;\n      out._size = deleteCount;\n    }\n\n    // Add values\n    prev = this.append(prev, items);\n\n    // Update tail, if needed\n    if (prev.next == null) {\n      this.tail = prev;\n    }\n\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this.root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    let N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: No capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Reduce input\n    const diff = N <= capacity ? 0 : N - capacity;\n    N -= diff;\n\n    // Case 3: Discard list overflow\n    if (this._size + N > capacity) {\n      this._size = capacity - N;\n      const prev = get(this.root, this._size)!;\n      this.emitter.emit(BoundedEvent.Overflow, toArray(prev.next));\n      prev.next = undefined;\n      this.tail = prev;\n    }\n\n    // Discard input overflow\n    if (diff > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values.slice(N));\n      values.length = N;\n    }\n\n    // Add values\n    const [head, tail] = toList(values);\n    tail!.next = this.root.next;\n    this.root.next = head;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this.tail = tail!;\n    }\n\n    // Update size\n    this._size += N;\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this.root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected append(tail: Node<T>, values: T[], minIndex = 0): Node<T> {\n    const root = this.root;\n    const next = tail.next;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = minIndex; i < N; ++i) {\n      const curr = { value: values[i] } as Node<T>;\n      tail.next = curr;\n      tail = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next!.value);\n        root.next = root.next!.next;\n      }\n    }\n    tail.next = next;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return tail;\n  }\n}\n","import { Queue } from \"../types/queue\";\nimport { Bounded } from \"../types/bounded\";\n\nimport { CircularLinkedList } from \"./circularLinkedList\";\nimport { BoundedEvent } from \"..\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  first(): T | undefined {\n    return this.list.at(0);\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  front(): T | undefined {\n    return this.list.at(0);\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Stack } from \"../types/stack\";\nimport { Bounded } from \"../types/bounded\";\nimport { BoundedEvent, CircularDoublyLinkedList } from \"..\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal map.\n   * @internal\n   */\n  protected map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.map = new Map(capacity as Iterable<[K, V]>);\n    this._capacity = this.map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the map.\n   */\n  get size(): number {\n    return this.map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.map);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this.map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this.map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this.map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this.map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this.map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this.map.delete(key) && this.size >= this.capacity) {\n      const entry = this.map.entries().next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this.map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this.map.values();\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport { Bounded } from \"../types/bounded\";\nimport { CircularArrayList } from \"./circularArrayList\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  first(): T | undefined {\n    return this.list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this.list.first();\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal set.\n   * @internal\n   */\n  protected set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.set = new Set(capacity as Iterable<T>);\n    this._capacity = this.set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the set.\n   */\n  get size(): number {\n    return this.set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.set);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this.set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this.set.delete(value);\n      evicted.push(value);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this.set.delete(value) && this.size >= this.capacity) {\n      const out = this.set.values().next().value;\n      this.set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this.set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this.set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this.set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this.set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this.set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this.set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.set.values();\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Stack } from \"../types/stack\";\nimport { Bounded } from \"../types/bounded\";\nimport { CircularArrayList } from \"./circularArrayList\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.last();\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  top(): T | undefined {\n    return this.list.last();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n"],"names":["BoundedEvent","EventEmitter","CircularBase","emitter","__publicField","event","listener","ARRAY_MAX_LENGTH","isArrayLength","value","isInfinity","isNumber","isSafeCount","addIfBelow","addend","target","clamp","min","max","isInRange","toInteger","defaultValue","CircularArrayList","capacity","index","start","end","size","isFwd","vals","targetEnd","deleteCount","ext","callbackfn","thisArg","N","tail","evicted","i","values","elems","next","prevValue","out","from","to","items","addCount","replaceCount","free","shifted","mid","head","temp","diff","externalIndex","CircularDeque","v","cut","prev","count","get","entries","node","has","keys","toArray","array","toList","root","singlyCut","singlyGet","CircularDoublyLinkedList","curr","CircularLinkedDeque","CircularLinkedList","minIndex","CircularLinkedQueue","CircularLinkedStack","CircularMap","iter","n","entry","key","CircularQueue","CircularSet","CircularStack"],"mappings":"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"}