{"version":3,"file":"circle-ds.min.cjs","sources":["../../src/utils/is.ts","../../src/circle/circleView.ts","../../src/circle/circleQueue.ts","../../src/circle/circleStack.ts","../../src/utils/mixins.ts","../../src/circle/circleDeque.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return isFunction(value?.[Symbol.iterator]);\n}\n\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","import { isIterable } from \"../utils/is\";\nimport { Collection } from \"../types/collection\";\n\n/**\n * A circular view is a fixed-size, read-only, circular array used to\n * store elements.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleView<T> implements Collection<T, number> {\n  /**\n   * The index representing the first element in the collection.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The index one more than the last element in the collection.\n   * @internal\n   */\n  protected tail: number;\n\n  /**\n   * The values in the collection.\n   * @internal\n   */\n  protected vals: (T | undefined)[];\n\n  /**\n   * Capacity defaults to zero and should be updated via {@link CircleView.capacity}.\n   */\n  constructor();\n  /**\n   * @param capacity - the maximum capacity.\n   */\n  constructor(capacity: number);\n  /**\n   * @param items - the items to store in the collection.\n   */\n  constructor(items: Iterable<T>);\n  /**\n   * @param items - the items to store in the collection.\n   */\n  constructor(...items: T[]);\n  constructor(capacity?: number | T | Iterable<T>, ...items: T[]) {\n    this.head = 0;\n    this._size = 0;\n    this.tail = 0;\n    this.vals = [];\n\n    const numArgs = arguments.length;\n    if (numArgs < 1) {\n      return;\n    }\n\n    if (numArgs === 1 && typeof capacity === \"number\") {\n      this.vals.length = capacity;\n    } else if (numArgs === 1 && isIterable(capacity)) {\n      this.vals = Array.from(capacity);\n      this._size = this.vals.length;\n    } else {\n      this.vals = items;\n      this.vals.push(capacity as T);\n      this._size = this.vals.length;\n      this.tail = this._size - 1;\n      this.head = this.tail;\n    }\n  }\n\n  /**\n   * Creates a collection from an iterable object.\n   *\n   * @param iterable - an iterable object to convert to a collection.\n   */\n  static from<T, I extends typeof CircleView>(\n    this: I,\n    iterable: Iterable<T> | ArrayLike<T>\n  ): InstanceType<I> {\n    const obj = new this(0) as InstanceType<I>;\n    obj.vals = Array.from(iterable);\n    obj._size = obj.vals.length;\n    return obj;\n  }\n\n  /**\n   * Creates a collection from a variable number of arguments.\n   *\n   * @param elements - the elements to be inserted into the collection.\n   */\n  static of<I extends typeof CircleView<T>, T = unknown>(\n    this: I,\n    ...elements: T[]\n  ): InstanceType<I> {\n    const obj = new this(0) as InstanceType<I>;\n    obj.vals = elements;\n    obj._size = elements.length;\n    return obj;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.vals.length;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(newCapacity: number) {\n    // Sanitize input\n\n    newCapacity = +newCapacity;\n    if (!Number.isSafeInteger(newCapacity) || newCapacity < 0) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    const curCapacity = this.capacity;\n    if (this._size <= 0 || newCapacity == 0) {\n      this.head = 0;\n      this.tail = 0;\n      this._size = 0;\n      this.vals.length = newCapacity;\n    } else if (newCapacity > curCapacity) {\n      this.grow(newCapacity);\n    } else if (newCapacity < curCapacity) {\n      this.shrink(newCapacity);\n    }\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.tail = 0;\n    this.vals = new Array(this.capacity);\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[this.toInt(ext)]!];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[this.toInt(ext)]!;\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      if (this.vals[this.toInt(ext)] === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[this.toInt(ext)]!;\n    }\n  }\n\n  /**\n   * Converts an external index to an internal index\n   * @internal\n   *\n   * @param ext - The external index\n   *\n   * @returns The internal index\n   */\n  protected toInt(ext: number): number {\n    return (this.head + ext) % this.capacity;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param newCapacity - the new capacity\n   */\n  protected grow(newCapacity: number): void {\n    const curCapacity = this.capacity;\n    const tail = this.head + this._size;\n\n    this.vals.length = newCapacity;\n    if (tail <= curCapacity) {\n      this.tail = tail;\n      return;\n    }\n\n    const diff = Math.min(this.tail, newCapacity - curCapacity);\n    this.vals.copyWithin(curCapacity, 0, diff);\n    this.vals.fill(undefined, this.tail - diff, diff);\n    this.vals.copyWithin(0, diff, this.tail);\n    this.vals.fill(undefined, Math.max(diff, this.tail - diff), this.tail);\n    this.tail = tail % newCapacity;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param newCapacity - the new capacity\n   */\n  protected shrink(newCapacity: number): void {\n    this._size = Math.min(this._size, newCapacity);\n    this.tail = this.head + this._size;\n\n    if (this.tail <= newCapacity) {\n      this.tail %= newCapacity;\n      this.vals.length = newCapacity;\n    } else {\n      this.tail %= this.capacity;\n      this.vals = Array.from(this);\n      this.tail = this._size % newCapacity;\n      this.head = 0;\n    }\n  }\n}\n","import { CircleView } from \"./circleView\";\nimport { Queue } from \"../types/queue\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleQueue<T> extends CircleView<T> implements Queue<T> {\n  /**\n   * Get the element at the front of the queue.\n   *\n   * @returns the earliest inserted element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n\n  /**\n   * Inserts new elements at the end of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): T[] {\n    const cap = this.capacity;\n    if (cap < 1) {\n      return Array.from(elems);\n    }\n\n    const N = elems.length;\n    const out: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      const prev = this.vals[this.tail]!;\n      this.vals[this.tail] = elems[i];\n      this.tail = this.toInt(this._size + 1);\n      if (this._size < cap) {\n        ++this._size;\n      } else {\n        this.head = this.tail;\n        out.push(prev);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined;\n    this.head = (this.head + 1) % this.vals.length;\n    --this._size;\n    return value;\n  }\n}\n","import { CircleView } from \"./circleView\";\nimport { Stack } from \"../types/stack\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleStack<T> extends CircleView<T> implements Stack<T> {\n  /**\n   * Removes the last element from the stack and returns it.\n   *\n   * @returns the last element in the stack, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    this.tail = this.toInt(this._size - 1);\n    const value = this.vals[this.tail];\n    this.vals[this.tail] = undefined;\n    --this._size;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): T[] {\n    const cap = this.capacity;\n    if (cap < 1) {\n      return Array.from(elems);\n    }\n\n    const N = elems.length;\n    const out: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      const prev = this.vals[this.tail]!;\n      this.vals[this.tail] = elems[i];\n      this.tail = this.toInt(this._size + 1);\n      if (this._size < cap) {\n        ++this._size;\n      } else {\n        this.head = this.tail;\n        out.push(prev);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Get the element at the top of the stack.\n   *\n   * @returns the last inserted element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.toInt(this._size - 1)];\n  }\n}\n","export type Constructor<T = object> = new (...args: unknown[]) => T;\n\nexport function applyMixins(ctor: Constructor, mixins: Constructor[]): void {\n  for (const mixin of mixins) {\n    const proto = mixin.prototype;\n    for (const name of Object.getOwnPropertyNames(proto)) {\n      const descriptor =\n        Object.getOwnPropertyDescriptor(proto, name) ?? Object.create(null);\n      Object.defineProperty(ctor.prototype, name, descriptor);\n    }\n  }\n}\n","import { CircleView } from \"./circleView\";\nimport { CircleQueue } from \"./circleQueue\";\nimport { CircleStack } from \"./circleStack\";\nimport { Deque } from \"../types/deque\";\nimport { applyMixins } from \"../utils/mixins\";\n\n/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleDeque<T> extends CircleView<T> implements Deque<T> {\n  /**\n   * Get the element at the back of the queue.\n   *\n   * @returns the last inserted element, or `undefined` if empty.\n   */\n  back(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.toInt(this._size - 1)];\n  }\n  /**\n   * Get the element at the bottom of the stack.\n   *\n   * @returns the earliest inserted element, or `undefined` if empty.\n   */\n  bottom(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n  /**\n   * Inserts new elements at the start of the collection.\n   *\n   * @param elems - Elements to insert\n   *\n   * @returns The overwritten elements\n   */\n  unshift(...elems: T[]): T[] {\n    const length = this.vals.length;\n    if (length < 1) {\n      return Array.from(elems);\n    }\n\n    const out: T[] = [];\n    for (let i = elems.length - 1; i >= 0; --i) {\n      this.head = (this.head - 1 + length) % length;\n      const prev = this.vals[this.head]!;\n      this.vals[this.head] = elems[i];\n      if (this._size < length) {\n        ++this._size;\n      } else {\n        this.tail = this.head;\n        out.push(prev);\n      }\n    }\n\n    return out.reverse();\n  }\n}\n\nexport interface CircleDeque<T> extends CircleQueue<T>, CircleStack<T> {}\napplyMixins(CircleDeque, [CircleQueue, CircleStack]);\n"],"names":["isFunction","value","isIterable","CircleView","capacity","items","__publicField","numArgs","iterable","obj","elements","newCapacity","curCapacity","ext","callbackfn","thisArg","N","tail","diff","CircleQueue","elems","cap","out","i","prev","CircleStack","applyMixins","ctor","mixins","mixin","proto","name","descriptor","CircleDeque","length"],"mappings":"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"}