{"version":3,"file":"circle-ds.cjs","sources":["../../src/utils/is.ts","../../src/circle/circleView.ts","../../src/circle/circleQueue.ts","../../src/circle/circleStack.ts","../../src/utils/mixins.ts","../../src/circle/circleDeque.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return isFunction(value?.[Symbol.iterator]);\n}\n\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","import { isIterable } from \"../utils/is\";\nimport { Collection } from \"../types/collection\";\n\n/**\n * A circular view is a fixed-size, read-only, circular array used to\n * store elements.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleView<T> implements Collection<T, number> {\n  /**\n   * The index representing the first element in the collection.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The index one more than the last element in the collection.\n   * @internal\n   */\n  protected tail: number;\n\n  /**\n   * The values in the collection.\n   * @internal\n   */\n  protected vals: (T | undefined)[];\n\n  /**\n   * Capacity defaults to zero and should be updated via {@link CircleView.capacity}.\n   */\n  constructor();\n  /**\n   * @param capacity - the maximum capacity.\n   */\n  constructor(capacity: number);\n  /**\n   * @param items - the items to store in the collection.\n   */\n  constructor(items: Iterable<T>);\n  /**\n   * @param items - the items to store in the collection.\n   */\n  constructor(...items: T[]);\n  constructor(capacity?: number | T | Iterable<T>, ...items: T[]) {\n    this.head = 0;\n    this._size = 0;\n    this.tail = 0;\n    this.vals = [];\n\n    const numArgs = arguments.length;\n    if (numArgs < 1) {\n      return;\n    }\n\n    if (numArgs === 1 && typeof capacity === \"number\") {\n      this.vals.length = capacity;\n    } else if (numArgs === 1 && isIterable(capacity)) {\n      this.vals = Array.from(capacity);\n      this._size = this.vals.length;\n    } else {\n      this.vals = items;\n      this.vals.push(capacity as T);\n      this._size = this.vals.length;\n      this.tail = this._size - 1;\n      this.head = this.tail;\n    }\n  }\n\n  /**\n   * Creates a collection from an iterable object.\n   *\n   * @param iterable - an iterable object to convert to a collection.\n   */\n  static from<T, I extends typeof CircleView<T>>(\n    this: I,\n    iterable: Iterable<T> | ArrayLike<T>\n  ): InstanceType<I> {\n    const obj = new this(0) as InstanceType<I>;\n    obj.vals = Array.from(iterable);\n    obj._size = obj.vals.length;\n    return obj;\n  }\n\n  /**\n   * Creates a collection from a variable number of arguments.\n   *\n   * @param elements - the elements to be inserted into the collection.\n   */\n  static of<T, I extends typeof CircleView<T>>(\n    this: I,\n    ...elements: T[]\n  ): InstanceType<I> {\n    const obj = new this(0) as InstanceType<I>;\n    obj.vals = elements;\n    obj._size = elements.length;\n    return obj;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.vals.length;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(newCapacity: number) {\n    // Sanitize input\n\n    newCapacity = +newCapacity;\n    if (!Number.isSafeInteger(newCapacity) || newCapacity < 0) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    const curCapacity = this.capacity;\n    if (this._size <= 0 || newCapacity == 0) {\n      this.head = 0;\n      this.tail = 0;\n      this._size = 0;\n      this.vals.length = newCapacity;\n    } else if (newCapacity > curCapacity) {\n      this.grow(newCapacity);\n    } else if (newCapacity < curCapacity) {\n      this.shrink(newCapacity);\n    }\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.tail = 0;\n    this.vals = new Array(this.capacity);\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[this.toInt(ext)]!];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[this.toInt(ext)]!;\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      if (this.vals[this.toInt(ext)] === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[this.toInt(ext)]!;\n    }\n  }\n\n  /**\n   * Converts an external index to an internal index\n   * @internal\n   *\n   * @param ext - The external index\n   *\n   * @returns The internal index\n   */\n  protected toInt(ext: number): number {\n    return (this.head + ext) % this.capacity;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param newCapacity - the new capacity\n   */\n  protected grow(newCapacity: number): void {\n    const curCapacity = this.capacity;\n    const tail = this.head + this._size;\n\n    this.vals.length = newCapacity;\n    if (tail <= curCapacity) {\n      this.tail = tail;\n      return;\n    }\n\n    const diff = Math.min(this.tail, newCapacity - curCapacity);\n    this.vals.copyWithin(curCapacity, 0, diff);\n    this.vals.fill(undefined, this.tail - diff, diff);\n    this.vals.copyWithin(0, diff, this.tail);\n    this.vals.fill(undefined, Math.max(diff, this.tail - diff), this.tail);\n    this.tail = tail % newCapacity;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param newCapacity - the new capacity\n   */\n  protected shrink(newCapacity: number): void {\n    this._size = Math.min(this._size, newCapacity);\n    this.tail = this.head + this._size;\n\n    if (this.tail <= newCapacity) {\n      this.tail %= newCapacity;\n      this.vals.length = newCapacity;\n    } else {\n      this.tail %= this.capacity;\n      this.vals = Array.from(this);\n      this.tail = this._size % newCapacity;\n      this.head = 0;\n    }\n  }\n}\n","import { CircleView } from \"./circleView\";\nimport { Queue } from \"../types/queue\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleQueue<T> extends CircleView<T> implements Queue<T> {\n  /**\n   * Get the element at the front of the queue.\n   *\n   * @returns the earliest inserted element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n\n  /**\n   * Inserts new elements at the end of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): T[] {\n    const cap = this.capacity;\n    if (cap < 1) {\n      return Array.from(elems);\n    }\n\n    const N = elems.length;\n    const out: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      const prev = this.vals[this.tail]!;\n      this.vals[this.tail] = elems[i];\n      this.tail = this.toInt(this._size + 1);\n      if (this._size < cap) {\n        ++this._size;\n      } else {\n        this.head = this.tail;\n        out.push(prev);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined;\n    this.head = (this.head + 1) % this.vals.length;\n    --this._size;\n    return value;\n  }\n}\n","import { CircleView } from \"./circleView\";\nimport { Stack } from \"../types/stack\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleStack<T> extends CircleView<T> implements Stack<T> {\n  /**\n   * Removes the last element from the stack and returns it.\n   *\n   * @returns the last element in the stack, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    this.tail = this.toInt(this._size - 1);\n    const value = this.vals[this.tail];\n    this.vals[this.tail] = undefined;\n    --this._size;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): T[] {\n    const cap = this.capacity;\n    if (cap < 1) {\n      return Array.from(elems);\n    }\n\n    const N = elems.length;\n    const out: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      const prev = this.vals[this.tail]!;\n      this.vals[this.tail] = elems[i];\n      this.tail = this.toInt(this._size + 1);\n      if (this._size < cap) {\n        ++this._size;\n      } else {\n        this.head = this.tail;\n        out.push(prev);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Get the element at the top of the stack.\n   *\n   * @returns the last inserted element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.toInt(this._size - 1)];\n  }\n}\n","export type Constructor<T = object> = new (...args: unknown[]) => T;\n\nexport function applyMixins(ctor: Constructor, mixins: Constructor[]): void {\n  for (const mixin of mixins) {\n    const proto = mixin.prototype;\n    for (const name of Object.getOwnPropertyNames(proto)) {\n      const descriptor =\n        Object.getOwnPropertyDescriptor(proto, name) ?? Object.create(null);\n      Object.defineProperty(ctor.prototype, name, descriptor);\n    }\n  }\n}\n","import { CircleView } from \"./circleView\";\nimport { CircleQueue } from \"./circleQueue\";\nimport { CircleStack } from \"./circleStack\";\nimport { Deque } from \"../types/deque\";\nimport { applyMixins } from \"../utils/mixins\";\n\n/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircleDeque<T> extends CircleView<T> implements Deque<T> {\n  /**\n   * Get the element at the back of the queue.\n   *\n   * @returns the last inserted element, or `undefined` if empty.\n   */\n  back(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.toInt(this._size - 1)];\n  }\n  /**\n   * Get the element at the bottom of the stack.\n   *\n   * @returns the earliest inserted element, or `undefined` if empty.\n   */\n  bottom(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n  /**\n   * Inserts new elements at the start of the collection.\n   *\n   * @param elems - Elements to insert\n   *\n   * @returns The overwritten elements\n   */\n  unshift(...elems: T[]): T[] {\n    const length = this.vals.length;\n    if (length < 1) {\n      return Array.from(elems);\n    }\n\n    const out: T[] = [];\n    for (let i = elems.length - 1; i >= 0; --i) {\n      this.head = (this.head - 1 + length) % length;\n      const prev = this.vals[this.head]!;\n      this.vals[this.head] = elems[i];\n      if (this._size < length) {\n        ++this._size;\n      } else {\n        this.tail = this.head;\n        out.push(prev);\n      }\n    }\n\n    return out.reverse();\n  }\n}\n\nexport interface CircleDeque<T> extends CircleQueue<T>, CircleStack<T> {}\napplyMixins(CircleDeque, [CircleQueue, CircleStack]);\n"],"names":[],"mappings":"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"}