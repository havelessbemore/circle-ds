{"version":3,"file":"circle-ds.cjs","sources":["../../src/types/boundedEvent.ts","../../node_modules/eventemitter3/index.js","../../src/collections/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/utils/math.ts","../../src/utils/iterable.ts","../../src/collections/list/circularArrayList.ts","../../src/collections/deque/circularDeque.ts","../../src/utils/linkedNode.ts","../../src/utils/doublyLinkedNode.ts","../../src/collections/list/circularDoublyLinkedList.ts","../../src/collections/deque/circularLinkedDeque.ts","../../src/collections/list/circularLinkedList.ts","../../src/utils/skipList.ts","../../src/collections/list/circularSkipList.ts","../../src/collections/map/circularMap.ts","../../src/collections/queue/circularLinkedQueue.ts","../../src/collections/queue/circularQueue.ts","../../src/collections/set/circularSet.ts","../../src/collections/stack/circularLinkedStack.ts","../../src/collections/stack/circularStack.ts"],"sourcesContent":["/**\n * An enumeration of event types supported by {@link Bounded} collections.\n *\n * This object defines a set of constants representing event names that can\n * be emitted by instances of collections implementing the {@link Bounded} interface.\n * These events signify specific actions or changes in the state of the collection.\n *\n * Defined events include:\n * - `Overflow`: Indicates that the collection has reached its capacity, and\n *   as a result, one or more elements have been removed to accommodate new elements.\n *   This event is triggered during operations that add elements to the collection when\n *   it exceeds its capacity, or when capacity is updated below the collection's current\n *   size. Listeners attached to this event will receive an array of elements that were\n *   removed due to the overflow. Removed elements may be sent across 1 or more event\n *   instances.\n *\n * This object is marked as `const` to ensure that its properties are read-only,\n * preventing modification of event names which could lead to inconsistencies in\n * event handling across the application.\n */\nexport const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","import { EventEmitter } from \"eventemitter3\";\n\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport class CircularBase<T> {\n  /**\n   * @internal\n   * The event emitter.\n   *\n   */\n  protected _emitter: EventEmitter;\n\n  constructor(emitter = new EventEmitter()) {\n    this._emitter = emitter;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * The maximum number of arguments that can be passed to a function.\n *\n * While ECMAScript specifications do not explicitly limit the number of\n * function arguments, practical limits are imposed by JavaScript engine\n * implementations. Different engines can have different maximums, so a\n * conservative value is used to prevent runtime errors.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-list-and-record-specification-type | ECMAScript Specification},\n * section \"6.2.2 The List and Record Specification Types\".\n */\nexport const ARGS_MAX_LENGTH = 16383; // 2**14 - 1\n\n/**\n * The maximum length of an array.\n *\n * According to the ECMAScript specification, the length property of an array\n * is an unsigned 32-bit integer, so its range is 0 to 2**32 - 1, inclusive.\n * Beyond this, operations that modify the array length (e.g., `push`, `pop`,\n * `unshift`, `shift`) may fail or behave unexpectedly.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-arraycreate | ECMAScript Specification},\n * section \"10.4.2.2 ArrayCreate\".\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1\n\n/**\n * The maximum safe length for a linked structure.\n *\n * This constant is defined as the largest integer value that can be safely\n * represented in JavaScript (`Number.MAX_SAFE_INTEGER`), preventing integer\n * precision loss in length-related operations. Operations with values beyond\n * this number may not behave as expected due to limitations in JavaScript's\n * number representation.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-number.max_safe_integer | ECMAScript Specification},\n * section \"21.1.2.6 Number.MAX_SAFE_INTEGER\".\n */\nexport const LINKED_MAX_LENGTH = Number.MAX_SAFE_INTEGER; // 2**53 - 1\n","import { ARRAY_MAX_LENGTH, LINKED_MAX_LENGTH } from \"./constants\";\n\n/**\n * Checks if a given value is an integer within a valid array length range.\n *\n * This function is useful for validating array lengths before attempting operations\n * that could result in a `RangeError` due to invalid array size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, ARRAY_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a function.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a function, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n/**\n * Checks if a given value is positive infinity.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is positive infinity, `false` otherwise.\n */\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n/**\n * Determines whether the provided value is iterable.\n *\n * This is useful for determining if a value can be used\n * in a `for...of` loop or with spread syntax.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value implements the iterable protocol, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if a given value is an integer within a valid linked length range.\n *\n * This function is useful for validating linked lengths before attempting operations\n * that could result in a `RangeError` due to invalid linked list size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, LINKED_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isLinkedLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= LINKED_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a number.\n *\n * This includes `NaN` and `Infinity`, so consider additional\n * checks if those values are not desirable.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type number, `false` otherwise.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Checks if a given value is a safe integer greater than or equal to 0.\n *\n * This is useful for validating counts or sizes that must be within the safe\n * integer range to prevent precision loss.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a safe integer and non-negative, `false` otherwise.\n */\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\n/**\n * Determines whether the provided value is a symbol.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a symbol, `false` otherwise.\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","/**\n * Adds a specified addend to a value if the value is below a given target.\n *\n * @param value - The initial number.\n * @param addend - The number added if the value is below the target.\n * @param target - The target number for comparison. If the value is below this\n * number, the addend will be added. Defaults to 0 if not specified.\n */\nexport function addIfBelow(value: number, addend: number, target = 0): number {\n  return value >= target ? value : value + addend;\n}\n\n/**\n * Restricts a given numerical value within a specified range [min, max].\n *\n * If the provided value is less than the minimum, the minimum is returned.\n * If it is greater than the maximum, the maximum is returned. If the value\n * is within the range, the value itself is returned. An error is thrown if\n * the minimum range value is greater than the maximum range value, as this\n * represents an invalid range.\n *\n * @param value - The numerical value to clamp.\n * @param min - The minimum allowable value of the range.\n * @param max - The maximum allowable value of the range.\n *\n * @returns The clamped value within the specified range.\n *\n * @throws `RangeError` If `min` is greater than `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError(\"Invalid clamp range; min must be <= max\");\n  }\n  if (value <= min) {\n    return min;\n  }\n  return value <= max ? value : max;\n}\n\n/**\n * Checks if a given numeric value falls within a specified range.\n *\n * @param value - The numeric value to check.\n * @param min - The inclusive lower bound of the range.\n * @param max - The exclusive upper bound of the range.\n *\n * @returns - `true` if `value` is within the range `[min, max)`, `false` otherwise.\n */\nexport function isInRange(value: number, min: number, max: number): boolean {\n  return value >= min && value < max;\n}\n\n/**\n * Calculates the logarithm of a given value with the specified base.\n *\n * This function uses natural logarithms (`Math.log`) for its calculations.\n * If either the value or the base is less than or equal to 0, `NaN` is returned\n * to indicate an invalid operation, as logarithms are not defined for non-positive\n * values and bases.\n *\n * @param value - The numerical value for which to calculate the logarithm. Must be positive.\n * @param base - The base of the logarithm. Must be positive.\n *\n * @returns The calculated logarithm of the value with the given base, or `NaN` for invalid inputs.\n */\nexport function log(value: number, base: number): number {\n  return value >= 0 && base > 0 ? Math.log(value) / Math.log(base) : NaN;\n}\n\n/**\n * Simulates a win streak based on a given probability and a random number generator.\n *\n * Consecutive \"wins\" are simulated by incrementing a counter each time the\n * random number generator returns a value less than the probability threshold. The\n * simulation continues until the generated value is equal to or greater than\n * the threshold, or until `max` is reached, indicating the end of the win streak.\n *\n * @example\n * // Simulate a win streak of consecutive coin tosses (50% win chance per toss).\n * const wins = simulateWinStreak(0.5);\n *\n * @param probability - A number representing the probability of a \"win\". It should be\n *                      within the range of values generated by the random number generator.\n * @param max - The maximum length of the win streak. Defaults to `Infinity`.\n * @param randomFn - A function that generates a random number within a given range (e.g. [0, 1)).\n *                   Defaults to `Math.random`.\n *\n * @returns A non-negative number of consecutive wins before a loss occurs.\n */\nexport function simulateWinStreak(\n  probability: number,\n  max = Infinity,\n  randomFn = Math.random\n): number {\n  let count = 0;\n  while (count < max && randomFn() < probability) {\n    ++count;\n  }\n  return count;\n}\n\n/**\n * Attempts to convert a given value to an integer.\n *\n * The function first tries to convert the value to a number. If the result\n * is not valid (i.e. `NaN`), the given `defaultValue` is returned. Otherwise,\n * the function truncates the number to an integer using `Math.trunc`.\n *\n * This is useful for ensuring numerical operations are performed on integers,\n * with a controllable fallback for invalid inputs.\n *\n * @param value - The value to convert to an integer. This can be of any type.\n * @param defaultValue - The fallback value to return if conversion fails. Defaults to 0.\n *\n * @returns The converted integer, or `defaultValue` if conversion is not possible.\n */\nexport function toInteger(value?: unknown, defaultValue = 0): number {\n  value = +value!;\n  return isNaN(value as number) ? defaultValue : Math.trunc(value as number);\n}\n","/**\n * Generates an iterable that yields chunks (arrays) of elements from the input iterable,\n * with each chunk containing up to a specified maximum number of elements. This function\n * is useful for processing or handling large collections of items in smaller, more\n * manageable segments.\n *\n * `chunkSize` is truncated to an integer to ensure expected behavior.\n * If `chunkSize` is less than 1, an empty iterable is generated.\n *\n * Example usage:\n * ```typescript\n * const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n * for (const chunk of chunk(nums, 3)) {\n *   console.log(chunk); // Outputs: [1, 2, 3], [4, 5, 6], [7, 8, 9]\n * }\n * ```\n *\n * @param source - The original iterable to be chunked. Can be any iterable object (e.g., Array, Set, or a custom iterable).\n * @param chunkSize - The maximum size of each chunk. Must be a positive integer; non-integer values are truncated.\n *\n * @returns An iterable iterator that yields each chunk as an array of elements.\n */\nexport function* chunk<T>(\n  source: Iterable<T>,\n  chunkSize: number\n): IterableIterator<T[]> {\n  if (chunkSize < 1) {\n    return;\n  }\n  let chunk: T[] = [];\n  chunkSize = Math.trunc(chunkSize);\n  for (const value of source) {\n    if (chunk.push(value) >= chunkSize) {\n      yield chunk;\n      chunk = [];\n    }\n  }\n  if (chunk.length > 0) {\n    yield chunk;\n  }\n}\n","import { CircularBase } from \"../circularBase\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport { isArrayLength, isInfinity, isNumber } from \"../../utils/is\";\nimport { Bounded } from \"../../types/bounded\";\nimport { ARGS_MAX_LENGTH, ARRAY_MAX_LENGTH } from \"../../utils/constants\";\nimport { List } from \"../../types/list\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../../utils/math\";\nimport { chunk } from \"../../utils/iterable\";\n\nexport class CircularArrayList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The index representing the first element.\n   */\n  protected _head: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The index one more than the last element.\n   */\n  protected _next: number;\n\n  /**\n   * @internal\n   * The number of elements.\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The stored values.\n   */\n  protected _vals: T[];\n\n  /**\n   * Creates a new list. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new list from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this._head = 0;\n    this._isFinite = false;\n    this._size = 0;\n    this._next = 0;\n    this._vals = [];\n\n    // Case 1: input is null or undefined\n    if (capacity == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(capacity)) {\n      this.capacity = capacity;\n      return;\n    }\n\n    // Case 3: input is an iterable\n    for (const vals of chunk(capacity, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularArrayList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size <= 0) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this._shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this._grow(capacity);\n    }\n  }\n\n  at(index?: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._vals[this._toIndex(index)];\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._head = 0;\n    this._next = 0;\n    this._vals.length = 0;\n  }\n\n  /*\n  copyWithin(target: number, start: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    target = clamp(addIfBelow(toInteger(target, 0), size), 0, size);\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    const temp = target > start ? target - start : 0;\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size - temp);\n\n    // Copy within\n    this._copyWithin(target, start, end);\n\n    // Return list\n    return this;\n  }\n  */\n\n  /**\n   * @internal\n   */\n  protected _copyWithin(target: number, start: number, end: number): void {\n    // If copying in-place or nothing to copy\n    if (target == start || start >= end) {\n      return;\n    }\n\n    // Get source data segments\n    const capacity = this._capacity - 1;\n    const vals = this._vals;\n    const ranges = this._toRanges(start, end);\n\n    if (target <= start || end <= target) {\n      // Copy from left to right\n      target = this._toIndex(target);\n      for (const [min, max] of ranges) {\n        for (let i = min; i < max; ++i) {\n          vals[target] = vals[i];\n          target = target < capacity ? target + 1 : 0;\n        }\n      }\n    } else {\n      // Copy from right to left\n      target = this._toIndex(target + (end - start));\n      for (const [min, max] of ranges.reverse()) {\n        for (let i = max - 1; i >= min; --i) {\n          target = target > 0 ? target - 1 : capacity;\n          vals[target] = vals[i];\n        }\n      }\n    }\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._delete(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  protected _delete(index: number, deleteCount: number): void {\n    this._copyWithin(index, index + deleteCount, this._size);\n    this._pop(deleteCount);\n  }\n\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this._vals[this._toIndex(ext)]];\n    }\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Fill values\n    this._fill(value, start, end);\n\n    // Return list\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  protected _fill(value: T, start: number, end: number): void {\n    for (const [min, max] of this._toRanges(start, end)) {\n      this._vals.fill(value, min, max);\n    }\n  }\n\n  first(): T | undefined {\n    return this._size > 0 ? this._vals[this._head] : undefined;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this._vals[this._toIndex(ext)];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  has(value: T): boolean {\n    const vals = this._vals;\n    for (const [min, max] of this._toRanges(0, this._size)) {\n      for (let i = min; i < max; ++i) {\n        if (value === vals[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  last(): T | undefined {\n    return this._size > 0\n      ? this._vals[this._toIndex(this._size - 1)]\n      : undefined;\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get and remove first value\n    const value = this._vals[this._toIndex(this._size - 1)];\n    this._pop(1);\n\n    // Return value\n    return value;\n  }\n\n  /**\n   * @internal\n   */\n  protected _pop(N: number): void {\n    // Remove values\n    const newSize = this._size - N;\n    this._fill(undefined as T, newSize, this._size);\n\n    // Update state\n    this._next = this._toIndex(newSize);\n    this._size = newSize;\n  }\n\n  push(...items: T[]): number {\n    // If no items\n    if (items.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(items);\n      return this._size;\n    }\n\n    // Push items\n    this._insert(this._size, items);\n\n    // Return new size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update value\n    index = this._toIndex(index);\n    const prevValue = this._vals[index];\n    this._vals[index] = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get and remove first value\n    const value = this._vals[this._head];\n    this._shift(1);\n\n    // Return value\n    return value;\n  }\n\n  /**\n   * @internal\n   */\n  protected _shift(N: number): void {\n    // Remove items\n    this._fill(undefined as T, 0, N);\n\n    // Update state\n    this._head = this._toIndex(N);\n    this._size -= N;\n  }\n\n  slice(start?: number, end?: number): CircularArrayList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Return slice\n    return this._toList(this._slice(start, end));\n  }\n\n  /**\n   * @internal\n   */\n  protected _slice(start: number, end: number): T[] {\n    const from = this._vals;\n    const to = new Array<T>(end - start);\n\n    let j = 0;\n    for ([start, end] of this._toRanges(start, end)) {\n      for (let i = start; i < end; ++i) {\n        to[j++] = from[i];\n      }\n    }\n\n    return to;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularArrayList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Create output\n    const out = this._toList(this._slice(start, start + deleteCount));\n\n    // Update list\n    this._splice(start, deleteCount, items);\n\n    // Return output\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected _splice(start: number, deleteCount: number, items: T[] = []): void {\n    const addCount = items.length;\n    const replaceCount = Math.min(deleteCount, addCount);\n    const vals = this._vals;\n\n    // Replace values\n    let j = 0;\n    for (const [a, b] of this._toRanges(start, start + replaceCount)) {\n      for (let i = a; i < b; ++i) {\n        vals[i] = items[j++];\n      }\n    }\n\n    // If done\n    if (deleteCount == addCount) {\n      return;\n    }\n\n    // Insert remaining values or finish deletions\n    start += replaceCount;\n    deleteCount < addCount\n      ? this._insert(start, items, replaceCount)\n      : this._delete(start, deleteCount - addCount);\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(\n    start: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(start, items, min, min + free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (start > 0) {\n      const shifted = Math.min(start, N - free);\n      this._overflow(this._slice(0, shifted));\n      this._shift(shifted);\n      start -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = max - free;\n    this._overflow(items.slice(min, mid));\n    this._safePresert(0, items, mid, max);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(\n    vIndex: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n    const vals = this._vals;\n\n    // Make space\n    this._copyWithin(vIndex + N, vIndex, this._size);\n\n    // Insert into space\n    for (const [start, end] of this._toRanges(vIndex, vIndex + N)) {\n      for (let i = start; i < end; ++i) {\n        vals[i] = items[min++];\n      }\n    }\n\n    // Update state\n    this._size += N;\n    this._next = this._toIndex(this._size);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...items: T[]): number {\n    // If no items\n    if (items.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(items);\n      return this._size;\n    }\n\n    // Presert items\n    this._presert(0, items);\n\n    // Return new size\n    return this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(\n    end: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safePresert(end, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safePresert(end, items, max - free, max);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (end < this._size) {\n      const popped = Math.min(this._size - end, N - free);\n      this._overflow(this._slice(this._size - popped, this._size));\n      this._pop(popped);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safePresert(end, items, min, max);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = min + free;\n    this._overflow(items.slice(mid, max));\n    this._safeInsert(this._size, items, min, mid);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safePresert(\n    vIndex: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const capacity = this._capacity;\n    const N = max - min;\n    const vals = this._vals;\n\n    // Make space\n    const newHead = capacity - N;\n    this._copyWithin(newHead, 0, vIndex);\n\n    // Insert into space\n    vIndex += newHead;\n    for (const [start, end] of this._toRanges(vIndex, vIndex + N)) {\n      for (let i = start; i < end; ++i) {\n        vals[i] = items[min++];\n      }\n    }\n\n    // Update state\n    this._size += N;\n    this._head = this._toIndex(newHead);\n  }\n\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this._vals[this._toIndex(ext)];\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: T[]): void {\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * @internal\n   *\n   * Grow capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected _grow(capacity: number): void {\n    // Check if list is sequential: [    H123456T    ]\n    if (this._isSequential()) {\n      this._sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n    if (this._size <= this._head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this._next;\n      this._vals.copyWithin(temp, 0, this._next);\n      this._vals.copyWithin(0, this._head, this._head + temp);\n      this._vals.length = this._size;\n      this._head = 0;\n      this._next = this._size;\n    } else if (this._head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this._vals.length = this._head + this._size;\n      this._vals.copyWithin(this._capacity, 0, this._next);\n      this._vals.fill(undefined as T, 0, this._next);\n      this._next = (this._head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this._vals.length = capacity;\n      this._vals.copyWithin(this._capacity, 0, diff);\n      this._vals.copyWithin(0, diff, this._next);\n      const temp = Math.max(diff, this._next - diff);\n      this._vals.fill(undefined as T, temp, this._next);\n      this._next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   *\n   * Returns whether the list is stored sequentially in memory.\n   *\n   * @returns `true` if the list is sequential in memory, `false` otherwise.\n   */\n  protected _isSequential(): boolean {\n    return this._head < this._next || this._next <= 0;\n  }\n\n  /**\n   * @internal\n   *\n   * Adjusts the list to fit within the given capacity.\n   *\n   * Assumes the list:\n   * - is sequential in memory.\n   * - fits in the given capacity (size \\<= capacity).\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the list was reset, `false` otherwise.\n   */\n  protected _sequentialReset(capacity: number): boolean {\n    const tail = this._head + this._size;\n\n    // If list fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this._vals.length = tail;\n      this._next = this._vals.length % capacity;\n\n      // If list must be fully moved: [H------T    ]\n    } else if (this._head >= capacity) {\n      this._vals.copyWithin(0, this._head, tail);\n      this._vals.length = this._size;\n      this._head = 0;\n      this._next = this._size % capacity;\n\n      // If list must be partially moved: [--T  H----]\n    } else {\n      this._vals.copyWithin(0, capacity, tail);\n      this._vals.length = capacity;\n      this._next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * @internal\n   *\n   * Shrink capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected _shrink(capacity: number): void {\n    // Handle overflow\n    if (this._size > capacity) {\n      const shifted = this._size - capacity;\n      this._overflow(this._slice(0, shifted));\n      this._shift(shifted);\n    }\n\n    // Check if list is sequential: [    H123456T    ]\n    if (this._isSequential()) {\n      this._sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of list: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this._vals.copyWithin(this._head - diff, this._head, this._capacity);\n    this._vals.length = capacity;\n    this._head -= diff;\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected _toIndex(externalIndex: number): number {\n    return (this._head + externalIndex) % this._capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected _toList(items: T[]): CircularArrayList<T> {\n    const out = new CircularArrayList<T>(0);\n    out._vals = items;\n    out._size = items.length;\n    out._capacity = items.length;\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected _toRanges(min: number, max: number): [number, number][] {\n    const head = this._head;\n    const mid = this._capacity - head;\n    if (max <= mid) {\n      return [[head + min, head + max]];\n    }\n    if (min >= mid) {\n      return [[min - mid, max - mid]];\n    }\n    return [\n      [head + min, this._capacity],\n      [0, max - mid],\n    ];\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Bounded } from \"../../types/bounded\";\nimport { Deque } from \"../..\";\nimport { CircularArrayList } from \"../list/circularArrayList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularArrayList<T>;\n\n  /**\n   * Creates a new deque. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new deque with the given capacity.\n   *\n   * @param capacity - the deque's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new deque from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the deque.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this._list.first();\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.last();\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  top(): T | undefined {\n    return this._list.last();\n  }\n\n  unshift(...elems: T[]): number {\n    return this._list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { LinkedCore, LinkedNode } from \"../types/linkedNode\";\n\n/**\n * Creates a copy of a segment from a linked list.\n *\n * @param node - The first {@link LinkedNode} of the original list from which\n *               the copy operation begins.\n * @param count - The number of nodes to copy. If the count exceeds the number\n *                of nodes available, only the available nodes are copied.\n *\n * @returns A tuple containing:\n *          - The head {@link LinkedNode} of the new list.\n *          - The tail {@link LinkedNode} of the new list.\n *          - An integer representing the total number of nodes copied.\n */\nexport function copy<T>(\n  node: LinkedNode<T> | undefined,\n  distance: number\n): LinkedCore<T> {\n  // Create new root\n  const root: LinkedNode<T> = { value: undefined as T };\n\n  // For each node\n  let size = 0;\n  let tail = root;\n  while (node != null && size < distance) {\n    // Create a duplicate\n    const dupe: LinkedNode<T> = { value: node.value };\n\n    // Attach the duplicate\n    tail.next = dupe;\n    tail = dupe;\n\n    // Update size\n    ++size;\n\n    // Move to the next node\n    node = node.next;\n  }\n\n  // Return copy\n  tail.next = undefined;\n  return { root, size, tail };\n}\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<T>(\n  prev: LinkedNode<T> | undefined,\n  count: number\n): LinkedCore<T> {\n  // Create new root\n  const root: LinkedNode<T> = { value: undefined as T };\n\n  // Check inputs\n  if (prev == null || count <= 0) {\n    return { root, size: 0, tail: root };\n  }\n\n  // Cut segment\n  const head = prev.next!;\n  const tail = get(head, count - 1)!;\n  prev.next = tail.next;\n  tail.next = undefined;\n\n  // Return cut segment\n  root.next = head;\n  return { root, size: count, tail };\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* entries<T>(node?: LinkedNode<T>): Generator<[number, T]> {\n  for (let i = 0; node != null; ++i) {\n    yield [i, node!.value];\n    node = node!.next;\n  }\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends LinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n  for (let i = 0; node != null && i < index; ++i) {\n    node = node.next;\n  }\n  return node;\n}\n\n/**\n * Determines whether a linked list contains a node with a specified value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * @param node - The node from which to start searching.\n * @param value - The value to search for.\n * @param end - An optional node at which to end the search (exclusive).\n * If not provided, the search continues until the end of the list.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n *\n */\nexport function has<T>(node: LinkedNode<T> | undefined, value: T): boolean {\n  while (node != null) {\n    if (node!.value === value) {\n      return true;\n    }\n    node = node!.next;\n  }\n  return false;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: LinkedNode<T>,\n  values: Iterable<T>\n): LinkedNode<T> {\n  // Convert values to list\n  const { root, size, tail } = toList(values);\n\n  // If no values\n  if (size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  tail!.next = prev.next;\n  prev.next = root.next;\n\n  return tail!;\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list).\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* keys<T>(node?: LinkedNode<T>): Generator<number> {\n  for (let i = 0; node != null; ++i) {\n    yield i;\n    node = node!.next;\n  }\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(values: Iterable<T>): LinkedCore<T> {\n  const root: LinkedNode<T> = { value: undefined as T };\n\n  let size = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { value };\n    tail = tail.next;\n    ++size;\n  }\n  tail.next = undefined;\n\n  return { root, size, tail };\n}\n\n/**\n * Iterates through a linked list, yielding each node's value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* values<T>(node?: LinkedNode<T>): Generator<T> {\n  while (node != null) {\n    yield node!.value;\n    node = node!.next;\n  }\n}\n","import { DoublyLinkedCore, DoublyLinkedNode } from \"../types/doublyLinkedNode\";\n\nimport { get as singlyGet, cut as singlyCut } from \"./linkedNode\";\n\n/**\n * Creates a copy of a segment from a doubly linked list.\n *\n * @param node - The first {@link DoublyLinkedNode} of the original list from\n *               which the copy operation begins.\n * @param count - The number of nodes to copy. If the count exceeds the number\n *                of nodes available, only the available nodes are copied.\n *\n * @returns A tuple containing:\n *          - The head {@link DoublyLinkedNode} of the new list.\n *          - The tail {@link DoublyLinkedNode} of the new list.\n *          - An integer representing the total number of nodes copied.\n */\nexport function copy<T>(\n  node: DoublyLinkedNode<T> | undefined,\n  distance: number\n): DoublyLinkedCore<T> {\n  // Create new root\n  const root: DoublyLinkedNode<T> = { value: undefined as T };\n\n  // Check distance\n  if (node == null || distance <= 0) {\n    return { root, size: 0, tail: root };\n  }\n\n  // For each node\n  let size = 0;\n  let tail = root;\n  while (node != null && size < distance) {\n    // Create a duplicate\n    const dupe: DoublyLinkedNode<T> = { value: node.value };\n\n    // Attach the duplicate\n    tail.next = dupe;\n    dupe.prev = tail;\n    tail = dupe;\n\n    // Update size\n    ++size;\n\n    // Move to the next node\n    node = node.next;\n  }\n\n  // Return copy\n  root.prev = undefined;\n  tail.next = undefined;\n  return { root, size, tail };\n}\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<T>(\n  node: DoublyLinkedNode<T>,\n  count: number\n): DoublyLinkedCore<T> {\n  const seg = singlyCut(node, count) as DoublyLinkedCore<T>;\n  if (seg.size <= 0) {\n    return seg;\n  }\n  seg.root.next!.prev = seg.root;\n  const next = node.next;\n  if (next != null) {\n    next.prev = node;\n  }\n  return seg;\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends DoublyLinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index >= 0) {\n    return singlyGet(node, index);\n  }\n  for (let i = 0; node != null && i > index; --i) {\n    node = node.prev;\n  }\n  return node;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n *\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: DoublyLinkedNode<T>,\n  values: T[]\n): DoublyLinkedNode<T> {\n  // Convert values to list\n  const list = toList(values);\n\n  // If no values\n  if (list.size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  const head = list.root.next!;\n  const tail = list.tail;\n  const next = prev.next;\n  head.prev = prev;\n  tail.next = next;\n  prev.next = head;\n  if (next != null) {\n    next.prev = tail;\n  }\n\n  return tail!;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A {@link DoublyLinkedCore}.\n */\nexport function toList<T>(values: Iterable<T>): DoublyLinkedCore<T> {\n  const root: DoublyLinkedNode<T> = { value: undefined as T };\n\n  let size = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { prev: tail, value } as DoublyLinkedNode<T>;\n    tail = tail.next;\n    ++size;\n  }\n\n  root.prev = undefined;\n  tail.next = undefined;\n  return { root, size, tail };\n}\n","import { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport {\n  DoublyLinkedCore,\n  DoublyLinkedNode,\n  DoublyLinkedNode as Node,\n} from \"../../types/doublyLinkedNode\";\nimport { List } from \"../../types/list\";\n\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../../utils/constants\";\nimport { copy, cut, get, toList } from \"../../utils/doublyLinkedNode\";\nimport { isInfinity, isLinkedLength, isNumber } from \"../../utils/is\";\nimport { chunk } from \"../../utils/iterable\";\nimport {\n  entries,\n  has,\n  keys,\n  values as getValues,\n} from \"../../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../../utils/math\";\n\nimport { CircularBase } from \"../circularBase\";\n\nexport class CircularDoublyLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The root of the linked list\n   */\n  protected _root: Node<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last node in the linked list.\n   */\n  protected _tail: DoublyLinkedNode<T>;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._root = { value: undefined } as Node<T>;\n    this._size = 0;\n    this._tail = this._root;\n\n    // Case 1: input is null or undefined\n    if (capacity == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(capacity)) {\n      this.capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const vals of chunk(capacity, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDoublyLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const { root } = cut(this._root, diff);\n    this._size -= diff;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = this._root;\n    }\n\n    // Emit discarded items\n    for (const array of chunk(getValues(root.next), ARGS_MAX_LENGTH)) {\n      this._overflow(array);\n    }\n  }\n\n  at(index: number): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._get(index).value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tail = this._root;\n    this._root.next = undefined;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    const node = this._get(index);\n    node.prev!.next = node.next;\n    if (node.next != null) {\n      node.next.prev = node.prev;\n    }\n    --this._size;\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Update values\n    let node = this._get(start);\n    while (start < end) {\n      node.value = value;\n      node = node.next!;\n      ++start;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  push(...values: T[]): number {\n    // Add values\n    this._insert(this._size, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update node\n    const node = this._get(index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularDoublyLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Check if empty\n    if (start >= end) {\n      return new CircularDoublyLinkedList<T>(0);\n    }\n\n    // Create segment copy\n    const node = this._get(start);\n    const core = copy(node, end - start);\n\n    // Return copied segment as a list\n    const list = new CircularDoublyLinkedList<T>(core.size);\n    list._root = core.root;\n    list._size = core.size;\n    list._tail = core.tail;\n\n    // Return new list\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularDoublyLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items, if any\n    let list: CircularDoublyLinkedList<T>;\n    if (deleteCount <= 0) {\n      list = new CircularDoublyLinkedList<T>(0);\n    } else {\n      const { root, size, tail } = this._cut(start, deleteCount);\n      list = new CircularDoublyLinkedList<T>(size);\n      list._root = root;\n      list._size = size;\n      list._tail = tail;\n    }\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return getValues(this._root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Add values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return getValues(this._root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): DoublyLinkedCore<T> {\n    // Get previous\n    const prev = this._get(start - 1)!;\n\n    // Cut and get removed segment\n    const seg = cut(prev, count);\n\n    // Update size\n    this._size -= count;\n\n    // Update tail\n    if (start >= this._size) {\n      this._tail = prev;\n    }\n\n    // Return cut segment\n    return seg;\n  }\n\n  /**\n   * @internal\n   */\n  protected _get(index: number): Node<T> {\n    const mid = this._size / 2;\n    return ++index <= mid\n      ? get(this._root, index)!\n      : get(this._tail, index - this._size)!;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(getValues(root.next));\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: Iterable<T>): void {\n    if (!Array.isArray(evicted)) {\n      evicted = Array.from(evicted);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(getValues(root.next));\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Sanitize input\n    if (values.length <= 0) {\n      return;\n    }\n\n    // Create segment\n    const { root, size, tail } = toList(values);\n    const head = root.next!;\n\n    // Insert segment\n    const prev = this._get(index - 1);\n    const next = prev.next;\n    head.prev = prev;\n    tail.next = next;\n    prev.next = head;\n    if (next != null) {\n      next.prev = tail;\n    }\n\n    // Update list state\n    this._tail = index < this._size ? this._tail : tail!;\n    this._size += size;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Bounded } from \"../../types/bounded\";\nimport { Deque } from \"../../types/deque\";\n\nimport { CircularDoublyLinkedList } from \"../list/circularDoublyLinkedList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  first(): T | undefined {\n    return this._list.at(0);\n  }\n\n  front(): T | undefined {\n    return this._list.at(0);\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  unshift(...elems: T[]): number {\n    return this._list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded, BoundedEvent } from \"../..\";\nimport { LinkedCore, LinkedNode as Node } from \"../../types/linkedNode\";\nimport { List } from \"../../types/list\";\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../../utils/constants\";\nimport { isInfinity, isLinkedLength, isNumber } from \"../../utils/is\";\nimport { chunk } from \"../../utils/iterable\";\nimport {\n  copy,\n  cut,\n  entries,\n  get,\n  has,\n  keys,\n  toList,\n  values,\n} from \"../../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../../utils/math\";\nimport { CircularBase } from \"../circularBase\";\n\nexport class CircularLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The root of the linked list\n   */\n  protected _root: Node<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last node in the linked list.\n   */\n  protected _tail: Node<T>;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._root = { value: undefined } as Node<T>;\n    this._size = 0;\n    this._tail = this._root;\n\n    // Case 1: input is null or undefined\n    if (capacity == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(capacity)) {\n      this.capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const vals of chunk(capacity, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const { root } = cut(this._root, diff);\n    this._size -= diff;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = this._root;\n    }\n\n    // Emit discarded items\n    this._overflow(root.next);\n  }\n\n  at(index?: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._get(index)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tail = this._root;\n    this._root.next = undefined;\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._cut(index, 1);\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n    if (start >= end) {\n      return this;\n    }\n\n    // Fill values\n    let node = this._get(start)!;\n    for (let i = start; i < end; ++i) {\n      node.value = value;\n      node = node.next!;\n    }\n\n    // Return list\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  push(...values: T[]): number {\n    // Add values\n    this._insert(this._size, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Set value\n    const node = this._get(index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Check if empty\n    if (start >= end) {\n      return new CircularLinkedList<T>(0);\n    }\n\n    // Create segment copy\n    const node = this._get(start);\n    const core = copy(node, end - start);\n\n    // Return copied segment as a list\n    const list = new CircularLinkedList<T>(core.size);\n    list._root = core.root;\n    list._size = core.size;\n    list._tail = core.tail;\n\n    // Return new list\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularLinkedList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items, if any\n    let list: CircularLinkedList<T>;\n    if (deleteCount <= 0) {\n      list = new CircularLinkedList<T>(0);\n    } else {\n      const { root, size, tail } = this._cut(start, deleteCount);\n      list = new CircularLinkedList<T>(deleteCount);\n      list._root = root;\n      list._size = size;\n      list._tail = tail;\n    }\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this._root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Add values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this._root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): LinkedCore<T> {\n    // Get previous\n    const prev = this._get(start - 1)!;\n\n    // Cut and get removed segment\n    const core = cut(prev, count);\n\n    // Update size\n    this._size -= count;\n\n    // Update tail\n    if (start >= this._size) {\n      this._tail = prev;\n    }\n\n    // Return cut segment\n    return core;\n  }\n\n  /**\n   * @internal\n   */\n  protected _get(index: number): Node<T> {\n    return ++index == this._size ? this._tail : get(this._root, index)!;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(root.next);\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted?: T[] | Node<T>): void {\n    if (evicted == null) {\n      return;\n    }\n    if (Array.isArray(evicted)) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n    for (const array of chunk(values(evicted), ARGS_MAX_LENGTH)) {\n      this._emitter.emit(BoundedEvent.Overflow, array);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(root.next);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Sanitize input\n    if (values.length <= 0) {\n      return;\n    }\n\n    // Create segment\n    const { root, size, tail } = toList(values);\n\n    // Insert segment\n    const prev = this._get(index - 1);\n    tail!.next = prev.next;\n    prev.next = root.next;\n\n    // Update list state\n    this._tail = index < this._size ? this._tail : tail!;\n    this._size += size;\n  }\n}\n","import {\n  SkipCore,\n  SkipEntry,\n  SkipLink,\n  SkipNode,\n  SkipStack,\n} from \"../types/skipList\";\nimport { clamp, log } from \"./math\";\n\n/**\n * Adjusts the `span` property of nodes in a skip list across specified levels.\n *\n * The adjustment can increase (for positive `diff`) or decrease (for negative `diff`)\n * the `span` values. This function is used to maintain\n * the integrity of skip list distances after insertion or deletion.\n *\n * @param stack - An array representing a vertical cross-section (stack) of the skip list at a certain position.\n *                Each element in the stack corresponds to a node at a different level, starting from the bottom.\n * @param diff - The numerical difference to apply to the `span` of each node in the stack. A positive `diff`\n *               increases the span, and a negative `diff` value decreases it.\n * @param min - The minimum level (0-based index) at which to start adjusting spans. Defaults to 0.\n */\nexport function adjustSpan<T>(\n  stack: SkipStack<T>,\n  diff: number,\n  min = 0\n): void {\n  const Y = stack.length;\n  for (let y = min >= 0 ? min : 0; y < Y; ++y) {\n    const levels = stack[y].node.levels;\n    const { next, span } = levels[y];\n    levels[y] = { next: next, span: span + diff };\n  }\n}\n\n/**\n * Calculates the maximum level for a skip list based on the given probability\n * factor and expected size.\n *\n * The maximum level determines how many forward pointers each element in the\n * skip list can have, which impacts the overall speed of search, insertion,\n * and deletion operations within the list.\n *\n * @param probability - The probability factor used for determining the level.\n *          It should be a number between 0 and 1 (exclusive). The probability\n *          factor affects the sparseness of the skip list; a lower value results\n *          in a shorter list, while a higher value results in a taller list.\n *\n * @param expectedSize - The expected number of elements in the skip list. It\n *                     should be a positive integer. The expected size\n *                     influences the optimal maximum level for the list.\n *\n * @returns The calculated optimal maximum level for the skip list. Returns 1\n *          if the probability factor is less than or equal to 0 or the\n *          expected size is less than or equal to 1. Returns Infinity if the\n *          probability factor is 1 or more, indicating an unbounded number of\n *          levels, and likely an error in inputs.\n */\nexport function calcMaxLevel(\n  probability: number,\n  expectedSize: number\n): number {\n  if (probability <= 0 || expectedSize <= 1) {\n    return 1;\n  }\n  if (probability >= 1) {\n    return Infinity;\n  }\n  return Math.ceil(log(expectedSize, 1 / probability));\n}\n\n/**\n * Copies a segment from a skip list, starting at a specified node\n * and copying a specified distance. The copied segment is\n * returned as a new {@link SkipCore}.\n *\n * @param node - The {@link SkipNode} from which the copy operation begins.\n * @param distance - The distance to copy from the start position. If this\n *                value exceeds the size of the original skip list, only the\n *                available nodes are copied.\n *\n * @returns The {@link SkipCore} of the duplicate list.\n */\nexport function copy<T>(\n  node: SkipNode<T> | undefined,\n  distance: number\n): SkipCore<T> {\n  // Create new list\n  let size = 0;\n  const root = toNode(undefined as T);\n  const tails: SkipNode<T>[] = [root];\n\n  // Check input\n  if (node == null || distance <= 0) {\n    return { root, size, tails };\n  }\n\n  // For each node\n  let maxY = 1;\n  const indexes: number[] = [-1];\n  while (node != null && size < distance) {\n    // Update maximum level\n    const Y = node.levels.length;\n    while (maxY < Y) {\n      tails[maxY] = root;\n      indexes[maxY] = -1;\n      ++maxY;\n    }\n\n    // Create and attach the duplicate node\n    const dupe = toNode(node.value, Y);\n    for (let y = 0; y < Y; ++y) {\n      tails[y].levels[y] = { next: dupe, span: size - indexes[y] };\n    }\n    tails.fill(dupe, 0, Y);\n    indexes.fill(size, 0, Y);\n\n    // Move to the next node\n    const { next, span } = node.levels[0];\n    node = next as SkipNode<T>;\n    size += span;\n  }\n\n  // Update the tail pointers\n  for (let y = 0; y < maxY; ++y) {\n    tails[y].levels[y] = { next: undefined, span: distance - indexes[y] };\n  }\n\n  // Return the copy\n  return { root, size, tails };\n}\n\n/**\n * Cuts a segment from a given skip list.\n *\n * The cut starts at the specified position and spans the given distance. The\n * cut segment is returned as a new skip list.\n *\n * @param core - The {@link SkipCore} representing the skip list from which to cut the segment.\n *               This skip list will be modified to reflect the removal.\n * @param start - The zero-based index indicating the start position of the cut, inclusive.\n * @param distance - The number of elements to be included in the cut segment.\n *\n * @returns A new {@link SkipCore} representing the skip list segment that has been cut.\n *\n * @remarks\n * - The height (levels) of the original list may be reduced if segment removal results in empty levels.\n * - The cut segment's height (levels) may be less than the original list. It will only contain\n *   levels that include nodes within the segment.\n */\nexport function cut<T>(\n  core: SkipCore<T>,\n  start: number,\n  end: number\n): SkipCore<T> {\n  // Initialize output\n  const segRoot = toNode(undefined as T);\n  const seg: SkipCore<T> = { root: segRoot, size: 0, tails: [segRoot] };\n\n  // Check inputs\n  if (start >= end || end <= 0 || start >= core.size) {\n    return seg;\n  }\n\n  // Get stacks\n  const prevStack = getStack(core, start - 1);\n  const tailStack = getStack(core, end - 1, Array.from(prevStack));\n\n  // Check size\n  let nextI = prevStack[0].index + prevStack[0].node.levels[0].span;\n  start = clamp(start, prevStack[0].index, nextI);\n  nextI = tailStack[0].index + tailStack[0].node.levels[0].span;\n  end = clamp(end, tailStack[0].index, nextI);\n  if (start >= end) {\n    return seg;\n  }\n  const size = end - start;\n  seg.size = size;\n\n  // Detach segment\n  let y: number;\n  let Y = prevStack.length;\n  for (y = 0; y < Y; ++y) {\n    const prev = prevStack[y];\n    const tail = tailStack[y];\n\n    // Check if segment exists at this level\n    if (prev.index >= tail.index) {\n      break;\n    }\n\n    // Connect segment start to new root\n    let edge = prev.node.levels[y];\n    let span = prev.index + edge.span - start;\n    segRoot.levels[y] = { next: edge.next, span };\n\n    // Remove segment from list\n    edge = tail.node.levels[y];\n    span = tail.index - prev.index + (edge.span - size);\n    prev.node.levels[y] = { next: edge.next, span };\n\n    // Detach segment end\n    tail.node.levels[y] = { next: undefined, span: end - tail.index };\n    seg.tails[y] = tail.node;\n  }\n\n  // Remove segment from untouched levels\n  adjustSpan(prevStack, -size, y);\n\n  if (y >= Y) {\n    // Remove empty levels from the source list\n    const levels = core.root.levels;\n    while (y > 1 && levels[y - 1].next == null) {\n      --y;\n    }\n    Y = y;\n    levels.length = Y;\n    core.tails.length = Y;\n  }\n\n  // Update tails from source list\n  core.size -= size;\n  if (start >= core.size) {\n    for (y = 0; y < Y; ++y) {\n      core.tails[y] = prevStack[y].node;\n    }\n  }\n\n  return seg;\n}\n\n/**\n * Iterates through a skip list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the given node and continues the end of the list.\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* entries<T>(node?: SkipNode<T>): Generator<[number, T]> {\n  let i = 0;\n  while (node != null) {\n    yield [i, node.value];\n    const { next, span } = node.levels[0];\n    node = next;\n    i += span;\n  }\n}\n\nexport function getEntry<T>(core: SkipCore<T>, target: number): SkipEntry<T> {\n  // Check target minimum\n  if (target < 0) {\n    return { index: -1, node: core.root };\n  }\n\n  // Check target maximum\n  const tails = core.tails;\n  let index = core.size - tails[0].levels[0].span;\n  if (target >= index) {\n    return { index, node: tails[0] };\n  }\n\n  // Use tails as shortcuts\n  index = -1;\n  let y: number;\n  let node = core.root;\n  for (y = node.levels.length - 1; y >= 0 && index < target; --y) {\n    const i = core.size - tails[y].levels[y].span;\n    if (i > target) {\n      break;\n    }\n    index = i;\n    node = tails[y];\n  }\n\n  // Find node\n  while (y >= 0 && index < target) {\n    const { next, span } = node.levels[y];\n    if (index + span > target || next == null) {\n      --y;\n    } else {\n      index += span;\n      node = next;\n    }\n  }\n\n  // Return index and distance\n  return { index, node };\n}\n\nexport function getStack<T>(\n  core: SkipCore<T>,\n  target: number,\n  stack: SkipStack<T> = toStack(core.root, -1)\n): SkipStack<T> {\n  // Check target minimum\n  const Y = stack.length;\n  if (Y <= 0 || target <= stack[0].index) {\n    return stack;\n  }\n\n  // Check target maximum\n  const size = core.size;\n  const tails = core.tails;\n  if (target >= size - tails[0].levels[0].span) {\n    for (let y = 0; y < Y; ++y) {\n      const index = size - tails[y].levels[y].span;\n      stack[y] = { index, node: tails[y] };\n    }\n    return stack;\n  }\n\n  // Use tails as shortcuts\n  let y: number;\n  for (y = Y - 1; y >= 0 && stack[y].index < target; --y) {\n    const i = size - tails[y].levels[y].span;\n    if (i > target) {\n      break;\n    }\n    stack[y] = { index: i, node: tails[y] };\n  }\n\n  // Find node\n  while (y >= 0 && stack[y].index < target) {\n    const { index, node } = stack[y];\n    const { next, span } = node.levels[y];\n    if (index + span <= target && next != null) {\n      stack[y] = { index: index + span, node: next };\n    } else {\n      --y;\n    }\n  }\n\n  // Finish stack update\n  if (y > 0) {\n    const { index, node } = stack[y];\n    for (let i = 0; i < y; ++i) {\n      stack[i] = { index, node };\n    }\n  }\n\n  return stack;\n}\n\n/**\n * Determines whether a skip list contains a node with a specified value.\n *\n * Iteration starts from the given node and continues the end of the list.\n *\n * @param node - The {@link SkipNode} at which to start iterating.\n * @param value - The value to search for.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n */\nexport function has<T>(node: SkipNode<T> | undefined, value: T): boolean {\n  while (node != null) {\n    if (node.value === value) {\n      return true;\n    }\n    node = node.levels[0].next;\n  }\n  return false;\n}\n\n/**\n * Increases the number of levels in a skip list to a specified level.\n *\n * Each new level is initialized such that it spans the entire list.\n * This function directly modifies the input skip list core.\n *\n * @param core - The {@link SkipCore} whose levels should be increased. The core is directly modified.\n *\n * @param levels - The number of levels the skip list should be increased to. If the current number\n *                 of levels is already equal to or greater than this value, no changes are made.\n */\nexport function increaseLevels<T>(core: SkipCore<T>, levels: number): void {\n  const { root, size, tails } = core;\n  for (let y = tails.length; y < levels; ++y) {\n    root.levels[y] = { next: undefined, span: size + 1 };\n    tails[y] = root;\n  }\n}\n\n/**\n * Inserts a skip list segment (`src`) into another skip list (`dest`) at a specified index.\n *\n * @param dest - The {@link SkipCore} representing the destination skip list into which the segment is to be\n *               inserted. This skip list will be modified to include the nodes from the source segment.\n * @param index - The zero-based position within the destination list at which the source segment is to be inserted.\n * @param src - The {@link SkipCore} representing the source skip list segment to be inserted into the destination\n *              list. This skip list's tail nodes will be modified to contain links within the destination list.\n *\n * @remarks\n * - The function may increase the height (number of levels) of the destination list if the source segment has\n *   more levels than the destination. This ensures that the merged list can accommodate the full structure of\n *   the segment being inserted.\n */\nexport function insert<T>(\n  dest: SkipCore<T>,\n  index: number,\n  src: SkipCore<T>\n): void {\n  // Check source values\n  if (src.size <= 0) {\n    return;\n  }\n\n  // Increase destination's height if necessary\n  const minY = src.tails.length;\n  increaseLevels(dest, minY);\n\n  // Attach segment\n  const prevs = getStack(dest, index - 1);\n  for (let y = 0; y < minY; ++y) {\n    const prev = prevs[y].node;\n    const tail = src.tails[y];\n\n    // Attach segment tail\n    const prevEdge = prev.levels[y];\n    const tailEdge = tail.levels[y];\n    let span = prevs[y].index - index + prevEdge.span + tailEdge.span;\n    tail.levels[y] = { next: prevEdge.next, span };\n\n    // Attach segment head\n    const rootEdge = src.root.levels[y];\n    span = index - prevs[y].index + (rootEdge.span - 1);\n    prev.levels[y] = { next: rootEdge.next, span };\n  }\n\n  // Update higher levels\n  adjustSpan(prevs, src.size, minY);\n\n  // Update tails\n  if (index === dest.size) {\n    for (let y = 0; y < minY; ++y) {\n      dest.tails[y] = src.tails[y];\n    }\n  }\n\n  // Update size\n  dest.size += src.size;\n}\n\n/**\n * Iterates through a skip list, yielding each node's index\n * (position in the list).\n *\n * Iteration starts from the given node and continues the end of the list.\n * This function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The {@link SkipNode} at which to start iterating.\n */\nexport function* keys<T>(node?: SkipNode<T>): Generator<number> {\n  let i = 0;\n  while (node != null) {\n    yield i;\n    const { next, span } = node.levels[0];\n    node = next;\n    i += span;\n  }\n}\n\n/**\n * Iterates through a skip list, yielding each node's height.\n *\n * Iteration starts from the given node and continues the end of the list.\n *\n * @param node - The {@link SkipNode} at which to start iterating.\n */\nexport function* levels<T>(node?: SkipNode<T>): Generator<number> {\n  while (node != null) {\n    yield node.levels.length;\n    node = node.levels[0].next;\n  }\n}\n\n/**\n * Creates a generator that yields each node in a skip list.\n *\n * Iteration starts from the given node and continues the end of the list.\n *\n * @param node - The {@link SkipNode} at which to start iterating.\n */\nexport function* nodes<T>(node?: SkipNode<T>): Generator<SkipNode<T>> {\n  while (node != null) {\n    yield node;\n    node = node.levels[0].next;\n  }\n}\n\n/**\n * Constructs a skip list from an array of levels and an array of values.\n *\n * @param levels - An array of integers that determines the number of\n *                 levels of the corresponding value in the `values` array.\n * @param values - An array of values to be stored in the skip list. Each\n *                 value is assigned to a new node in the list.\n *\n * @returns A tuple containing three elements:\n *          - The first element is the root {@link SkipNode} of the skip list. This is a dummy node immediately\n *            prior to the first value.\n *          - The second element is an array of {@link SkipNode}s representing the tail nodes at each level.\n *          - The third element is an integer `X` representing the number of nodes successfully added to the list,\n *            not including the root node.\n *\n * @remarks\n * - If the lengths of the input arrays do not match, the function operates on the smallest length.\n * - A dummy root node is created and updated to have up to the maximum level in the `levels` array.\n */\nexport function toList<T>(levels: number[], values: T[]): SkipCore<T> {\n  // Get # of values (X) and max level (Y)\n  let Y = -Infinity;\n  const size = Math.min(levels.length, values.length);\n  for (let y = 0; y < size; ++y) {\n    Y = Y >= levels[y] ? Y : levels[y];\n  }\n\n  // Check inputs\n  if (Y <= 0 || size <= 0) {\n    const root = toNode(undefined as T);\n    return { root, size: 0, tails: [root] };\n  }\n\n  // Create root node and tails array\n  const root = toNode(undefined as T, Y, size + 1);\n  const tails = new Array(Y).fill(root);\n\n  // For each value\n  for (let i = 0; i < size; ++i) {\n    // Create node\n    Y = levels[i];\n    const span = size - i;\n    const next = toNode(values[i], Y, span);\n\n    // Append node\n    for (let y = 0; y < Y; ++y) {\n      const levels = tails[y].levels;\n      levels[y] = { next, span: levels[y].span - span };\n      tails[y] = next;\n    }\n  }\n\n  // Return root, tails and list length\n  return { root, size, tails };\n}\n\n/**\n * Generates a new skip list node.\n *\n * @param value - The value to be stored in the new skip list node.\n * @param levels - The number of levels the node participates in within the skip list. Defaults to `1`.\n * @param span - The uniform distance to the next node at each level. Defaults to `1`.\n * @param next - The uniform next node at each level. Defaults to `undefined`.\n *\n * @returns A {@link SkipNode} object populated with the specified value and levels array. Each\n *          level in the array is initialized with a `next` pointer and `span` distance set to\n *          the specified values.\n */\nexport function toNode<T>(\n  value: T,\n  levels = 1,\n  span = 1,\n  next?: SkipNode<T>\n): SkipNode<T> {\n  const array = new Array<SkipLink<T>>(levels);\n  for (let i = 0; i < levels; ++i) {\n    array[i] = { next, span };\n  }\n  return { value, levels: array };\n}\n\n/**\n * Generates a skip stack filled with pointers to the given node and index.\n *\n * @param node - The {@link SkipNode} to which all pointers in the generated stack will point.\n * @param index - The index in the skip list at which the node is located. Defaults to `0`.\n *\n * @returns A {@link SkipStack} array, where each level points to `node` with index `index`.\n *          The length of this array is equal to the number of levels in the input node.\n */\nexport function toStack<T>(node: SkipNode<T>, index = 0): SkipStack<T> {\n  const N = node.levels.length;\n  const stack: SkipStack<T> = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    stack[i] = { index, node };\n  }\n  return stack;\n}\n\n/**\n * Reduces the height of the skip list to the specified level.\n *\n * @param node - The skip node.\n * @param level - The target level.\n */\nexport function truncateLevels<T>(\n  node: SkipNode<T> | undefined,\n  level: number\n): void {\n  // Check inputs\n  if (node == null || node.levels.length <= level) {\n    return;\n  }\n\n  // Truncate nodes\n  while (node != null) {\n    const next = node.levels[level].next as SkipNode<T>;\n    node.levels.length = level;\n    node = next!;\n  }\n}\n\n/**\n * Iterates through a skip list, yielding each node's value.\n *\n * Iteration starts from the given node and continues the end of the list.\n * This function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The {@link SkipNode} at which to start iterating.\n */\nexport function* values<T>(node?: SkipNode<T>): Generator<T> {\n  while (node != null) {\n    yield node.value;\n    node = node.levels[0].next;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Bounded, BoundedConfig } from \"../../types/bounded\";\nimport {\n  SkipList,\n  SkipListConfig,\n  SkipCore,\n  SkipNode,\n} from \"../../types/skipList\";\n\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../../utils/constants\";\nimport {\n  isArrayLength,\n  isInfinity,\n  isIterable,\n  isLinkedLength,\n  isNumber,\n} from \"../../utils/is\";\nimport { chunk } from \"../../utils/iterable\";\nimport {\n  addIfBelow,\n  clamp,\n  isInRange,\n  simulateWinStreak,\n  toInteger,\n} from \"../../utils/math\";\nimport {\n  calcMaxLevel,\n  copy,\n  cut,\n  entries,\n  getEntry,\n  has,\n  insert,\n  keys,\n  toList,\n  toNode,\n  truncateLevels,\n  values,\n} from \"../../utils/skipList\";\n\nimport { CircularBase } from \"../circularBase\";\n\nexport interface CircularSkipListConfig extends BoundedConfig, SkipListConfig {}\n\nexport class CircularSkipList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, SkipList<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The maximum number of levels in the skip list.\n   */\n  protected _maxLevel: number;\n\n  /**\n   * @internal\n   * The probability factor used to randomly determine the levels\n   * of new nodes. Should be a value between 0 and 1, where a lower\n   * value results in fewer levels on average.\n   */\n  protected _p: number;\n\n  /**\n   * @internal\n   * The root of the skip list\n   */\n  protected _root: SkipNode<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last nodes in the skip list at each level.\n   */\n  protected _tails: SkipNode<T>[];\n\n  constructor();\n  constructor(capacity?: number | null);\n  constructor(config: CircularSkipListConfig);\n  constructor(items: Iterable<T>);\n  constructor(config?: CircularSkipListConfig | Iterable<T> | null | number) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._p = 0.5;\n    this._maxLevel = calcMaxLevel(this._p, LINKED_MAX_LENGTH);\n    this._root = toNode(undefined as T);\n    this._size = 0;\n    this._tails = [this._root];\n\n    // Case 1: input is null or undefined\n    if (config == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(config)) {\n      this.capacity = config;\n      return;\n    }\n\n    // Case 3: input is config\n    if (!isIterable(config)) {\n      this.capacity = config.capacity ?? this._capacity;\n      this.p = config.p ?? this._p;\n      const size = config.expectedSize ?? this._capacity;\n      this.maxLevel = config.maxLevel ?? calcMaxLevel(this._p, size);\n      return;\n    }\n\n    // Case 4: input is an iterable\n    for (const vals of chunk(config, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get levels(): number {\n    return this._root.levels.length;\n  }\n\n  get maxLevel(): number {\n    return this._maxLevel;\n  }\n\n  get p(): number {\n    return this._p;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularSkipList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink list and emit discarded items\n    const { root } = this._cut(0, this._size - capacity);\n    this._overflow(root.levels[0].next);\n  }\n\n  set maxLevel(maxLevel: number) {\n    // Convert input to number\n    maxLevel = +maxLevel;\n\n    // If input is invalid\n    if (!isArrayLength(maxLevel) || maxLevel <= 0) {\n      throw new RangeError(\"Invalid maxLevel\");\n    }\n\n    // Update\n    this._maxLevel = maxLevel;\n\n    // Remove excess levels\n    if (maxLevel < this.levels) {\n      truncateLevels(this._root, maxLevel);\n    }\n  }\n\n  set p(p: number) {\n    // Convert input to number\n    p = +p;\n\n    // If input is invalid\n    if (isNaN(p) || p < 0 || p > 1) {\n      throw new RangeError(\"Invalid p\");\n    }\n\n    // Update\n    this._p = p;\n  }\n\n  at(index: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    return getEntry(core, index).node.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tails = [this._root];\n    this._root.levels.length = 1;\n    this._root.levels[0] = { next: undefined, span: 1 };\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._cut(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.levels[0].next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n    if (start >= end) {\n      return this;\n    }\n\n    // Fill values\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    let { node } = getEntry(core, start);\n    for (let i = start; i < end; ++i) {\n      node.value = value;\n      node = node.levels[0].next!;\n    }\n\n    // Return list\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.levels[0].next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.levels[0].next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.levels[0].next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.levels[0].next!.value;\n  }\n\n  push(...values: T[]): number {\n    // Add values\n    this._insert(this._size, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Set value\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    const { node } = getEntry(core, index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.levels[0].next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularSkipList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Create config\n    const config: CircularSkipListConfig = {\n      capacity: 0,\n      p: this._p,\n      maxLevel: this._maxLevel,\n    };\n\n    // Check if empty\n    if (start >= end) {\n      return new CircularSkipList<T>(config);\n    }\n\n    // Create segment copy\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    const seg = copy(getEntry(core, start).node, end - start);\n\n    // Return copied segment as a list\n    config.capacity = seg.size;\n    const list = new CircularSkipList<T>(config);\n    list._root = seg.root;\n    list._tails = seg.tails;\n    list._size = seg.size;\n\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularSkipList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items\n    const core = this._cut(start, deleteCount);\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    const list = new CircularSkipList<T>({\n      capacity: deleteCount,\n      p: this._p,\n      maxLevel: this._maxLevel,\n    });\n    list._root = core.root;\n    list._tails = core.tails;\n    list._size = core.size;\n\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...values: T[]): number {\n    // Add values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this._root.levels[0].next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): SkipCore<T> {\n    // Create list core\n    const core = { root: this._root, size: this._size, tails: this._tails };\n\n    // Cut and get removed segment\n    const seg = cut(core, start, start + count);\n\n    // Update list state\n    this._size = core.size;\n    this._tails = core.tails;\n\n    // Return cut segment\n    return seg;\n  }\n\n  /**\n   * @internal\n   */\n  protected _genLevels(N: number): number[] {\n    const levels = new Array<number>(N);\n    const maxLevel = this._maxLevel - 1;\n    for (let i = 0; i < N; ++i) {\n      levels[i] = 1 + simulateWinStreak(this._p, maxLevel - 1);\n    }\n    return levels;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(root.levels[0].next);\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted?: T[] | SkipNode<T>): void {\n    if (evicted == null) {\n      return;\n    }\n    if (Array.isArray(evicted)) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n    for (const array of chunk(values(evicted), ARGS_MAX_LENGTH)) {\n      this._emitter.emit(BoundedEvent.Overflow, array);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return;\n    }\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(root.levels[0].next);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Create segment\n    const levels = this._genLevels(values.length);\n    const seg = toList(levels, values);\n\n    // Insert segment\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    insert(core, index, seg);\n\n    // Update list state\n    this._size = core.size;\n    this._tails = core.tails;\n  }\n}\n","import { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Collection } from \"../../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../../utils/is\";\n\nimport { CircularBase } from \"../circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The internal map.\n   */\n  protected _map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this._map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this._map = new Map(capacity as Iterable<[K, V]>);\n    this._capacity = this._map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the map.\n   */\n  get size(): number {\n    return this._map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this._map);\n      this.clear();\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this._map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this._map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this._map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this._map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this._map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this._map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this._map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this._map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this._map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this._emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this._map.delete(key) && this.size >= this.capacity) {\n      const entry = this._map.entries().next().value;\n      this._map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this._map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this._map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this._map.values();\n  }\n}\n","import { Queue } from \"../../types/queue\";\nimport { Bounded } from \"../../types/bounded\";\n\nimport { CircularLinkedList } from \"../list/circularLinkedList\";\nimport { BoundedEvent } from \"../..\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.at(0);\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  front(): T | undefined {\n    return this._list.at(0);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Queue } from \"../../types/queue\";\nimport { Bounded } from \"../../types/bounded\";\nimport { CircularArrayList } from \"../list/circularArrayList\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularArrayList<T>;\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this._list.first();\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Collection } from \"../../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../../utils/is\";\n\nimport { CircularBase } from \"../circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The internal set.\n   */\n  protected _set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this._set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this._set = new Set(capacity as Iterable<T>);\n    this._capacity = this._set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the set.\n   */\n  get size(): number {\n    return this._set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this._set);\n      this.clear();\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this._set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this._set.delete(value);\n      evicted.push(value);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this._emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this._set.delete(value) && this.size >= this.capacity) {\n      const out = this._set.values().next().value;\n      this._set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this._set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this._set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this._set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this._set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this._set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this._set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this._set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this._set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._set.values();\n  }\n}\n","import { Stack } from \"../../types/stack\";\nimport { Bounded } from \"../../types/bounded\";\nimport { BoundedEvent, CircularDoublyLinkedList } from \"../..\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { BoundedEvent } from \"../../types/boundedEvent\";\nimport { Stack } from \"../../types/stack\";\nimport { Bounded } from \"../../types/bounded\";\nimport { CircularArrayList } from \"../list/circularArrayList\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularArrayList<T>;\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.last();\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  top(): T | undefined {\n    return this._list.last();\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n"],"names":["has","EventEmitter","module","chunk","copy","cut","get","entries","keys","toList","values","singlyCut","singlyGet","getValues","size","levels","y","root","evicted"],"mappings":"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","x_google_ignoreList":[1]}