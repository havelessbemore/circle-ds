{"version":3,"file":"circle-ds.min.mjs","sources":["../../src/types/boundedEvent.ts","../../__vite-browser-external","../../src/circle/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/circle/circularLinkedDeque.ts","../../src/circle/circularLinkedQueue.ts","../../src/circle/circularLinkedStack.ts","../../src/circle/circularMap.ts","../../src/circle/circularQueue.ts","../../src/circle/circularSet.ts","../../src/circle/circularStack.ts"],"sourcesContent":["export const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","export default {}","import EventEmitter from \"events\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport interface BoundedConstructor<T> {\n  new (capacity?: number | null): CircularBase<T>;\n}\n\nexport class CircularBase<T> {\n  /**\n   * The event emitter.\n   * @internal\n   */\n  protected emitter: EventEmitter;\n\n  constructor() {\n    this.emitter = new EventEmitter();\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for\n   * the {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * Alternatively, the `addListener()` method can be used to add\n   * the event listener to the end of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  prependListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.prependListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * \"The length data property of an Array instance represents the number of\n * elements in that array. The value is an unsigned, 32-bit integer...\"\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length}\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1;\n","import { ARRAY_MAX_LENGTH } from \"./constants\";\n\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\nexport function isNull(value: unknown): value is null {\n  return value === null;\n}\n\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n\nexport function isUndefined(value: unknown): value is undefined {\n  return typeof value === \"undefined\";\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Deque } from \"../types/deque\";\nimport {\n  isInfinity,\n  isNull,\n  isNumber,\n  isSafeCount,\n  isUndefined,\n} from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\n\ninterface Node<T> {\n  next: Node<T>;\n  prev: Node<T>;\n  value: T;\n}\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Deque<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the collection.\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n    this._size = 0;\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root.prev;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { next: this.root, prev: tail, value };\n      tail = tail.next;\n      this.root.prev = tail;\n      ++this._size;\n    }\n    this._capacity = this._size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularLinkedDeque.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink stack\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    head.prev = this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Removes the top element from the stack and returns it.\n   *\n   * @returns the top element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.prev;\n    this.root.prev = node.prev;\n    node.prev.next = this.root;\n    --this._size;\n    return node.value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, elems);\n      return this._size;\n    }\n\n    const N = elems.length;\n    const root = this.root;\n    const evicted: T[] = [];\n\n    let tail = root.prev;\n    for (let i = 0; i < N; ++i) {\n      tail.next = { next: root, prev: tail, value: elems[i] };\n      tail = tail.next;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n    root.prev = tail;\n    root.next.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const head = this.root.next.next;\n    const value = head.prev.value;\n    this.root.next = head;\n    head.prev = this.root;\n    --this._size;\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Inserts new elements at the front of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  unshift(...elems: T[]): number {\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, elems);\n      return this._size;\n    }\n\n    const root = this.root;\n    const evicted: T[] = [];\n\n    let head = root.next;\n    for (let i = elems.length - 1; i >= 0; --i) {\n      head = { next: head, prev: root, value: elems[i] };\n      head.next.prev = head;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.prev.value);\n        root.prev = root.prev.prev;\n      }\n    }\n    root.next = head;\n    root.prev.next = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted.reverse());\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport {\n  isInfinity,\n  isNull,\n  isNumber,\n  isSafeCount,\n  isUndefined,\n} from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\n\ninterface Node<T> {\n  next: Node<T>;\n  value: T;\n}\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Queue<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the collection.\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The tail of the collection.\n   * @internal\n   */\n  protected tail: Node<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this._size = 0;\n    this.tail = this.root;\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { next: this.root, value } as Node<T>;\n      tail = tail.next;\n      ++this._size;\n    }\n    this.tail = tail;\n    tail.next = this.root;\n    this._capacity = this._size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularLinkedQueue.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink queue\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    this.tail = this._size > 0 ? this.tail : this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.tail = this.root;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.root.next.value;\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      return this._size;\n    }\n\n    const N = elems.length;\n    const root = this.root;\n    const evicted: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      this.tail.next = { next: root, value: elems[i] };\n      this.tail = this.tail.next;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const head = this.root.next;\n    this.root.next = head.next;\n    if (--this._size < 1) {\n      this.tail = this.root;\n    }\n    return head.value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { Stack } from \"../types/stack\";\nimport {\n  isInfinity,\n  isNull,\n  isNumber,\n  isSafeCount,\n  isUndefined,\n} from \"../utils/is\";\nimport { BoundedEvent } from \"..\";\nimport { Bounded } from \"../types/bounded\";\n\ninterface Node<T> {\n  next: Node<T>;\n  prev: Node<T>;\n  value: T;\n}\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Stack<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The root of the collection.\n   * @internal\n   */\n  protected root: Node<T>;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n    this._size = 0;\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { prev: tail, value } as Node<T>;\n      tail = tail.next;\n      ++this._size;\n    }\n    tail.next = this.root;\n    this.root.prev = tail;\n    this._capacity = this._size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularLinkedStack.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink stack\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    head.prev = this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Removes the top element from the stack and returns it.\n   *\n   * @returns the top element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.prev;\n    this.root.prev = node.prev;\n    node.prev.next = this.root;\n    --this._size;\n    return node.value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      return this._size;\n    }\n\n    const N = elems.length;\n    const root = this.root;\n    const evicted: T[] = [];\n\n    let tail = root.prev;\n    for (let i = 0; i < N; ++i) {\n      tail.next = { next: root, prev: tail, value: elems[i] };\n      tail = tail.next;\n      if (this._size < capacity) {\n        ++this._size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n    root.prev = tail;\n    root.next.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element pushed onto the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this.root.prev.value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport {\n  isInfinity,\n  isNull,\n  isNumber,\n  isSafeCount,\n  isUndefined,\n} from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal map.\n   * @internal\n   */\n  protected map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const [key, value] of capacity as Iterable<[K, V]>) {\n      this.map.set(key, value);\n    }\n    this._capacity = this.map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of values in the map.\n   */\n  get size(): number {\n    return this.map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.map);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this.map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this.map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this.map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this.map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this.map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this.map.delete(key) && this.size >= this.capacity) {\n      const entry = this.map.entries().next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this.map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this.map.values();\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport {\n  isArrayLength,\n  isInfinity,\n  isNull,\n  isNumber,\n  isUndefined,\n} from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Queue<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isArrayLength(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Check if queue is empty\n    if (this._size < 1) {\n      this._capacity = capacity;\n      this.clear();\n      return;\n    }\n\n    // Check if queue is shrinking or growing\n    capacity < this._capacity\n      ? this.emit(this.shrink(capacity)) // shrinking\n      : this.grow(capacity); // growing\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularQueue.name;\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link front | front()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link first | first()}.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    // Base 1: No input\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Base 2: No capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit([elems]);\n      return this._size;\n    }\n\n    // Get evicted items\n    const diff = N - capacity;\n    const evicted = this.evict(this.size + diff);\n    if (diff > 0) {\n      evicted.push(elems.splice(0, diff));\n    }\n\n    // Base 3: Too many inputs\n    if (diff >= 0) {\n      this.vals = elems;\n      this._size = capacity;\n      this.emit(evicted);\n      return this._size;\n    }\n\n    // Add each element to the queue\n    let tail = this.next;\n    const vals = this.vals;\n    for (let i = 0; i < N; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    // Update meta and emit evicted items\n    this._size += N;\n    this.next = tail;\n    this.emit(evicted);\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    --this._size;\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined as T;\n    if (++this.head >= this._capacity) {\n      this.head = 0;\n      this.vals.length = this.next;\n    }\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if queue is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the queue is stored sequentially in memory.\n   *\n   * @returns `true` if the queue is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  protected emit(evicted: T[][]): void {\n    const N = evicted.length;\n    for (let i = 0; i < N; ++i) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted[i]);\n    }\n  }\n\n  /**\n   * Removes a given number of elements from the queue.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict\n   */\n  protected evict(count: number): T[][] {\n    if (count <= 0) {\n      return [];\n    }\n\n    const evicted: T[][] = [];\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      evicted.push(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return evicted;\n    }\n\n    if (isNonsequential) {\n      evicted.push(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return evicted;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      evicted.push(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return evicted;\n    }\n\n    evicted.push(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n    return evicted;\n  }\n\n  /**\n   * Adjusts the queue to fit within the given capacity.\n   *\n   * Assumes the queue is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the queue was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If queue fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If queue must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If queue must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): T[][] {\n    // Handle overflow\n    const evicted = this.evict(this._size - capacity);\n\n    // Check if queue is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return evicted;\n    }\n\n    // Shift 1st half of queue: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n    return evicted;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport {\n  isInfinity,\n  isNull,\n  isNumber,\n  isSafeCount,\n  isUndefined,\n} from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal set.\n   * @internal\n   */\n  protected set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const value of capacity as Iterable<T>) {\n      this.set.add(value);\n    }\n    this._capacity = this.set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   *  @returns the number of values in the set.\n   */\n  get size(): number {\n    return this.set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.set);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this.set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this.set.delete(value);\n      evicted.push(value);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this.set.delete(value) && this.size >= this.capacity) {\n      const out = this.set.values().next().value;\n      this.set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this.set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this.set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this.set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this.set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this.set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this.set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.set.values();\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Stack } from \"../types/stack\";\nimport {\n  isArrayLength,\n  isInfinity,\n  isNull,\n  isNumber,\n  isUndefined,\n} from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Stack<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // Case 1: capacity is null, undefined or Infinity\n    if (isUndefined(capacity) || isNull(capacity) || isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isArrayLength(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Check if stack is empty\n    if (this._size < 1) {\n      this._capacity = capacity;\n      this.clear();\n      return;\n    }\n\n    // Check if stack is shrinking or growing\n    capacity < this._capacity\n      ? this.emit(this.shrink(capacity)) // shrinking\n      : this.grow(capacity); // growing\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag]() {\n    return CircularStack.name;\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Get the last element in the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    return this.vals[(this.head + this._size - 1) % this._capacity];\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    let tail = this.next - 1;\n    if (tail < 0) {\n      tail += this.head + this._size;\n    }\n\n    --this._size;\n    this.next = tail;\n    const value = this.vals[tail];\n    this.vals[tail] = undefined as T;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): number {\n    // Base 1: No input\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Base 2: No capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit([elems]);\n      return this._size;\n    }\n\n    // Get evicted items\n    const diff = N - capacity;\n    const evicted = this.evict(this.size + diff);\n    if (diff > 0) {\n      evicted.push(elems.splice(0, diff));\n    }\n\n    // Base 3: Too many inputs\n    if (diff >= 0) {\n      this.vals = elems;\n      this._size = capacity;\n      this.emit(evicted);\n      return this._size;\n    }\n\n    // Add each element to the stack\n    let tail = this.next;\n    const vals = this.vals;\n    for (let i = 0; i < N; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    // Update meta and emit evicted items\n    this._size += N;\n    this.next = tail;\n    this.emit(evicted);\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element in the stack.\n   *\n   * Alias for {@link last | last()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    return this.vals[(this.head + this._size - 1) % this._capacity];\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if stack is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // stack is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the stack is stored sequentially in memory.\n   *\n   * @returns `true` if the stack is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  protected emit(evicted: T[][]): void {\n    const N = evicted.length;\n    for (let i = 0; i < N; ++i) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted[i]);\n    }\n  }\n\n  /**\n   * Removes a given number of elements from the stack.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict\n   */\n  protected evict(count: number): T[][] {\n    if (count <= 0) {\n      return [];\n    }\n\n    const evicted: T[][] = [];\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      evicted.push(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return evicted;\n    }\n\n    if (isNonsequential) {\n      evicted.push(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return evicted;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      evicted.push(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return evicted;\n    }\n\n    evicted.push(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n    return evicted;\n  }\n\n  /**\n   * Adjusts the stack to fit within the given capacity.\n   *\n   * Assumes the stack is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - the new capacity.\n   *\n   * @returns `true` if the stack was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If stack fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If stack must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If stack must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): T[][] {\n    // Handle overflow\n    const evicted = this.evict(this._size - capacity);\n\n    // Check if stack is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return evicted;\n    }\n\n    // Shift 1st half of stack: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n    return evicted;\n  }\n}\n"],"names":["BoundedEvent","EventEmitter","CircularBase","__publicField","event","listener","ARRAY_MAX_LENGTH","isArrayLength","value","isInfinity","isNull","isNumber","isSafeCount","isUndefined","CircularLinkedDeque","capacity","tail","items","head","node","callbackfn","thisArg","i","elems","N","root","evicted","CircularLinkedQueue","CircularLinkedStack","CircularMap","key","iter","n","entry","CircularQueue","ext","diff","vals","temp","count","len","isNonsequential","CircularSet","out","CircularStack"],"mappings":"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"}