{"version":3,"file":"circle-ds.min.mjs","sources":["../../src/utils/is.ts","../../src/circular/circularView.ts","../../src/circular/circularQueue.ts","../../src/circular/circularStack.ts","../../src/utils/mixins.ts","../../src/circular/circularDeque.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return isFunction(value?.[Symbol.iterator]);\n}\n\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","import { isIterable } from \"../utils/is\";\nimport { Collection } from \"../types/collection\";\n\n/**\n * A circular view is a fixed-size, read-only, circular array used to\n * store elements.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularView<T> implements Collection<T, number> {\n  /**\n   * The index representing the first element in the collection.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * The number of elements in the collection.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The index one more than the last element in the collection.\n   * @internal\n   */\n  protected tail: number;\n\n  /**\n   * The values in the collection.\n   * @internal\n   */\n  protected vals: (T | undefined)[];\n\n  /**\n   * Capacity defaults to zero and should be updated via {@link CircularView.capacity}.\n   */\n  constructor();\n  /**\n   * @param capacity - the maximum capacity.\n   */\n  constructor(capacity: number);\n  /**\n   * @param items - the items to store in the collection.\n   */\n  constructor(items: Iterable<T>);\n  /**\n   * @param items - the items to store in the collection.\n   */\n  constructor(...items: T[]);\n  constructor(capacity?: number | T | Iterable<T>, ...items: T[]) {\n    this.head = 0;\n    this._size = 0;\n    this.tail = 0;\n    this.vals = [];\n\n    const numArgs = arguments.length;\n    if (numArgs < 1) {\n      return;\n    }\n\n    if (numArgs === 1 && typeof capacity === \"number\") {\n      this.vals.length = capacity;\n    } else if (numArgs === 1 && isIterable(capacity)) {\n      this.vals = Array.from(capacity);\n      this._size = this.vals.length;\n    } else {\n      this.vals = items;\n      this.vals.push(capacity as T);\n      this._size = this.vals.length;\n      this.tail = this._size - 1;\n      this.head = this.tail;\n    }\n  }\n\n  /**\n   * Creates a collection from an iterable object.\n   *\n   * @param iterable - an iterable object to convert to a collection.\n   */\n  static from<T, I extends typeof CircularView>(\n    this: I,\n    iterable: Iterable<T> | ArrayLike<T>\n  ): InstanceType<I> {\n    const obj = new this(0) as InstanceType<I>;\n    obj.vals = Array.from(iterable);\n    obj._size = obj.vals.length;\n    return obj;\n  }\n\n  /**\n   * Creates a collection from a variable number of arguments.\n   *\n   * @param elements - the elements to be inserted into the collection.\n   */\n  static of<I extends typeof CircularView<T>, T = unknown>(\n    this: I,\n    ...elements: T[]\n  ): InstanceType<I> {\n    const obj = new this(0) as InstanceType<I>;\n    obj.vals = elements;\n    obj._size = elements.length;\n    return obj;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.vals.length;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(newCapacity: number) {\n    // Sanitize input\n\n    newCapacity = +newCapacity;\n    if (!Number.isSafeInteger(newCapacity) || newCapacity < 0) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    const curCapacity = this.capacity;\n    if (this._size <= 0 || newCapacity == 0) {\n      this.head = 0;\n      this.tail = 0;\n      this._size = 0;\n      this.vals.length = newCapacity;\n    } else if (newCapacity > curCapacity) {\n      this.grow(newCapacity);\n    } else if (newCapacity < curCapacity) {\n      this.shrink(newCapacity);\n    }\n  }\n\n  /**\n   *  @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.tail = 0;\n    this.vals = new Array(this.capacity);\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[this.toInt(ext)]!];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[this.toInt(ext)]!;\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      if (this.vals[this.toInt(ext)] === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[this.toInt(ext)]!;\n    }\n  }\n\n  /**\n   * Converts an external index to an internal index\n   * @internal\n   *\n   * @param ext - The external index\n   *\n   * @returns The internal index\n   */\n  protected toInt(ext: number): number {\n    return (this.head + ext) % this.capacity;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param newCapacity - the new capacity\n   */\n  protected grow(newCapacity: number): void {\n    const curCapacity = this.capacity;\n    const tail = this.head + this._size;\n\n    this.vals.length = newCapacity;\n    if (tail <= curCapacity) {\n      this.tail = tail;\n      return;\n    }\n\n    const diff = Math.min(this.tail, newCapacity - curCapacity);\n    this.vals.copyWithin(curCapacity, 0, diff);\n    this.vals.fill(undefined, this.tail - diff, diff);\n    this.vals.copyWithin(0, diff, this.tail);\n    this.vals.fill(undefined, Math.max(diff, this.tail - diff), this.tail);\n    this.tail = tail % newCapacity;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param newCapacity - the new capacity\n   */\n  protected shrink(newCapacity: number): void {\n    this._size = Math.min(this._size, newCapacity);\n    this.tail = this.head + this._size;\n\n    if (this.tail <= newCapacity) {\n      this.tail %= newCapacity;\n      this.vals.length = newCapacity;\n    } else {\n      this.tail %= this.capacity;\n      this.vals = Array.from(this);\n      this.tail = this._size % newCapacity;\n      this.head = 0;\n    }\n  }\n}\n","import { CircularView } from \"./circularView\";\nimport { Queue } from \"../types/queue\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T> extends CircularView<T> implements Queue<T> {\n  /**\n   * Get the element at the front of the queue.\n   *\n   * @returns the earliest inserted element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n\n  /**\n   * Inserts new elements at the end of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): T[] {\n    const cap = this.capacity;\n    if (cap < 1) {\n      return Array.from(elems);\n    }\n\n    const N = elems.length;\n    const out: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      const prev = this.vals[this.tail]!;\n      this.vals[this.tail] = elems[i];\n      this.tail = this.toInt(this._size + 1);\n      if (this._size < cap) {\n        ++this._size;\n      } else {\n        this.head = this.tail;\n        out.push(prev);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined;\n    this.head = (this.head + 1) % this.vals.length;\n    --this._size;\n    return value;\n  }\n}\n","import { CircularView } from \"./circularView\";\nimport { Stack } from \"../types/stack\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T> extends CircularView<T> implements Stack<T> {\n  /**\n   * Removes the last element from the stack and returns it.\n   *\n   * @returns the last element in the stack, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    this.tail = this.toInt(this._size - 1);\n    const value = this.vals[this.tail];\n    this.vals[this.tail] = undefined;\n    --this._size;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The overwritten elements, if any.\n   */\n  push(...elems: T[]): T[] {\n    const cap = this.capacity;\n    if (cap < 1) {\n      return Array.from(elems);\n    }\n\n    const N = elems.length;\n    const out: T[] = [];\n\n    for (let i = 0; i < N; ++i) {\n      const prev = this.vals[this.tail]!;\n      this.vals[this.tail] = elems[i];\n      this.tail = this.toInt(this._size + 1);\n      if (this._size < cap) {\n        ++this._size;\n      } else {\n        this.head = this.tail;\n        out.push(prev);\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Get the element at the top of the stack.\n   *\n   * @returns the last inserted element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.toInt(this._size - 1)];\n  }\n}\n","export type Constructor<T = object> = new (...args: unknown[]) => T;\n\nexport function applyMixins(ctor: Constructor, mixins: Constructor[]): void {\n  for (const mixin of mixins) {\n    const proto = mixin.prototype;\n    for (const name of Object.getOwnPropertyNames(proto)) {\n      const descriptor =\n        Object.getOwnPropertyDescriptor(proto, name) ?? Object.create(null);\n      Object.defineProperty(ctor.prototype, name, descriptor);\n    }\n  }\n}\n","import { CircularView } from \"./circularView\";\nimport { CircularQueue } from \"./circularQueue\";\nimport { CircularStack } from \"./circularStack\";\nimport { Deque } from \"../types/deque\";\nimport { applyMixins } from \"../utils/mixins\";\n\n/* eslint-disable @typescript-eslint/no-unsafe-declaration-merging */\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T> extends CircularView<T> implements Deque<T> {\n  /**\n   * Get the element at the back of the queue.\n   *\n   * @returns the last inserted element, or `undefined` if empty.\n   */\n  back(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.toInt(this._size - 1)];\n  }\n  /**\n   * Get the element at the bottom of the stack.\n   *\n   * @returns the earliest inserted element, or `undefined` if empty.\n   */\n  bottom(): T | undefined {\n    return this._size <= 0 ? undefined : this.vals[this.head];\n  }\n  /**\n   * Inserts new elements at the start of the collection.\n   *\n   * @param elems - Elements to insert\n   *\n   * @returns The overwritten elements\n   */\n  unshift(...elems: T[]): T[] {\n    const length = this.vals.length;\n    if (length < 1) {\n      return Array.from(elems);\n    }\n\n    const out: T[] = [];\n    for (let i = elems.length - 1; i >= 0; --i) {\n      this.head = (this.head - 1 + length) % length;\n      const prev = this.vals[this.head]!;\n      this.vals[this.head] = elems[i];\n      if (this._size < length) {\n        ++this._size;\n      } else {\n        this.tail = this.head;\n        out.push(prev);\n      }\n    }\n\n    return out.reverse();\n  }\n}\n\nexport interface CircularDeque<T> extends CircularQueue<T>, CircularStack<T> {}\napplyMixins(CircularDeque, [CircularQueue, CircularStack]);\n"],"names":["isFunction","value","isIterable","CircularView","capacity","items","__publicField","numArgs","iterable","obj","elements","newCapacity","curCapacity","ext","callbackfn","thisArg","N","tail","diff","CircularQueue","elems","cap","out","i","prev","CircularStack","applyMixins","ctor","mixins","mixin","proto","name","descriptor","CircularDeque","length"],"mappings":"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"}