{"version":3,"file":"circle-ds.min.mjs","sources":["../../src/types/boundedEvent.ts","../../__vite-browser-external","../../src/circle/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/circle/circularDeque.ts","../../src/utils/math.ts","../../src/circle/circularDoublyLinkedList.ts","../../src/circle/circularLinkedDeque.ts","../../src/utils/linkedNode.ts","../../src/circle/circularLinkedList.ts","../../src/circle/circularLinkedQueue.ts","../../src/circle/circularLinkedStack.ts","../../src/circle/circularMap.ts","../../src/circle/circularQueue.ts","../../src/circle/circularSet.ts","../../src/circle/circularStack.ts"],"sourcesContent":["/**\n * An enumeration of event types supported by {@link Bounded} collections.\n *\n * This object defines a set of constants representing event names that can\n * be emitted by instances of collections implementing the {@link Bounded} interface.\n * These events signify specific actions or changes in the state of the collection.\n *\n * Defined events include:\n * - `Overflow`: Indicates that the collection has reached its capacity, and\n *   as a result, one or more elements have been removed to accommodate new elements.\n *   This event is triggered during operations that add elements to the collection when\n *   it exceeds its capacity, or when capacity is updated below the collection's current\n *   size. Listeners attached to this event will receive an array of elements that were\n *   removed due to the overflow. Removed elements may be sent across 1 or more event\n *   instances.\n *\n * This object is marked as `const` to ensure that its properties are read-only,\n * preventing modification of event names which could lead to inconsistencies in\n * event handling across the application.\n */\nexport const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","export default {}","import EventEmitter from \"events\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport class CircularBase<T> {\n  /**\n   * The event emitter.\n   * @internal\n   */\n  protected emitter: EventEmitter;\n\n  constructor(emitter = new EventEmitter()) {\n    this.emitter = emitter;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for\n   * the {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * Alternatively, the `addListener()` method can be used to add\n   * the event listener to the end of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  prependListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.prependListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this.emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * Represents the maximum number of arguments that can be passed to a function.\n *\n * While ECMAScript specifications do not explicitly limit the number of function arguments,\n * practical limits are imposed by JavaScript engine implementations. Different engines can\n * have different maximums, so a conservative value is used to prevent runtime errors.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-list-and-record-specification-type | ECMAScript Specification},\n * section \"6.2.2 The List and Record Specification Types\".\n */\nexport const ARGS_MAX_LENGTH = 16383; // 2**14 - 1\n\n/**\n * Defines the maximum allowable length of an array.\n *\n * According to the ECMAScript specification, the length property of an array is\n * an unsigned 32-bit integer, so its range is 0 to 2**32 - 1, inclusive. Beyond this,\n * operations that modify the array length (e.g., `push`, `pop`, `unshift`, `shift`)\n * may fail or behave unexpectedly.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-arraycreate | ECMAScript Specification},\n * section \"10.4.2.2 ArrayCreate\".\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1;\n","import { ARRAY_MAX_LENGTH } from \"./constants\";\n\n/**\n * Checks if a given value is an integer within a valid array length range.\n *\n * This function is useful for validating array lengths before attempting operations\n * that could result in a `RangeError` due to invalid array size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, ARRAY_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a function.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a function, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n/**\n * Checks if a given value is positive infinity.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is positive infinity, `false` otherwise.\n */\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n/**\n * Determines whether the provided value is iterable.\n *\n * This is useful for determining if a value can be used\n * in a `for...of` loop or with spread syntax.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value implements the iterable protocol, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\n/**\n * Determines whether the provided value is a number.\n *\n * This includes `NaN` and `Infinity`, so consider additional\n * checks if those values are not desirable.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type number, `false` otherwise.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Checks if a given value is a safe integer greater than or equal to 0.\n *\n * This is useful for validating counts or sizes that must be within the safe\n * integer range to prevent precision loss.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a safe integer and non-negative, `false` otherwise.\n */\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\n/**\n * Determines whether the provided value is a symbol.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a symbol, `false` otherwise.\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\nimport { Deque } from \"..\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Deque<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new deque. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new deque with the given capacity.\n   *\n   * @param capacity - the deque's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new deque from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the deque.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  /**\n   * @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularDeque.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size < 1) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Get the first element in the deque.\n   *\n   * Alias for {@link front | front()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the deque.\n   *\n   * Alias for {@link first | first()}.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Get the last element in the deque.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.top();\n  }\n\n  /**\n   * Removes the last element from the deque.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    const tail = this.next > 0 ? this.next - 1 : this.head + this._size - 1;\n\n    --this._size;\n    this.next = tail;\n    const value = this.vals[tail];\n    this.vals[tail] = undefined as T;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the deque.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the deque.\n   */\n  push(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._push(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._push(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evictHead(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(0, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._push(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the deque.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    --this._size;\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined as T;\n    if (++this.head >= this._capacity) {\n      this.head = 0;\n      this.vals.length = this.next;\n    }\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Inserts new elements at the end of the deque.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the deque.\n   */\n  unshift(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._unshift(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._unshift(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evictTail(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(N - diff, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._unshift(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Get the last element in the deque.\n   *\n   * Alias for {@link last | last()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    return this.vals[(this.head + this._size - 1) % this._capacity];\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Emit an event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected emit(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes a given number of elements from the deque.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evictHead(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      this.emit(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n  }\n\n  /**\n   * Removes a given number of elements from the deque.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evictTail(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const isNonsequential = !this.isSequential();\n    if (isNonsequential && this.next > count) {\n      this.emit(this.vals.slice(this.next - count, this.next));\n      this.vals.fill(undefined as T, this.next - count, this.next);\n      this.next -= count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(0, this.next));\n      this.vals.fill(undefined as T, 0, this.next);\n      this._size -= this.next;\n      count -= this.next;\n      this.next = 0;\n      if (count <= 0) {\n        return;\n      }\n    }\n\n    const tail = this.head + this._size;\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, tail));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(tail - count, tail));\n    this.next = tail - count;\n    this.vals.length = this.next;\n    this._size -= count;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if deque is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the deque is stored sequentially in memory.\n   * @internal\n   *\n   * @returns `true` if the deque is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param max - The number of elements to append.\n   */\n  protected _push(elems: T[], max: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let tail = this.next;\n    for (let i = 0; i < max; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    this.next = tail;\n    this._size += max;\n  }\n\n  /**\n   * Adjusts the deque to fit within the given capacity.\n   * @internal\n   *\n   * Assumes the deque is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the deque was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If deque fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If deque must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If deque must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    this.evictHead(this._size - capacity);\n\n    // Check if deque is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of deque: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param num - The number of elements to append.\n   */\n  protected _unshift(elems: T[], num: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let head = this.head;\n    const min = elems.length - num;\n    for (let i = elems.length - 1; i >= min; --i) {\n      if (--head < 0) {\n        head += capacity;\n      }\n      vals[head] = elems[i];\n    }\n\n    this.head = head;\n    this._size += num;\n  }\n}\n","/**\n * Restricts a given numerical value within a specified range [min, max].\n *\n * If the provided value is less than the minimum, the minimum is returned.\n * If it is greater than the maximum, the maximum is returned. If the value\n * is within the range, the value itself is returned. An error is thrown if\n * the minimum range value is greater than the maximum range value, as this\n * represents an invalid range.\n *\n * @param value - The numerical value to clamp.\n * @param min - The minimum allowable value of the range.\n * @param max - The maximum allowable value of the range.\n *\n * @returns The clamped value within the specified range.\n *\n * @throws `RangeError` If `min` is greater than `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError(\"Invalid clamp range; min must be <= max\");\n  }\n  if (value <= min) {\n    return min;\n  }\n  return value <= max ? value : max;\n}\n\n/**\n * Calculates the logarithm of a given value with the specified base.\n *\n * This function uses natural logarithms (`Math.log`) for its calculations.\n * If either the value or the base is less than or equal to 0, `NaN` is returned\n * to indicate an invalid operation, as logarithms are not defined for non-positive\n * values and bases.\n *\n * @param value - The numerical value for which to calculate the logarithm. Must be positive.\n * @param base - The base of the logarithm. Must be positive.\n *\n * @returns The calculated logarithm of the value with the given base, or `NaN` for invalid inputs.\n */\nexport function log(value: number, base: number): number {\n  return value >= 0 && base > 0 ? Math.log(value) / Math.log(base) : NaN;\n}\n\n/**\n * Generates a number representing the length of a consecutive run based on a\n * probability threshold.\n *\n * This function iteratively increments a counter as long as the randomly\n * generated numbers from `randomFn` are less than the specified probability\n * threshold `p`, or until the counter reaches the maximum `max`.\n *\n * The function is useful for simulations or models that require a random yet\n * probabilistically constrained sequence length, such as simulating streaks or\n * runs in games of chance.\n *\n * @param p - The probability threshold. Defaults to 0.5.\n * @param max - The maximum value the of the run. Defaults to Infinity.\n * @param min - The starting value of the run. Defaults to 0.\n * @param randomFn - A function that generates a random number. Defaults to `Math.random`.\n *\n * @returns The length of the run.\n */\nexport function randomRun(\n  p = 0.5,\n  max = Infinity,\n  min = 0,\n  randomFn = Math.random\n): number {\n  while (min < max && randomFn() < p) {\n    ++min;\n  }\n  return min;\n}\n\n/**\n * Attempts to convert a given value to an integer.\n *\n * The function first tries to convert the value to a number. If the result\n * is not valid (i.e. `NaN`), the given `defaultValue` is returned. Otherwise,\n * the function truncates the number to an integer using `Math.trunc`.\n *\n * This is useful for ensuring numerical operations are performed on integers,\n * with a controllable fallback for invalid inputs.\n *\n * @param value - The value to convert to an integer. This can be of any type.\n * @param defaultValue - The fallback value to return if conversion fails. Defaults to 0.\n *\n * @returns The converted integer, or `defaultValue` if conversion is not possible.\n */\nexport function toInteger(value?: unknown, defaultValue = 0): number {\n  value = +value!;\n  return isNaN(value as number) ? defaultValue : Math.trunc(value as number);\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { DoublyLinkedNode as Node } from \"../types/doublyLinkedNode\";\nimport { List } from \"../types/list\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { clamp, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularDoublyLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n  /**\n   * @internal\n   */\n  protected root!: Node<T>;\n  /**\n   * @internal\n   */\n  protected _size!: number;\n\n  /**\n   * Creates a new queue with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    let tail = this.root;\n    for (const value of capacity as Iterable<T>) {\n      tail.next = { prev: tail, value } as Node<T>;\n      tail = tail.next;\n      ++this._size;\n    }\n    tail.next = this.root;\n    this.root.prev = tail;\n    this._capacity = this._size;\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDoublyLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink\n    const items: T[] = [];\n    let head = this.root.next;\n    do {\n      items.push(head.value);\n      head = head.next;\n    } while (--this._size > capacity);\n    this.root.next = head;\n    head.prev = this.root;\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, items);\n  }\n\n  at(index: number): T | undefined {\n    const i = this.tryIndex(index);\n    return i == undefined ? undefined : this.getNode(i).value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.root.next = this.root;\n    this.root.prev = this.root;\n  }\n\n  delete(index: number): boolean {\n    index = this.tryIndex(index)!;\n    if (index == undefined) {\n      return false;\n    }\n    this.remove(this.getNode(index));\n    return true;\n  }\n\n  *entries(): IterableIterator<[number, T]> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield [i, node.value];\n    }\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(end, -size, size);\n    end += end >= 0 ? 0 : size;\n\n    // Update values\n    for (let node = this.getNode(start); start < end; ++start) {\n      node.value = value;\n      node = node.next;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    const N = this._size;\n    let node = this.root;\n    for (let i = 0; i < N; ++i) {\n      node = node.next;\n      if (node.value === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  *keys(): IterableIterator<number> {\n    for (let i = 0; i < this._size; ++i) {\n      yield i;\n    }\n  }\n\n  pop(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.prev;\n    this.remove(node);\n    return node.value;\n  }\n\n  push(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.append(this.root.prev, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    const i = this.tryIndex(index);\n    if (i == undefined) {\n      return undefined;\n    }\n    const node = this.getNode(i);\n    const prevValue = node.value;\n    node.value = value;\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    const node = this.root.next;\n    this.remove(node);\n    return node.value;\n  }\n\n  slice(start?: number, end?: number): CircularDoublyLinkedList<T> {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(end, -size, size);\n    end += end >= 0 ? 0 : size;\n\n    const out = new CircularDoublyLinkedList<T>();\n    for (let prev = this.getNode(start - 1); start < end; ++start) {\n      out.push(prev.next.value);\n      prev = prev.next;\n    }\n\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularDoublyLinkedList<T> {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, size - start);\n\n    // Create output list\n    const out = new CircularDoublyLinkedList<T>();\n\n    // Replace values\n    const itemCount = items.length;\n    let prev = this.getNode(start - 1);\n    const replaceCount = Math.min(deleteCount, itemCount);\n    for (let i = 0; i < replaceCount; ++i) {\n      prev = prev.next;\n      out.push(prev.value);\n      prev.value = items[i];\n    }\n\n    // Add values\n    if (deleteCount <= replaceCount) {\n      this.append(prev, items, replaceCount);\n      return out;\n    }\n\n    // Attach out tail to segment head\n    let tail = out.root.prev;\n    prev.next.prev = tail;\n    tail.next = prev.next;\n\n    // Find segment tail\n    const diff = deleteCount - replaceCount;\n    tail = this.moveRight(prev, diff);\n\n    // Delete segment from list\n    prev.next = tail.next;\n    tail.next.prev = prev;\n    this._size -= diff;\n\n    // Attach segment tail to out root\n    tail.next = out.root;\n    out.root.prev = tail;\n    out._size += diff;\n\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.prepend(this.root.next, values);\n\n    // Return size\n    return this._size;\n  }\n\n  *values(): IterableIterator<T> {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next;\n      yield node.value;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected append(prev: Node<T>, values: T[], minIndex = 0): Node<T> {\n    const root = this.root;\n    const next = prev.next;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = minIndex; i < N; ++i) {\n      const curr = { prev, value: values[i] } as Node<T>;\n      prev.next = curr;\n      prev = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next.value);\n        root.next = root.next.next;\n      }\n    }\n    prev.next = next;\n    next.prev = prev;\n    root.next.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return prev;\n  }\n\n  /**\n   * @internal\n   */\n  protected getNode(index: number): Node<T> {\n    const node = this.root;\n    const half = this._size / 2;\n    return index <= half\n      ? this.moveRight(node, index + 1)\n      : this.moveLeft(node, this._size - index);\n  }\n\n  /**\n   * @internal\n   */\n  protected moveLeft(node: Node<T>, steps: number): Node<T> {\n    for (let i = 0; i < steps; ++i) {\n      node = node.prev;\n    }\n    return node;\n  }\n\n  /**\n   * @internal\n   */\n  protected moveRight(node: Node<T>, steps: number): Node<T> {\n    for (let i = 0; i < steps; ++i) {\n      node = node.next;\n    }\n    return node;\n  }\n\n  /**\n   * @internal\n   */\n  protected prepend(next: Node<T>, values: T[]): Node<T> {\n    const root = this.root;\n    const prev = next.prev;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    for (let i = values.length - 1; i >= 0; --i) {\n      const curr = { next, value: values[i] } as Node<T>;\n      next.prev = curr;\n      next = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.prev.value);\n        root.prev = root.prev.prev;\n      }\n    }\n    next.prev = prev;\n    prev.next = next;\n    root.prev.next = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted.reverse());\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return next;\n  }\n\n  /**\n   * @internal\n   */\n  protected remove(node: Node<T>): void {\n    node.prev.next = node.next;\n    node.next.prev = node.prev;\n    --this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected tryIndex(index: number): number | undefined {\n    // Conver to number\n    index = +index;\n\n    // Check if an integer\n    const size = this._size;\n    if (!Number.isInteger(index) || index >= size || index < -size) {\n      return undefined;\n    }\n\n    // If negative, treat as index + size\n    return index < 0 ? index + size : index;\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Bounded } from \"../types/bounded\";\nimport { Deque } from \"../types/deque\";\n\nimport { CircularDoublyLinkedList } from \"./circularDoublyLinkedList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  first(): T | undefined {\n    return this.list.at(0);\n  }\n\n  front(): T | undefined {\n    return this.list.at(0);\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  unshift(...elems: T[]): number {\n    return this.list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { LinkedNode } from \"../types/linkedNode\";\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes, returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(root), a `TypeError` is thrown.\n *\n * @param root - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(root)`\n */\nexport function cut<T>(\n  root: LinkedNode<T>,\n  count: number\n): [LinkedNode<T>, LinkedNode<T>] | [undefined, undefined] {\n  if (count <= 0) {\n    return [undefined, undefined];\n  }\n  const head = root.next!;\n  const tail = get(head, count - 1)!;\n  root.next = tail.next;\n  tail.next = undefined;\n  return [head, tail];\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param head - The head node of the linked list to iterate over.\n */\nexport function* entries<T>(\n  head?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<[number, T]> {\n  for (let i = 0; head != end; ++i) {\n    yield [i, head!.value];\n    head = head!.next;\n  }\n}\n\n/**\n * Retrieves the node at the specified index in a linked list.\n *\n * This function iterates through the linked list starting from the `head`\n * node, moving forward `index` nodes in the sequence. The caller is\n * responsible for ensuring that the list contains a sufficient number\n * of nodes to prevent accessing `undefined` properties. `index` values that\n * exceed the list's length will result in a `TypeError`.\n *\n * @param head - The node from which to start.\n * @param index - The zero-based index of the node to retrieve.\n *\n * @returns The node at the specified index, or `undefined` if `index` equals `len(head)`.\n *\n * @throws - {@link TypeError}\n * thrown if `index` \\> `len(head)`\n */\nexport function get<T>(\n  head: LinkedNode<T> | undefined,\n  index: number\n): LinkedNode<T> | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n  for (let i = 0; i < index; ++i) {\n    head = head!.next;\n  }\n  return head;\n}\n\nexport function has<T>(\n  head: LinkedNode<T> | undefined,\n  value: T,\n  end?: LinkedNode<T>\n): boolean {\n  while (head != end) {\n    if (head!.value === value) {\n      return true;\n    }\n    head = head!.next;\n  }\n  return false;\n}\n\nexport function* keys<T>(\n  head?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<number> {\n  for (let i = 0; head != end; ++i) {\n    yield i;\n    head = head!.next;\n  }\n}\n\n/**\n * Calculates the length of the linked list.\n *\n * This function iterates through the linked list starting from the `head`\n * node, counting each node until it reaches the end of the list (i.e. the next\n * node is `null` or `undefined`).\n *\n * @param head - The node from which to start counting.\n *\n * @returns The number of nodes in the linked list.\n */\nexport function len<T>(head?: LinkedNode<T>, end?: LinkedNode<T>): number {\n  let count = 0;\n  while (head != end) {\n    head = head!.next;\n    ++count;\n  }\n  return count;\n}\n\nexport function toArray<T>(head?: LinkedNode<T>, end?: LinkedNode<T>): T[] {\n  const array: T[] = [];\n\n  while (head != end) {\n    array.push(head!.value);\n    head = head!.next;\n  }\n\n  return array;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(\n  values: Iterable<T>\n): [LinkedNode<T>, LinkedNode<T>, number] | [undefined, undefined, 0] {\n  const root = {} as LinkedNode<T>;\n\n  let count = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { value };\n    tail = tail.next;\n    ++count;\n  }\n\n  return root.next == null\n    ? [undefined, undefined, 0]\n    : [root.next, tail, count];\n}\n\nexport function* values<T>(\n  head?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<T> {\n  for (let i = 0; head != end; ++i) {\n    yield head!.value;\n    head = head!.next;\n  }\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { LinkedNode as Node } from \"../types/linkedNode\";\nimport { List } from \"../types/list\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport {\n  cut,\n  entries,\n  get,\n  has,\n  keys,\n  toArray,\n  toList,\n  values,\n} from \"../utils/linkedNode\";\nimport { clamp, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n  /**\n   * @internal\n   */\n  protected root!: Node<T>;\n  /**\n   * @internal\n   */\n  protected _size!: number;\n  /**\n   * @internal\n   */\n  protected tail!: Node<T>;\n\n  /**\n   * Creates a new queue with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    const [head, tail, size] = toList(capacity as Iterable<T>);\n    this.root.next = head;\n    this.tail = tail ?? this.root;\n    this._capacity = size;\n    this._size = size;\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      this._capacity = capacity;\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const [head] = cut(this.root, diff);\n    this._size -= diff;\n    if (this._size <= 0) {\n      this.tail = this.root;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Emit discarded items\n    this.emitter.emit(BoundedEvent.Overflow, toArray(head));\n  }\n\n  at(index: number): T | undefined {\n    const i = this.tryIndex(index);\n    return i == undefined ? undefined : get(this.root, i + 1)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this.root = { value: undefined } as Node<T>;\n    this.tail = this.root;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = this.tryIndex(index)!;\n    if (index == undefined) {\n      return false;\n    }\n\n    // Delete node\n    const prev = get(this.root, index)!;\n    prev.next = prev.next!.next;\n\n    // Update tail\n    if (index == --this._size) {\n      this.tail = prev;\n    }\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this.root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(end, -size, size);\n    end += end >= 0 ? 0 : size;\n\n    // Update values\n    for (let node = get(this.root, start + 1); start < end; ++start) {\n      node!.value = value;\n      node = node!.next;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this.root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this.root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this.root.next);\n  }\n\n  pop(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n    const value = this.tail.value;\n    this.tail = get(this.root, --this._size)!;\n    this.tail.next = undefined;\n    return value;\n  }\n\n  push(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.tail = this.append(this.tail, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    const i = this.tryIndex(index);\n    if (i == undefined) {\n      return undefined;\n    }\n\n    // Update node\n    const node = get(this.root, i + 1)!;\n    const prevValue = node.value;\n    node.value = value;\n\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n    const head = this.root.next!;\n    this.root.next = head.next;\n    if (--this._size <= 0) {\n      this.tail = this.root;\n    }\n    return head.value;\n  }\n\n  slice(start?: number, end?: number): CircularLinkedList<T> {\n    const out = new CircularLinkedList<T>();\n\n    // Check size\n    if (this._size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize end\n    end = toInteger(end, size);\n    end = clamp(end, -size, size);\n    end += end >= 0 ? 0 : size;\n\n    // Add values to output\n    for (let node = get(this.root, start)!; start < end; ++start) {\n      node = node.next!;\n      out.push(node.value);\n    }\n\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularLinkedList<T> {\n    const out = new CircularLinkedList<T>();\n    if (this._size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    const size = this._size;\n    start = toInteger(start, 0);\n    start = clamp(start, -size, size);\n    start += start >= 0 ? 0 : size;\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, size - start);\n\n    // Get prev node\n    let prev = get(this.root, start)!;\n\n    // Delete values\n    const [head, tail] = cut(prev, deleteCount);\n    this._size -= deleteCount;\n    out.root.next = head;\n    out.tail = tail ?? out.root;\n    out._size = deleteCount;\n\n    // Add values\n    prev = this.append(prev, items);\n\n    // Update tail\n    if (prev.next == null) {\n      this.tail = prev;\n    }\n\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this.root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    let N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: No capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Reduce input\n    const diff = N <= capacity ? 0 : N - capacity;\n    N -= diff;\n\n    // Case 3: Discard list overflow\n    if (this._size + N > capacity) {\n      this._size = capacity - N;\n      const prev = get(this.root, this._size)!;\n      this.emitter.emit(BoundedEvent.Overflow, toArray(prev.next));\n      prev.next = undefined;\n      this.tail = prev;\n    }\n\n    // Discard input overflow\n    if (diff > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, values.slice(N));\n      values.length = N;\n    }\n\n    // Add values\n    const [head, tail] = toList(values);\n    tail!.next = this.root.next;\n    this.root.next = head;\n    if (this._size <= 0) {\n      this.tail = tail!;\n    }\n    this._size += N;\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this.root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected append(tail: Node<T>, values: T[], minIndex = 0): Node<T> {\n    const root = this.root;\n    const next = tail.next;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = minIndex; i < N; ++i) {\n      const curr = { value: values[i] } as Node<T>;\n      tail.next = curr;\n      tail = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next!.value);\n        root.next = root.next!.next;\n      }\n    }\n    tail.next = next;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return tail;\n  }\n\n  /**\n   * @internal\n   */\n  protected tryIndex(index: number): number | undefined {\n    // Conver to number\n    index = +index;\n\n    // Check if an integer\n    const size = this._size;\n    if (!Number.isInteger(index) || index >= size || index < -size) {\n      return undefined;\n    }\n\n    // If negative, treat as index + size\n    return index < 0 ? index + size : index;\n  }\n}\n","import { Queue } from \"../types/queue\";\nimport { Bounded } from \"../types/bounded\";\n\nimport { CircularLinkedList } from \"./circularLinkedList\";\nimport { BoundedEvent } from \"..\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  first(): T | undefined {\n    return this.list.at(0);\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  front(): T | undefined {\n    return this.list.at(0);\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Stack } from \"../types/stack\";\nimport { Bounded } from \"../types/bounded\";\nimport { BoundedEvent, CircularDoublyLinkedList } from \"..\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this.list.at(-1);\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal map.\n   * @internal\n   */\n  protected map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.map = new Map(capacity as Iterable<[K, V]>);\n    this._capacity = this.map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the map.\n   */\n  get size(): number {\n    return this.map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.map);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this.map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this.map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this.map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this.map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this.map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this.map.delete(key) && this.size >= this.capacity) {\n      const entry = this.map.entries().next().value;\n      this.map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this.map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this.map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this.map.values();\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Queue<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   * @internal\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  /**\n   * @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularQueue.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size < 1) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  /**\n   * Remove all elements and resets the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Get the first element in the queue.\n   *\n   * Alias for {@link front | front()}.\n   *\n   * @returns the first element, or `undefined` if empty.\n   */\n  first(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Get the element at the front of the queue.\n   *\n   * Alias for {@link first | first()}.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  front(): T | undefined {\n    return this.vals[this.head];\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Inserts new elements at the end of the queue.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the queue.\n   */\n  push(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._push(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._push(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evict(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(0, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._push(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Removes the element at the front of the queue.\n   *\n   * @returns the front element, or `undefined` if empty.\n   */\n  shift(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    --this._size;\n    const value = this.vals[this.head];\n    this.vals[this.head] = undefined as T;\n    if (++this.head >= this._capacity) {\n      this.head = 0;\n      this.vals.length = this.next;\n    }\n    return value;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Emit an event containing the items evicted from the collection.\n   * @internal\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected emit(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes a given number of elements from the queue.\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   * @internal\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evict(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      this.emit(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if queue is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the queue is stored sequentially in memory.\n   * @internal\n   *\n   * @returns `true` if the queue is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param max - The number of elements to append.\n   */\n  protected _push(elems: T[], max: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let tail = this.next;\n    for (let i = 0; i < max; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    this.next = tail;\n    this._size += max;\n  }\n\n  /**\n   * Adjusts the queue to fit within the given capacity.\n   * @internal\n   *\n   * Assumes the queue is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the queue was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If queue fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If queue must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If queue must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    this.evict(this._size - capacity);\n\n    // Check if queue is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of queue: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The internal set.\n   * @internal\n   */\n  protected set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.set = new Set(capacity as Iterable<T>);\n    this._capacity = this.set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the set.\n   */\n  get size(): number {\n    return this.set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.set);\n      this.clear();\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this.set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this.set.delete(value);\n      evicted.push(value);\n    }\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this.emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this.set.delete(value) && this.size >= this.capacity) {\n      const out = this.set.values().next().value;\n      this.set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this.set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this.emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this.set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this.set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this.set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this.set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this.set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.set.values();\n  }\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Stack } from \"../types/stack\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Stack<T>\n{\n  /**\n   * The maximum number of elements that can be stored in the collection.\n   * @internal\n   */\n  protected _capacity: number;\n\n  /**\n   * The index representing the first element.\n   * @internal\n   */\n  protected head: number;\n\n  /**\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected isFinite: boolean;\n\n  /**\n   * The index one more than the last element.\n   * @internal\n   */\n  protected next: number;\n\n  /**\n   * The number of elements.\n   * @internal\n   */\n  protected _size: number;\n\n  /**\n   * The stored values.\n   * @internal\n   */\n  protected vals: T[];\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this.head = 0;\n    this.isFinite = false;\n    this._size = 0;\n    this.next = 0;\n    this.vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this.isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    for (const value of capacity as Iterable<T>) {\n      this.vals.push(value);\n    }\n    this._capacity = this.vals.length;\n    this.isFinite = true;\n    this._size = this._capacity;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this.isFinite ? this._capacity : Infinity;\n  }\n\n  /**\n   * @returns the number of elements in the collection.\n   */\n  get size(): number {\n    return this._size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularStack.name;\n  }\n\n  /**\n   * Sets the maximum number of elements that can be stored.\n   */\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this.isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this.isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size < 1) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  /**\n   * Remove all elements from the collection.\n   */\n  clear(): void {\n    this.head = 0;\n    this._size = 0;\n    this.next = 0;\n    this.vals.length = 0;\n  }\n\n  /**\n   * Iterate through the collection's entries.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this.vals[(this.head + ext) % this._capacity]];\n    }\n  }\n\n  /**\n   * Performs the specified action for each element in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per element.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. If omitted, `undefined` is used.\n   */\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this.vals[(this.head + ext) % this._capacity];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  /**\n   * Determines whether a given element is in the collection.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @param value - The element to search for\n   *\n   * @returns a boolean indicating if `value` was found or not\n   */\n  has(value: T): boolean {\n    const N = this._size;\n    for (let ext = 0; ext < N; ++ext) {\n      if (value === this.vals[(this.head + ext) % this._capacity]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Iterate through the collection's keys.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of keys.\n   */\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  /**\n   * Get the last element in the stack.\n   *\n   * Alias for {@link top | top()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  last(): T | undefined {\n    return this.top();\n  }\n\n  /**\n   * Removes the element at the top of the stack.\n   *\n   * @returns the top element, or `undefined` if empty.\n   */\n  pop(): T | undefined {\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    const tail = this.next > 0 ? this.next - 1 : this.head + this._size - 1;\n\n    --this._size;\n    this.next = tail;\n    const value = this.vals[tail];\n    this.vals[tail] = undefined as T;\n    return value;\n  }\n\n  /**\n   * Inserts new elements at the end of the stack.\n   *\n   * @param elems - Elements to insert.\n   *\n   * @returns The new size of the stack.\n   */\n  push(...elems: T[]): number {\n    // Case 1: Zero inputs\n    const N = elems.length;\n    if (N < 1) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity < 1) {\n      this.emit(elems);\n      return this._size;\n    }\n\n    // Case 3: Enough free space\n    const free = capacity - this._size;\n    if (free >= N) {\n      this._push(elems, N);\n      return this._size;\n    }\n\n    // Case 4: \"Infinite\" capacity but out of space\n    if (!this.isFinite) {\n      this._push(elems, free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove old values\n    const diff = N - capacity;\n    this.evict(this.size + diff);\n    if (diff > 0) {\n      this.emit(elems.splice(0, diff));\n    }\n\n    // Add new values\n    else if (diff < 0) {\n      this._push(elems, N);\n      return this._size;\n    }\n    this.vals = elems;\n    this._size = capacity;\n    return this._size;\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  /**\n   * Get the last element in the stack.\n   *\n   * Alias for {@link last | last()}.\n   *\n   * @returns the last element, or `undefined` if empty.\n   */\n  top(): T | undefined {\n    if (this._size < 1) {\n      return undefined;\n    }\n    return this.vals[(this.head + this._size - 1) % this._capacity];\n  }\n\n  /**\n   * Iterate through the collection's values.\n   *\n   * **NOTE:** Unknown behavior may occur if the collection is modified during use.\n   *\n   * @returns an iterable of values.\n   */\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this.vals[(this.head + ext) % this._capacity];\n    }\n  }\n\n  /**\n   * Emit an event containing the items evicted from the collection.\n   * @internal\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected emit(evicted: T[]): void {\n    this.emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes a given number of elements from the stack.\n   * @internal\n   *\n   * If elements are removed, the {@link BoundedEvent.Overflow} event\n   * is emitted one or more times.\n   *\n   * @param count - The number of elements to evict.\n   */\n  protected evict(count: number): void {\n    if (count <= 0) {\n      return;\n    }\n\n    const len = this._capacity - this.head;\n    const isNonsequential = !this.isSequential();\n\n    if (isNonsequential && len > count) {\n      this.emit(this.vals.slice(this.head, this.head + count));\n      this.vals.fill(undefined as T, this.head, this.head + count);\n      this.head += count;\n      this._size -= count;\n      return;\n    }\n\n    if (isNonsequential) {\n      this.emit(this.vals.slice(this.head, this.head + len));\n      this.vals.length = this.next;\n      this.head = 0;\n      this._size -= len;\n      if (count <= len) {\n        return;\n      }\n      count -= len;\n    }\n\n    if (count >= this._size) {\n      this.emit(this.vals.slice(this.head, this.head + this._size));\n      this.clear();\n      return;\n    }\n\n    this.emit(this.vals.slice(this.head, this.head + count));\n    this.vals.fill(undefined as T, this.head, this.head + count);\n    this.head += count;\n    this._size -= count;\n  }\n\n  /**\n   * Grow capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if stack is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // stack is not sequential: [456T    H123]\n\n    if (this._size <= this.head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this.next;\n      this.vals.copyWithin(temp, 0, this.next);\n      this.vals.copyWithin(0, this.head, this.head + temp);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size;\n    } else if (this.head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this.vals.length = this.head + this._size;\n      this.vals.copyWithin(this._capacity, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.next = (this.head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this._capacity, 0, diff);\n      this.vals.copyWithin(0, diff, this.next);\n      const temp = Math.max(diff, this.next - diff);\n      this.vals.fill(undefined as T, temp, this.next);\n      this.next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * Returns whether the stack is stored sequentially in memory.\n   * @internal\n   *\n   * @returns `true` if the stack is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this.head < this.next || this.next < 1;\n  }\n\n  /**\n   * Append new elements to the collection.\n   * @internal\n   *\n   * @param elems - The elements to append.\n   * @param max - The number of elements to append.\n   */\n  protected _push(elems: T[], max: number): void {\n    const capacity = this._capacity;\n    const vals = this.vals;\n\n    let tail = this.next;\n    for (let i = 0; i < max; ++i) {\n      vals[tail] = elems[i];\n      if (++tail >= capacity) {\n        tail = 0;\n      }\n    }\n\n    this.next = tail;\n    this._size += max;\n  }\n\n  /**\n   * Adjusts the stack to fit within the given capacity.\n   * @internal\n   *\n   * Assumes the stack is A) sequential in memory and B) size \\<= capacity.\n   *\n   * @param capacity - the new capacity.\n   *\n   * @returns `true` if the stack was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this.head + this._size;\n\n    // If stack fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this.vals.length = tail;\n      this.next = this.vals.length % capacity;\n\n      // If stack must be fully moved: [H------T    ]\n    } else if (this.head >= capacity) {\n      this.vals.copyWithin(0, this.head, tail);\n      this.vals.length = this._size;\n      this.head = 0;\n      this.next = this._size % capacity;\n\n      // If stack must be partially moved: [--T  H----]\n    } else {\n      this.vals.copyWithin(0, capacity, tail);\n      this.vals.length = capacity;\n      this.next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * Shrink capacity.\n   * @internal\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    this.evict(this._size - capacity);\n\n    // Check if stack is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of stack: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this.vals.copyWithin(this.head - diff, this.head, this._capacity);\n    this.vals.length = capacity;\n    this.head -= diff;\n    this._capacity = capacity;\n  }\n}\n"],"names":["BoundedEvent","EventEmitter","CircularBase","emitter","__publicField","event","listener","ARRAY_MAX_LENGTH","isArrayLength","value","isInfinity","isNumber","isSafeCount","CircularDeque","capacity","ext","callbackfn","thisArg","N","tail","elems","free","diff","evicted","count","len","isNonsequential","temp","max","vals","i","num","head","min","clamp","toInteger","defaultValue","CircularDoublyLinkedList","items","index","node","start","end","size","values","prevValue","out","prev","deleteCount","itemCount","replaceCount","minIndex","root","next","curr","half","steps","CircularLinkedDeque","v","cut","get","entries","has","keys","toArray","array","toList","CircularLinkedList","CircularLinkedQueue","CircularLinkedStack","CircularMap","iter","n","entry","key","CircularQueue","CircularSet","CircularStack"],"mappings":"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"}