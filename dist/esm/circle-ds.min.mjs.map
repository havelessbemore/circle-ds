{"version":3,"file":"circle-ds.min.mjs","sources":["../../src/types/boundedEvent.ts","../../__vite-browser-external","../../src/circle/circularBase.ts","../../src/utils/constants.ts","../../src/utils/is.ts","../../src/utils/math.ts","../../src/circle/circularArrayList.ts","../../src/circle/circularDeque.ts","../../src/utils/linkedNode.ts","../../src/utils/doublyLinkedNode.ts","../../src/circle/circularDoublyLinkedList.ts","../../src/circle/circularLinkedDeque.ts","../../src/circle/circularLinkedList.ts","../../src/circle/circularLinkedQueue.ts","../../src/circle/circularLinkedStack.ts","../../src/circle/circularMap.ts","../../src/circle/circularQueue.ts","../../src/circle/circularSet.ts","../../src/utils/iterable.ts","../../src/utils/skipNode.ts","../../src/utils/skipStack.ts","../../src/circle/circularSkipList.ts","../../src/circle/circularStack.ts"],"sourcesContent":["/**\n * An enumeration of event types supported by {@link Bounded} collections.\n *\n * This object defines a set of constants representing event names that can\n * be emitted by instances of collections implementing the {@link Bounded} interface.\n * These events signify specific actions or changes in the state of the collection.\n *\n * Defined events include:\n * - `Overflow`: Indicates that the collection has reached its capacity, and\n *   as a result, one or more elements have been removed to accommodate new elements.\n *   This event is triggered during operations that add elements to the collection when\n *   it exceeds its capacity, or when capacity is updated below the collection's current\n *   size. Listeners attached to this event will receive an array of elements that were\n *   removed due to the overflow. Removed elements may be sent across 1 or more event\n *   instances.\n *\n * This object is marked as `const` to ensure that its properties are read-only,\n * preventing modification of event names which could lead to inconsistencies in\n * event handling across the application.\n */\nexport const BoundedEvent = {\n  Overflow: \"overflow\",\n} as const;\n","export default {}","import EventEmitter from \"events\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { ValueOf } from \"../types/valueOf\";\n\nexport class CircularBase<T> {\n  /**\n   * The event emitter.\n   * @internal\n   */\n  protected _emitter: EventEmitter;\n\n  constructor(emitter = new EventEmitter()) {\n    this._emitter = emitter;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  addListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.addListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Appends the listener function to the listeners array for the\n   * {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * By default, event listeners are invoked in the order they are added.\n   * The `prependListener()` method can be used as an alternative to add\n   * the event listener to the beginning of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  on(event: typeof BoundedEvent.Overflow, listener: (elems: T[]) => void): this;\n  on(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.on(event, listener);\n    return this;\n  }\n\n  /**\n   * Adds the listener function to the beginning of the listeners array for\n   * the {@link BoundedEvent.Overflow} event.\n   *\n   * * No checks are made to see if the listener has already been added.\n   * Multiple calls with the same of event + listener combination will\n   * result in the listener being added and called multiple times.\n   *\n   * * Alternatively, the `addListener()` method can be used to add\n   * the event listener to the end of the listeners array.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function. It will\n   * receive an array of elements that have been removed due to overflow.\n   * This can happen when elements are added while the collection is at\n   * capacity, or when capacity is reduced below the current size.\n   *\n   * @returns the collection.\n   */\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  prependListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.prependListener(event, listener);\n    return this;\n  }\n\n  /**\n   * Removes the specified listener from the listener array for the event.\n   *\n   * At most once instance of a listener will be removed. If a listener\n   * has been added multiple times for the same event, this method should\n   * be called once per instance.\n   *\n   * @param event - The name of the event.\n   * @param listener - The callback function.\n   *\n   * @returns the collection.\n   */\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this;\n  removeListener(\n    event: ValueOf<typeof BoundedEvent>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    listener: (...args: any[]) => void\n  ): this {\n    this._emitter.removeListener(event, listener);\n    return this;\n  }\n}\n","/**\n * The maximum number of arguments that can be passed to a function.\n *\n * While ECMAScript specifications do not explicitly limit the number of\n * function arguments, practical limits are imposed by JavaScript engine\n * implementations. Different engines can have different maximums, so a\n * conservative value is used to prevent runtime errors.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-list-and-record-specification-type | ECMAScript Specification},\n * section \"6.2.2 The List and Record Specification Types\".\n */\nexport const ARGS_MAX_LENGTH = 16383; // 2**14 - 1\n\n/**\n * The maximum length of an array.\n *\n * According to the ECMAScript specification, the length property of an array\n * is an unsigned 32-bit integer, so its range is 0 to 2**32 - 1, inclusive.\n * Beyond this, operations that modify the array length (e.g., `push`, `pop`,\n * `unshift`, `shift`) may fail or behave unexpectedly.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-arraycreate | ECMAScript Specification},\n * section \"10.4.2.2 ArrayCreate\".\n */\nexport const ARRAY_MAX_LENGTH = 4294967295; // 2**32 - 1\n\n/**\n * The maximum safe length for a linked structure.\n *\n * This constant is defined as the largest integer value that can be safely\n * represented in JavaScript (`Number.MAX_SAFE_INTEGER`), preventing integer\n * precision loss in length-related operations. Operations with values beyond\n * this number may not behave as expected due to limitations in JavaScript's\n * number representation.\n *\n * For more details, see the\n * {@link https://262.ecma-international.org/14.0/#sec-number.max_safe_integer | ECMAScript Specification},\n * section \"21.1.2.6 Number.MAX_SAFE_INTEGER\".\n */\nexport const LINKED_MAX_LENGTH = Number.MAX_SAFE_INTEGER; // 2**53 - 1\n","import { ARRAY_MAX_LENGTH, LINKED_MAX_LENGTH } from \"./constants\";\n\n/**\n * Checks if a given value is an integer within a valid array length range.\n *\n * This function is useful for validating array lengths before attempting operations\n * that could result in a `RangeError` due to invalid array size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, ARRAY_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isArrayLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= ARRAY_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a function.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a function, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport function isFunction(value: unknown): value is Function {\n  return typeof value === \"function\";\n}\n\n/**\n * Checks if a given value is positive infinity.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is positive infinity, `false` otherwise.\n */\nexport function isInfinity(value: unknown): boolean {\n  return value === Number.POSITIVE_INFINITY;\n}\n\n/**\n * Determines whether the provided value is iterable.\n *\n * This is useful for determining if a value can be used\n * in a `for...of` loop or with spread syntax.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value implements the iterable protocol, `false` otherwise.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isIterable(value: any): value is Iterable<unknown> {\n  return typeof value?.[Symbol.iterator] === \"function\";\n}\n\n/**\n * Checks if a given value is an integer within a valid linked length range.\n *\n * This function is useful for validating linked lengths before attempting operations\n * that could result in a `RangeError` due to invalid linked list size.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is an integer within the `[0, LINKED_MAX_LENGTH]` range, `false` otherwise.\n */\nexport function isLinkedLength(value: unknown): value is number {\n  return (\n    Number.isInteger(value) &&\n    (value as number) >= 0 &&\n    (value as number) <= LINKED_MAX_LENGTH\n  );\n}\n\n/**\n * Determines whether the provided value is a number.\n *\n * This includes `NaN` and `Infinity`, so consider additional\n * checks if those values are not desirable.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is of type number, `false` otherwise.\n */\nexport function isNumber(value: unknown): value is number {\n  return typeof value === \"number\";\n}\n\n/**\n * Checks if a given value is a safe integer greater than or equal to 0.\n *\n * This is useful for validating counts or sizes that must be within the safe\n * integer range to prevent precision loss.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a safe integer and non-negative, `false` otherwise.\n */\nexport function isSafeCount(value: unknown): value is number {\n  return Number.isSafeInteger(value) && (value as number) >= 0;\n}\n\n/**\n * Determines whether the provided value is a symbol.\n *\n * @param value - The value to check.\n *\n * @returns `true` if the value is a symbol, `false` otherwise.\n */\nexport function isSymbol(value: unknown): value is symbol {\n  return typeof value === \"symbol\";\n}\n","/**\n * Adds a specified addend to a value if the value is below a given target.\n *\n * @param value - The initial number.\n * @param addend - The number added if the value is below the target.\n * @param target - The target number for comparison. If the value is below this\n * number, the addend will be added. Defaults to 0 if not specified.\n */\nexport function addIfBelow(value: number, addend: number, target = 0): number {\n  return value >= target ? value : value + addend;\n}\n\n/**\n * Restricts a given numerical value within a specified range [min, max].\n *\n * If the provided value is less than the minimum, the minimum is returned.\n * If it is greater than the maximum, the maximum is returned. If the value\n * is within the range, the value itself is returned. An error is thrown if\n * the minimum range value is greater than the maximum range value, as this\n * represents an invalid range.\n *\n * @param value - The numerical value to clamp.\n * @param min - The minimum allowable value of the range.\n * @param max - The maximum allowable value of the range.\n *\n * @returns The clamped value within the specified range.\n *\n * @throws `RangeError` If `min` is greater than `max`.\n */\nexport function clamp(value: number, min: number, max: number): number {\n  if (min > max) {\n    throw new RangeError(\"Invalid clamp range; min must be <= max\");\n  }\n  if (value <= min) {\n    return min;\n  }\n  return value <= max ? value : max;\n}\n\n/**\n * Checks if a given numeric value falls within a specified range.\n *\n * @param value - The numeric value to check.\n * @param min - The inclusive lower bound of the range.\n * @param max - The exclusive upper bound of the range.\n *\n * @returns - `true` if `value` is within the range `[min, max)`, `false` otherwise.\n */\nexport function isInRange(value: number, min: number, max: number): boolean {\n  return value >= min && value < max;\n}\n\n/**\n * Calculates the logarithm of a given value with the specified base.\n *\n * This function uses natural logarithms (`Math.log`) for its calculations.\n * If either the value or the base is less than or equal to 0, `NaN` is returned\n * to indicate an invalid operation, as logarithms are not defined for non-positive\n * values and bases.\n *\n * @param value - The numerical value for which to calculate the logarithm. Must be positive.\n * @param base - The base of the logarithm. Must be positive.\n *\n * @returns The calculated logarithm of the value with the given base, or `NaN` for invalid inputs.\n */\nexport function log(value: number, base: number): number {\n  return value >= 0 && base > 0 ? Math.log(value) / Math.log(base) : NaN;\n}\n\n/**\n * Generates a number representing the length of a consecutive run based on a\n * probability threshold.\n *\n * This function iteratively increments a counter as long as the randomly\n * generated numbers from `randomFn` are less than the specified probability\n * threshold `p`, or until the counter reaches the maximum `max`.\n *\n * The function is useful for simulations or models that require a random yet\n * probabilistically constrained sequence length, such as simulating streaks or\n * runs in games of chance.\n *\n * @param probability - The probability threshold. Defaults to 0.5.\n * @param max - The maximum value the of the run. Defaults to Infinity.\n * @param min - The starting value of the run. Defaults to 0.\n * @param randomFn - A function that generates a random number. Defaults to `Math.random`.\n *\n * @returns The length of the run.\n */\nexport function randomRun(\n  probability = 0.5,\n  min = 0,\n  max = Infinity,\n  randomFn = Math.random\n): number {\n  while (min < max && randomFn() < probability) {\n    ++min;\n  }\n  return min;\n}\n\n/**\n * Attempts to convert a given value to an integer.\n *\n * The function first tries to convert the value to a number. If the result\n * is not valid (i.e. `NaN`), the given `defaultValue` is returned. Otherwise,\n * the function truncates the number to an integer using `Math.trunc`.\n *\n * This is useful for ensuring numerical operations are performed on integers,\n * with a controllable fallback for invalid inputs.\n *\n * @param value - The value to convert to an integer. This can be of any type.\n * @param defaultValue - The fallback value to return if conversion fails. Defaults to 0.\n *\n * @returns The converted integer, or `defaultValue` if conversion is not possible.\n */\nexport function toInteger(value?: unknown, defaultValue = 0): number {\n  value = +value!;\n  return isNaN(value as number) ? defaultValue : Math.trunc(value as number);\n}\n","import { CircularBase } from \"./circularBase\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { isArrayLength, isInfinity, isNumber } from \"../utils/is\";\nimport { Bounded } from \"../types/bounded\";\nimport { ARRAY_MAX_LENGTH } from \"../utils/constants\";\nimport { List } from \"../types/list\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../utils/math\";\n\nexport class CircularArrayList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The index representing the first element.\n   */\n  protected _head: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The index one more than the last element.\n   */\n  protected _next: number;\n\n  /**\n   * @internal\n   * The number of elements.\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The stored values.\n   */\n  protected _vals: T[];\n\n  /**\n   * Creates a new list. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new list from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = ARRAY_MAX_LENGTH;\n    this._head = 0;\n    this._isFinite = false;\n    this._size = 0;\n    this._next = 0;\n    this._vals = [];\n\n    // If capacity is null, undefined, or Infinity\n    if (capacity == null || isInfinity(capacity)) {\n      return;\n    }\n\n    // If capacity is a number\n    if (isNumber(capacity)) {\n      // If capacity is invalid\n      if (!isArrayLength(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      // If capacity is valid\n      this._capacity = capacity;\n      this._isFinite = true;\n      return;\n    }\n\n    // If capacity is an iterable\n    this._vals = Array.from(capacity as Iterable<T>);\n    this._capacity = this._vals.length;\n    this._isFinite = true;\n    this._size = this._capacity;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularArrayList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert capacity to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = ARRAY_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isArrayLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update collection\n    if (this._size <= 0) {\n      // If collection is empty\n      this._capacity = capacity;\n      this.clear();\n    } else if (capacity < this._capacity) {\n      // If capacity is decreasing\n      this.shrink(capacity);\n    } else if (capacity > this._capacity) {\n      // If capacity is increasing\n      this.grow(capacity);\n    }\n  }\n\n  at(index?: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this._vals[this.toIndex(index)];\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._head = 0;\n    this._next = 0;\n    this._vals.length = 0;\n  }\n\n  /*\n  copyWithin(target: number, start: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    target = clamp(addIfBelow(toInteger(target, 0), size), 0, size);\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    const temp = target > start ? target - start : 0;\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size - temp);\n\n    // Copy within\n    this._copyWithin(target, start, end);\n\n    // Return list\n    return this;\n  }\n  */\n\n  /**\n   * @internal\n   */\n  protected _copyWithin(target: number, start: number, end: number): void {\n    // If copying in-place or nothing to copy\n    if (target == start || start >= end) {\n      return;\n    }\n\n    // Get source data segments\n    const capacity = this._capacity - 1;\n    const vals = this._vals;\n    const ranges = this.toRanges(start, end);\n\n    if (target <= start || end <= target) {\n      // Copy from left to right\n      target = this.toIndex(target);\n      for (const [min, max] of ranges) {\n        for (let i = min; i < max; ++i) {\n          vals[target] = vals[i];\n          target = target < capacity ? target + 1 : 0;\n        }\n      }\n    } else {\n      // Copy from right to left\n      target = this.toIndex(target + (end - start));\n      for (const [min, max] of ranges.reverse()) {\n        for (let i = max - 1; i >= min; --i) {\n          target = target > 0 ? target - 1 : capacity;\n          vals[target] = vals[i];\n        }\n      }\n    }\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._delete(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  /**\n   * @internal\n   */\n  protected _delete(index: number, deleteCount: number): void {\n    this._copyWithin(index, index + deleteCount, this._size);\n    this._pop(deleteCount);\n  }\n\n  *entries(): IterableIterator<[number, T]> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield [ext, this._vals[this.toIndex(ext)]];\n    }\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Fill values\n    this._fill(value, start, end);\n\n    // Return list\n    return this;\n  }\n\n  /**\n   * @internal\n   */\n  protected _fill(value: T, start: number, end: number): void {\n    for (const [min, max] of this.toRanges(start, end)) {\n      this._vals.fill(value, min, max);\n    }\n  }\n\n  first(): T | undefined {\n    return this._size > 0 ? this._vals[this._head] : undefined;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    const N = this._size;\n    for (let ext = 0; ext < N && ext < this._size; ++ext) {\n      const value = this._vals[this.toIndex(ext)];\n      callbackfn.call(thisArg, value, ext, this);\n    }\n  }\n\n  has(value: T): boolean {\n    const vals = this._vals;\n    for (const [min, max] of this.toRanges(0, this._size)) {\n      for (let i = min; i < max; ++i) {\n        if (value === vals[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  *keys(): IterableIterator<number> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield ext;\n    }\n  }\n\n  last(): T | undefined {\n    return this._size > 0\n      ? this._vals[this.toIndex(this._size - 1)]\n      : undefined;\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get and remove first value\n    const value = this._vals[this.toIndex(this._size - 1)];\n    this._pop(1);\n\n    // Return value\n    return value;\n  }\n\n  /**\n   * @internal\n   */\n  protected _pop(N: number): void {\n    // Remove values\n    const newSize = this._size - N;\n    this._fill(undefined as T, newSize, this._size);\n\n    // Update state\n    this._next = this.toIndex(newSize);\n    this._size = newSize;\n  }\n\n  push(...items: T[]): number {\n    // If no items\n    if (items.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(items);\n      return this._size;\n    }\n\n    // Push items\n    this._insert(this._size, items);\n\n    // Return new size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update value\n    index = this.toIndex(index);\n    const prevValue = this._vals[index];\n    this._vals[index] = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Get and remove first value\n    const value = this._vals[this._head];\n    this._shift(1);\n\n    // Return value\n    return value;\n  }\n\n  /**\n   * @internal\n   */\n  protected _shift(N: number): void {\n    // Remove items\n    this._fill(undefined as T, 0, N);\n\n    // Update state\n    this._head = this.toIndex(N);\n    this._size -= N;\n  }\n\n  slice(start?: number, end?: number): CircularArrayList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Return slice\n    return this.toList(this._slice(start, end));\n  }\n\n  /**\n   * @internal\n   */\n  protected _slice(start: number, end: number): T[] {\n    const from = this._vals;\n    const to = new Array<T>(end - start);\n\n    let j = 0;\n    for ([start, end] of this.toRanges(start, end)) {\n      for (let i = start; i < end; ++i) {\n        to[j++] = from[i];\n      }\n    }\n\n    return to;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularArrayList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Create output\n    const out = this.toList(this._slice(start, start + deleteCount));\n\n    // Update list\n    this._splice(start, deleteCount, items);\n\n    // Return output\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected _splice(start: number, deleteCount: number, items: T[] = []): void {\n    const addCount = items.length;\n    const replaceCount = Math.min(deleteCount, addCount);\n    const vals = this._vals;\n\n    // Replace values\n    let j = 0;\n    for (const [a, b] of this.toRanges(start, start + replaceCount)) {\n      for (let i = a; i < b; ++i) {\n        vals[i] = items[j++];\n      }\n    }\n\n    // If done\n    if (deleteCount == addCount) {\n      return;\n    }\n\n    // Insert remaining values or finish deletions\n    start += replaceCount;\n    deleteCount < addCount\n      ? this._insert(start, items, replaceCount)\n      : this._delete(start, deleteCount - addCount);\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(\n    start: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(start, items, min, min + free);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (start > 0) {\n      const shifted = Math.min(start, N - free);\n      this._overflow(this._slice(0, shifted));\n      this._shift(shifted);\n      start -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(start, items, min, max);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = max - free;\n    this._overflow(items.slice(min, mid));\n    this._safePresert(0, items, mid, max);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(\n    vIndex: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n    const vals = this._vals;\n\n    // Make space\n    this._copyWithin(vIndex + N, vIndex, this._size);\n\n    // Insert into space\n    for (const [start, end] of this.toRanges(vIndex, vIndex + N)) {\n      for (let i = start; i < end; ++i) {\n        vals[i] = items[min++];\n      }\n    }\n\n    // Update state\n    this._size += N;\n    this._next = this.toIndex(this._size);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...items: T[]): number {\n    // If no items\n    if (items.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(items);\n      return this._size;\n    }\n\n    // Presert items\n    this._presert(0, items);\n\n    // Return new size\n    return this._size;\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(\n    end: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const N = max - min;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safePresert(end, items, min, max);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safePresert(end, items, max - free, max);\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (end < this._size) {\n      const popped = Math.min(this._size - end, N - free);\n      this._overflow(this._slice(this._size - popped, this._size));\n      this._pop(popped);\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safePresert(end, items, min, max);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = min + free;\n    this._overflow(items.slice(mid, max));\n    this._safeInsert(this._size, items, min, mid);\n  }\n\n  /**\n   * @internal\n   */\n  protected _safePresert(\n    vIndex: number,\n    items: T[],\n    min = 0,\n    max = items.length\n  ): void {\n    const capacity = this._capacity;\n    const N = max - min;\n    const vals = this._vals;\n\n    // Make space\n    const newHead = capacity - N;\n    this._copyWithin(newHead, 0, vIndex);\n\n    // Insert into space\n    vIndex += newHead;\n    for (const [start, end] of this.toRanges(vIndex, vIndex + N)) {\n      for (let i = start; i < end; ++i) {\n        vals[i] = items[min++];\n      }\n    }\n\n    // Update state\n    this._size += N;\n    this._head = this.toIndex(newHead);\n  }\n\n  *values(): IterableIterator<T> {\n    for (let ext = 0; ext < this._size; ++ext) {\n      yield this._vals[this.toIndex(ext)];\n    }\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: T[]): void {\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * @internal\n   *\n   * Grow capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected grow(capacity: number): void {\n    // Check if list is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Queue is not sequential: [456T    H123]\n    if (this._size <= this._head) {\n      // [H123456T] = A + B = N\n      const temp = this._size - this._next;\n      this._vals.copyWithin(temp, 0, this._next);\n      this._vals.copyWithin(0, this._head, this._head + temp);\n      this._vals.length = this._size;\n      this._head = 0;\n      this._next = this._size;\n    } else if (this._head + this._size <= capacity) {\n      // [        H123456T] = 2B < 2N\n      this._vals.length = this._head + this._size;\n      this._vals.copyWithin(this._capacity, 0, this._next);\n      this._vals.fill(undefined as T, 0, this._next);\n      this._next = (this._head + this._size) % capacity;\n    } /* else if (this.next + this._size <= capacity) {\n      // [    H123456T] = A + 2B = N + B < 2N\n      const temp = this._capacity - this.head;\n      this.vals.length = capacity;\n      this.vals.copyWithin(this.next, this.head, this._capacity);\n      this.vals.copyWithin(this.next + temp, 0, this.next);\n      this.vals.fill(undefined as T, 0, this.next);\n      this.vals.length = this.next + this._size;\n      this.head = this.next;\n      this.next = (this.head + this._size) % capacity;\n    } */ else {\n      // [6T      H12345] = B + D < 2B < 2N\n      const diff = capacity - this._capacity;\n      this._vals.length = capacity;\n      this._vals.copyWithin(this._capacity, 0, diff);\n      this._vals.copyWithin(0, diff, this._next);\n      const temp = Math.max(diff, this._next - diff);\n      this._vals.fill(undefined as T, temp, this._next);\n      this._next -= diff;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   *\n   * Returns whether the list is stored sequentially in memory.\n   *\n   * @returns `true` if the list is sequential in memory, `false` otherwise.\n   */\n  protected isSequential(): boolean {\n    return this._head < this._next || this._next <= 0;\n  }\n\n  /**\n   * @internal\n   *\n   * Adjusts the list to fit within the given capacity.\n   *\n   * Assumes the list:\n   * - is sequential in memory.\n   * - fits in the given capacity (size \\<= capacity).\n   *\n   * @param capacity - The new capacity.\n   *\n   * @returns `true` if the list was reset, `false` otherwise.\n   */\n  protected sequentialReset(capacity: number): boolean {\n    const tail = this._head + this._size;\n\n    // If list fits in current location: [    H------T    ]\n    if (tail <= capacity) {\n      this._vals.length = tail;\n      this._next = this._vals.length % capacity;\n\n      // If list must be fully moved: [H------T    ]\n    } else if (this._head >= capacity) {\n      this._vals.copyWithin(0, this._head, tail);\n      this._vals.length = this._size;\n      this._head = 0;\n      this._next = this._size % capacity;\n\n      // If list must be partially moved: [--T  H----]\n    } else {\n      this._vals.copyWithin(0, capacity, tail);\n      this._vals.length = capacity;\n      this._next = tail - capacity;\n    }\n\n    this._capacity = capacity;\n    return true;\n  }\n\n  /**\n   * @internal\n   *\n   * Shrink capacity.\n   *\n   * @param capacity - the new capacity\n   */\n  protected shrink(capacity: number): void {\n    // Handle overflow\n    if (this._size > capacity) {\n      const shifted = this._size - capacity;\n      this._overflow(this._slice(0, shifted));\n      this._shift(shifted);\n    }\n\n    // Check if list is sequential: [    H123456T    ]\n    if (this.isSequential()) {\n      this.sequentialReset(capacity);\n      return;\n    }\n\n    // Shift 1st half of list: [456T....H123] -> [456T..H123]\n    const diff = this._capacity - capacity;\n    this._vals.copyWithin(this._head - diff, this._head, this._capacity);\n    this._vals.length = capacity;\n    this._head -= diff;\n    this._capacity = capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected toIndex(externalIndex: number): number {\n    return (this._head + externalIndex) % this._capacity;\n  }\n\n  /**\n   * @internal\n   */\n  protected toList(items: T[]): CircularArrayList<T> {\n    const out = new CircularArrayList<T>(0);\n    out._vals = items;\n    out._size = items.length;\n    out._capacity = items.length;\n    return out;\n  }\n\n  /**\n   * @internal\n   */\n  protected toRanges(min: number, max: number): [number, number][] {\n    const head = this._head;\n    const mid = this._capacity - head;\n    if (max <= mid) {\n      return [[head + min, head + max]];\n    }\n    if (min >= mid) {\n      return [[min - mid, max - mid]];\n    }\n    return [\n      [head + min, this._capacity],\n      [0, max - mid],\n    ];\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Bounded } from \"../types/bounded\";\nimport { Deque } from \"..\";\nimport { CircularArrayList } from \"./circularArrayList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularArrayList<T>;\n\n  /**\n   * Creates a new deque. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new deque with the given capacity.\n   *\n   * @param capacity - the deque's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new deque from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the deque.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this._list.first();\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.last();\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  top(): T | undefined {\n    return this._list.last();\n  }\n\n  unshift(...elems: T[]): number {\n    return this._list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { LinkedNode } from \"../types/linkedNode\";\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<N extends LinkedNode<unknown>>(\n  prev: N,\n  count: number\n): [N, N] | [undefined, undefined] {\n  if (count <= 0) {\n    return [undefined, undefined];\n  }\n  const head = prev.next!;\n  const tail = get(head, count - 1)!;\n  prev.next = tail.next;\n  tail.next = undefined;\n  return [head, tail];\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* entries<T>(\n  node?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<[number, T]> {\n  for (let i = 0; node != end; ++i) {\n    yield [i, node!.value];\n    node = node!.next;\n  }\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends LinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index < 0) {\n    return undefined;\n  }\n  for (let i = 0; node != null && i < index; ++i) {\n    node = node.next;\n  }\n  return node;\n}\n\n/**\n * Determines whether a linked list contains a node with a specified value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * @param node - The node from which to start searching.\n * @param value - The value to search for.\n * @param end - An optional node at which to end the search (exclusive).\n * If not provided, the search continues until the end of the list.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n *\n */\nexport function has<T>(\n  node: LinkedNode<T> | undefined,\n  value: T,\n  end?: LinkedNode<T>\n): boolean {\n  while (node != end) {\n    if (node!.value === value) {\n      return true;\n    }\n    node = node!.next;\n  }\n  return false;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: LinkedNode<T>,\n  values: Iterable<T>\n): LinkedNode<T> {\n  // Convert values to list\n  const [head, tail, size] = toList(values);\n\n  // If no values\n  if (size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  tail!.next = prev.next;\n  prev.next = head;\n\n  return tail!;\n}\n\n/**\n * Iterates through a linked list, yielding each node's index\n * (position in the list).\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* keys<T>(\n  node?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<number> {\n  for (let i = 0; node != end; ++i) {\n    yield i;\n    node = node!.next;\n  }\n}\n\n/**\n * Finds the tail of the linked list and the distance to it.\n *\n * This function iterates through the linked list starting from the `node`\n * node, counting each node until it reaches the tail of the list (\n * where node.next is null or undefined).\n *\n * @param node - The node from which to start counting.\n *\n * @returns a tuple with the tail and distance to it.\n */\nexport function getTail(node?: null): [undefined, -1];\nexport function getTail<N extends LinkedNode<unknown>>(node: N): [N, number];\nexport function getTail<N extends LinkedNode<unknown>>(\n  node?: N | null\n): [N, number] | [undefined, -1];\nexport function getTail<N extends LinkedNode<unknown>>(\n  node?: N | null\n): [N, number] | [undefined, -1] {\n  if (node == null) {\n    return [undefined, -1];\n  }\n  let count = 0;\n  while (node.next != null) {\n    node = node.next;\n    ++count;\n  }\n  return [node, count];\n}\n\n/**\n * Converts a linked list into an array of values.\n *\n * The conversion starts from the `node` node and includes all nodes up to the\n * end of the list, or the `end` node if provided.\n *\n * @param node - The node at which to start converting.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, conversion continues until the end of the list.\n *\n * @returns An array with the values of the list from `node` to `end`.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but\n * not encountered before the end of the list.\n */\nexport function toArray<T>(node?: LinkedNode<T>, end?: LinkedNode<T>): T[] {\n  const array: T[] = [];\n\n  while (node != end) {\n    array.push(node!.value);\n    node = node!.next;\n  }\n\n  return array;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(\n  values: Iterable<T>\n): [LinkedNode<T>, LinkedNode<T>, number] | [undefined, undefined, 0] {\n  const root = {} as LinkedNode<T>;\n\n  let count = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { value };\n    tail = tail.next;\n    ++count;\n  }\n\n  return root.next === undefined\n    ? [undefined, undefined, 0]\n    : [root.next, tail, count];\n}\n\n/**\n * Iterates through a linked list, yielding each node's value.\n *\n * Iteration starts from the `node` node and continues until either the end\n * of the list, or the `end` node if provided.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a linked list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n * @param end - An optional node at which to end (exclusive).\n * If not provided, iteration continues until the end of the list.\n *\n * @throws - {@link TypeError}\n * thrown if an `end` node is provided but not encountered before the end of the list.\n */\nexport function* values<T>(\n  head?: LinkedNode<T>,\n  end?: LinkedNode<T>\n): Generator<T> {\n  for (let i = 0; head != end; ++i) {\n    yield head!.value;\n    head = head!.next;\n  }\n}\n","import { DoublyLinkedNode } from \"../types/doublyLinkedNode\";\n\nimport { get as singlyGet, cut as singlyCut } from \"./linkedNode\";\n\n/**\n * Removes and returns a segment of a linked list as a new list.\n *\n * This operation modifies the original list by removing the specified\n * range of nodes and returning the new list's head and tail as a tuple.\n * If `count` \\<= zero, the function returns [undefined, undefined].\n * If `count` \\> len(prev), a `TypeError` is thrown.\n *\n * @param prev - The node preceding the start of the section to be cut.\n * @param count - The number of nodes to include in the cut.\n *\n * @returns A tuple containing the head and tail of the removed segment,\n * or [undefined, undefined] if `count` \\<= zero.\n *\n * @throws - {@link TypeError}\n * thrown if `count` \\> `len(prev)`\n */\nexport function cut<N extends DoublyLinkedNode<unknown>>(\n  root: N,\n  count: number\n): [N, N] | [undefined, undefined] {\n  if (count <= 0) {\n    return [undefined, undefined];\n  }\n  const [head, tail] = singlyCut(root, count) as [N, N];\n  head.prev = undefined;\n  if (root.next != null) {\n    root.next.prev = root;\n  }\n  return [head, tail];\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * This function iterates through the linked list starting from the `node`\n * node, moving `index` nodes away in the list.\n *\n * @param node - The node from which to start.\n * @param index - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index,\n * or `undefined` if `index` does not exist.\n */\nexport function get<N extends DoublyLinkedNode<unknown>>(\n  node: N | undefined,\n  index: number\n): N | undefined {\n  if (index >= 0) {\n    return singlyGet(node, index);\n  }\n  for (let i = 0; node != null && i > index; --i) {\n    node = node.prev;\n  }\n  return node;\n}\n\n/**\n * Inserts a new sequence of values into a linked list right after a specified node.\n *\n * @param prev - The node in the linked list after which the new values will be inserted.\n * @param values - An iterable of values to be inserted.\n *\n * @returns The last node that was inserted into the list, or `prev` if no values were inserted.\n */\nexport function insert<T>(\n  prev: DoublyLinkedNode<T>,\n  values: T[]\n): DoublyLinkedNode<T> {\n  // Convert values to list\n  const [head, tail, size] = toList(values);\n\n  // If no values\n  if (size <= 0) {\n    return prev;\n  }\n\n  // Add values\n  const next = prev.next;\n  prev.next = head;\n  head!.prev = prev;\n  tail!.next = next;\n  if (next != null) {\n    next.prev = tail;\n  }\n\n  return tail!;\n}\n\n/**\n * Converts an iterable collection of values into a linked list and returns\n * the head, tail and size of the list.\n *\n * If the iterable is empty, the function returns a triple containing\n * `[undefined, undefined, 0]` to indicate that no list was created.\n *\n * @param values - The iterable collection of elements.\n *\n * @returns A triple containing the head, tail and size of the list.\n * Returns `[undefined, undefined, 0]` if the iterable is empty.\n */\nexport function toList<T>(\n  values: Iterable<T>\n):\n  | [DoublyLinkedNode<T>, DoublyLinkedNode<T>, number]\n  | [undefined, undefined, 0] {\n  const root = {} as DoublyLinkedNode<T>;\n\n  let count = 0;\n  let tail = root;\n  for (const value of values) {\n    tail.next = { prev: tail, value } as DoublyLinkedNode<T>;\n    tail = tail.next;\n    ++count;\n  }\n\n  if (count <= 0) {\n    return [undefined, undefined, 0];\n  }\n\n  root.next!.prev = undefined;\n  return [root.next!, tail, count];\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { DoublyLinkedNode as Node } from \"../types/doublyLinkedNode\";\nimport { List } from \"../types/list\";\nimport { cut, get, toList } from \"../utils/doublyLinkedNode\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport { entries, has, keys, toArray, values } from \"../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularDoublyLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The root of the linked list\n   */\n  protected _root: Node<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size!: number;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this._root = { value: undefined } as Node<T>;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    const [head, tail, size] = toList(capacity as Iterable<T>);\n    this._capacity = size;\n    if (size > 0) {\n      this._root.next = head!;\n      this._root.prev = tail!;\n      head!.prev = this._root;\n      tail!.next = this._root;\n      this._size = size;\n    }\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularDoublyLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const [head, tail] = cut(this._root, diff);\n    this._size -= diff;\n\n    // Emit discarded items\n    this._emitter.emit(BoundedEvent.Overflow, toArray(head, tail!.next));\n  }\n\n  at(index: number): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return this.get(index).value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._root.next = this._root;\n    this._root.prev = this._root;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    const node = this.get(index);\n    node.prev!.next = node.next;\n    node.next!.prev = node.prev;\n    --this._size;\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.next, this._root);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Update values\n    let node = this.get(start);\n    while (start < end) {\n      node.value = value;\n      node = node.next!;\n      ++start;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.next, value, this._root);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.next, this._root);\n  }\n\n  pop(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove tail\n    const node = this._root.prev!;\n    node.prev!.next = node.next;\n    node.next!.prev = node.prev;\n    --this._size;\n\n    // Return value\n    return node.value;\n  }\n\n  push(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this._emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.append(this._root.prev!, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update node\n    const node = this.get(index);\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove head\n    const head = this._root.next!;\n    head.prev!.next = head.next;\n    head.next!.prev = head.prev;\n    --this._size;\n\n    // Return value\n    return head.value;\n  }\n\n  slice(start?: number, end?: number): CircularDoublyLinkedList<T> {\n    const out = new CircularDoublyLinkedList<T>();\n\n    // Check if empty\n    if (this._size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Add values to output\n    let prev = this.get(start - 1);\n    while (start < end) {\n      prev = prev.next!;\n      out.push(prev.value);\n      ++start;\n    }\n\n    // Return new list\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularDoublyLinkedList<T> {\n    const out = new CircularDoublyLinkedList<T>();\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, this._size - start);\n\n    // Get prev node\n    const prev = this.get(start - 1);\n\n    // Delete values\n    if (deleteCount > 0) {\n      const [head, tail] = cut(prev, deleteCount);\n      this._size -= deleteCount;\n      head!.prev = out._root;\n      tail!.next = out._root;\n      out._root.next = head;\n      out._root.prev = tail;\n      out._size = deleteCount;\n    }\n\n    // Add values\n    this.append(prev, items);\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this._root.next, this._root);\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: Zero capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this._emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this.prepend(this._root.next!, values);\n\n    // Return size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this._root.next, this._root);\n  }\n\n  /**\n   * @internal\n   */\n  protected append(tail: Node<T>, values: T[]): Node<T> {\n    const root = this._root;\n    const next = tail.next!;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = 0; i < N; ++i) {\n      const curr = { prev: tail, value: values[i] } as Node<T>;\n      tail.next = curr;\n      tail = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next!.value);\n        root.next = root.next!.next;\n      }\n    }\n    tail.next = next;\n    next.prev = tail;\n    root.next!.prev = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return tail;\n  }\n\n  /**\n   * @internal\n   */\n  protected get(index: number): Node<T> {\n    index -= index <= this._size / 2 ? -1 : this._size;\n    return get(this._root, index)!;\n  }\n\n  /**\n   * @internal\n   */\n  protected prepend(next: Node<T>, values: T[]): Node<T> {\n    const root = this._root;\n    const prev = next.prev!;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    for (let i = values.length - 1; i >= 0; --i) {\n      const curr = { next, value: values[i] } as Node<T>;\n      next.prev = curr;\n      next = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.prev!.value);\n        root.prev = root.prev!.prev;\n      }\n    }\n    next.prev = prev;\n    prev.next = next;\n    root.prev!.next = root;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted.reverse());\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return next;\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Bounded } from \"../types/bounded\";\nimport { Deque } from \"../types/deque\";\n\nimport { CircularDoublyLinkedList } from \"./circularDoublyLinkedList\";\n\n/**\n * A circular deque is similar to a traditional deque, but uses a fixed-size,\n * circular buffer. When the deque reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedDeque<T> implements Bounded<T>, Deque<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedDeque.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  first(): T | undefined {\n    return this._list.at(0);\n  }\n\n  front(): T | undefined {\n    return this._list.at(0);\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  unshift(...elems: T[]): number {\n    return this._list.unshift(...elems);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded, BoundedEvent } from \"..\";\nimport { LinkedNode as Node } from \"../types/linkedNode\";\nimport { List } from \"../types/list\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\nimport {\n  cut,\n  entries,\n  get,\n  has,\n  keys,\n  toArray,\n  toList,\n  values,\n} from \"../utils/linkedNode\";\nimport { addIfBelow, clamp, isInRange, toInteger } from \"../utils/math\";\nimport { CircularBase } from \"./circularBase\";\n\nexport class CircularLinkedList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, List<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The root of the linked list\n   */\n  protected _root: Node<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size!: number;\n\n  /**\n   * @internal\n   * The last node in the linked list.\n   */\n  protected _tail!: Node<T>;\n\n  /**\n   * Creates a standard linked list (no capacity restriction).\n   */\n  constructor();\n  /**\n   * Creates a linked list with the given capacity.\n   *\n   * @param capacity - the list's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a linked list with the given items. Capacity is set to the number of items.\n   *\n   * @param items - the values to store in the list.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this._root = { value: undefined } as Node<T>;\n    this.clear();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a positive safe integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    const [head, tail, size] = toList(capacity as Iterable<T>);\n    this._capacity = size;\n    if (size > 0) {\n      this._root.next = head;\n      this._tail = tail!;\n      this._size = size;\n    }\n  }\n\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // If input is NaN, below zero, or a non-integer\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink\n    const diff = this._size - capacity;\n    const [head] = cut(this._root, diff);\n    this._size -= diff;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = this._root;\n    }\n\n    // Emit discarded items\n    this._emitter.emit(BoundedEvent.Overflow, toArray(head));\n  }\n\n  at(index?: number): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // If tail\n    if (++index == this._size) {\n      return this._tail.value;\n    }\n\n    // Return value\n    return get(this._root, index)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._root.next = undefined;\n    this._tail = this._root;\n  }\n\n  delete(index: number): boolean {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    const prev = get(this._root, index)!;\n    prev.next = prev.next!.next;\n    --this._size;\n\n    // Update tail, if needed\n    if (index == this._size) {\n      this._tail = prev;\n    }\n\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return entries(this._root.next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Update values\n    let node = get(this._root, start + 1);\n    while (start < end) {\n      node!.value = value;\n      node = node!.next;\n      ++start;\n    }\n\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return has(this._root.next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return keys(this._root.next);\n  }\n\n  pop(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove and update tail\n    const value = this._tail.value;\n    this._tail = get(this._root, --this._size)!;\n    this._tail.next = undefined;\n\n    // Return value\n    return value;\n  }\n\n  push(...values: T[]): number {\n    // If no values\n    const N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this._emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Add values\n    this._tail = this._append(this._tail, values);\n\n    // Return size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Check index\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Update node\n    const node = get(this._root, index + 1)!;\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // Check if empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove head\n    const head = this._root.next!;\n    this._root.next = head.next;\n    --this._size;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = this._root;\n    }\n\n    // Return value\n    return head.value;\n  }\n\n  slice(start?: number, end?: number): CircularLinkedList<T> {\n    const out = new CircularLinkedList<T>();\n\n    // Check if empty\n    if (this._size <= 0) {\n      return out;\n    }\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize end\n    end = toInteger(end, this._size);\n    end = clamp(addIfBelow(end, this._size), 0, this._size);\n\n    // Add values to output\n    let node = get(this._root, start)!;\n    while (start < end) {\n      node = node.next!;\n      out.push(node.value);\n      ++start;\n    }\n\n    // Return new list\n    return out;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularLinkedList<T> {\n    const out = new CircularLinkedList<T>();\n\n    // Sanitize start\n    start = toInteger(start, 0);\n    start = clamp(addIfBelow(start, this._size), 0, this._size);\n\n    // Sanitize deleteCount\n    deleteCount = toInteger(deleteCount, 0);\n    deleteCount = clamp(deleteCount, 0, this._size - start);\n\n    // Get prev node\n    let prev = get(this._root, start)!;\n\n    // Delete values\n    if (deleteCount > 0) {\n      const [head, tail] = cut(prev, deleteCount);\n      this._size -= deleteCount;\n      out._root.next = head;\n      out._tail = tail!;\n      out._size = deleteCount;\n    }\n\n    // Add values\n    prev = this._append(prev, items);\n\n    // Update tail, if needed\n    if (prev.next == null) {\n      this._tail = prev;\n    }\n\n    return out;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return values(this._root.next);\n  }\n\n  unshift(...values: T[]): number {\n    // Case 1: No values\n    let N = values.length;\n    if (N <= 0) {\n      return this._size;\n    }\n\n    // Case 2: No capacity\n    const capacity = this._capacity;\n    if (capacity <= 0) {\n      this._emitter.emit(BoundedEvent.Overflow, values);\n      return this._size;\n    }\n\n    // Reduce input\n    const diff = N <= capacity ? 0 : N - capacity;\n    N -= diff;\n\n    // Case 3: Discard list overflow\n    if (this._size + N > capacity) {\n      this._size = capacity - N;\n      const prev = get(this._root, this._size)!;\n      this._emitter.emit(BoundedEvent.Overflow, toArray(prev.next));\n      prev.next = undefined;\n      this._tail = prev;\n    }\n\n    // Discard input overflow\n    if (diff > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, values.slice(N));\n      values.length = N;\n    }\n\n    // Add values\n    const [head, tail] = toList(values);\n    tail!.next = this._root.next;\n    this._root.next = head;\n\n    // Update tail, if needed\n    if (this._size <= 0) {\n      this._tail = tail!;\n    }\n\n    // Update size\n    this._size += N;\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return values(this._root.next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _append(tail: Node<T>, values: T[], minIndex = 0): Node<T> {\n    const root = this._root;\n    const next = tail.next;\n    const evicted: T[] = [];\n    const capacity = this._capacity;\n\n    // Add values\n    let size = this._size;\n    const N = values.length;\n    for (let i = minIndex; i < N; ++i) {\n      const curr = { value: values[i] } as Node<T>;\n      tail.next = curr;\n      tail = curr;\n      if (size < capacity) {\n        ++size;\n      } else {\n        evicted.push(root.next!.value);\n        root.next = root.next!.next;\n      }\n    }\n    tail.next = next;\n\n    // Emit evicted items\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    // Update size\n    this._size = size;\n\n    // Return last node\n    return tail;\n  }\n}\n","import { Queue } from \"../types/queue\";\nimport { Bounded } from \"../types/bounded\";\n\nimport { CircularLinkedList } from \"./circularLinkedList\";\nimport { BoundedEvent } from \"..\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  first(): T | undefined {\n    return this._list.at(0);\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  front(): T | undefined {\n    return this._list.at(0);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this._list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Stack } from \"../types/stack\";\nimport { Bounded } from \"../types/bounded\";\nimport { BoundedEvent, CircularDoublyLinkedList } from \"..\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularLinkedStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected _list: CircularDoublyLinkedList<T>;\n\n  /**\n   * Creates a new stack with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack. Initial capacity is the number of items given.\n   *\n   * @param items - the values to store in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this._list = new CircularDoublyLinkedList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this._list.capacity;\n  }\n\n  get size(): number {\n    return this._list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularLinkedStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this._list.capacity = capacity;\n  }\n\n  clear(): void {\n    this._list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this._list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    this._list.forEach((v, i) => callbackfn.call(thisArg, v, i, this), thisArg);\n  }\n\n  has(value: T): boolean {\n    return this._list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this._list.keys();\n  }\n\n  last(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  pop(): T | undefined {\n    return this._list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this._list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  top(): T | undefined {\n    return this._list.at(-1);\n  }\n\n  values(): IterableIterator<T> {\n    return this._list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this._list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularMap<K, V>\n  extends CircularBase<[K, V]>\n  implements Bounded<[K, V]>, Map<K, V>, Collection<K, V>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The internal map.\n   */\n  protected _map: Map<K, V>;\n\n  /**\n   * Creates a new map with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new map with the given capacity.\n   *\n   * @param capacity - the map's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new map. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the map.\n   */\n  constructor(items: Iterable<[K, V]>);\n  constructor(capacity?: number | null | Iterable<[K, V]>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this._map = new Map();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this._map = new Map(capacity as Iterable<[K, V]>);\n    this._capacity = this._map.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the map.\n   */\n  get size(): number {\n    return this._map.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularMap.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the map.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if size is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this._map);\n      this.clear();\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: [K, V][] = [];\n    const iter = this._map.entries();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const entry = iter.next().value;\n      this._map.delete(entry[0]);\n      evicted.push(entry);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Removes all elements from the map.\n   */\n  clear(): void {\n    this._map.clear();\n  }\n\n  /**\n   * Deletes a specified value from the map.\n   *\n   * @returns `true` if the value existed in the map and has been removed, or `false` otherwise.\n   */\n  delete(key: K): boolean {\n    return this._map.delete(key);\n  }\n\n  /**\n   * Iterate through the map's entries.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[K, V]> {\n    return this._map.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the map.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: V, key: K, map: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const [key, value] of this._map.entries()) {\n      callbackfn.call(thisArg, value, key, this);\n    }\n  }\n\n  /**\n   * Returns the associated value of the given key from the map.\n   *\n   * If the associated value is an object, then you will get a reference to that object; any change made to the object will effectively modify it inside the map.\n   *\n   * @returns the value associated with the specified key, or `undefined` if no value is associated.\n   */\n  get(key: K): V | undefined {\n    return this._map.get(key);\n  }\n\n  /**\n   * Determines whether a given value is in the map.\n   *\n   * @param key - The key to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(key: K): boolean {\n    return this._map.has(key);\n  }\n\n  /**\n   * Iterate through the map's keys.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's keys.\n   */\n  keys(): IterableIterator<K> {\n    return this._map.keys();\n  }\n\n  /**\n   * Sets the specified key-value pair in the map.\n   *\n   * @param key - the key to add\n   * @param value - the key's value.\n   */\n  set(key: K, value: V): this {\n    // Base case: map has no capacity.\n    if (this.capacity < 1) {\n      this._emitter.emit(BoundedEvent.Overflow, [[key, value]]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: [K, V][] = [];\n    if (!this._map.delete(key) && this.size >= this.capacity) {\n      const entry = this._map.entries().next().value;\n      this._map.delete(entry[0]);\n      evicted.push(entry);\n    }\n\n    // Add value\n    this._map.set(key, value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<[K, V]> {\n    return this._map.entries();\n  }\n\n  /**\n   * Iterate through the map's values.\n   *\n   * **Note:** Modifying the map during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the map's values.\n   */\n  values(): IterableIterator<V> {\n    return this._map.values();\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Queue } from \"../types/queue\";\nimport { Bounded } from \"../types/bounded\";\nimport { CircularArrayList } from \"./circularArrayList\";\n\n/**\n * A circular queue is similar to a traditional queue, but uses a fixed-size,\n * circular buffer. When the queue reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularQueue<T> implements Bounded<T>, Queue<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new queue. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new queue with the given capacity.\n   *\n   * @param capacity - the queue's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new queue from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the queue.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularQueue.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  first(): T | undefined {\n    return this.list.first();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  front(): T | undefined {\n    return this.list.first();\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  shift(): T | undefined {\n    return this.list.shift();\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n","import { Bounded } from \"../types/bounded\";\nimport { BoundedEvent } from \"../types/boundedEvent\";\nimport { Collection } from \"../types/collection\";\nimport { isInfinity, isNumber, isSafeCount } from \"../utils/is\";\n\nimport { CircularBase } from \"./circularBase\";\n\n/**\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularSet<T>\n  extends CircularBase<T>\n  implements Bounded<T>, Set<T>, Collection<T, T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * The internal set.\n   */\n  protected set: Set<T>;\n\n  /**\n   * Creates a new set with `capacity` defaulted to `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new set with the given capacity.\n   *\n   * @param capacity - the set's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new set. Initial capacity is the number of unique items given.\n   *\n   * @param items - the values to store in the set.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    super();\n\n    // Initialize class variables\n    this._capacity = Infinity;\n    this.set = new Set();\n\n    // Case 1: capacity is null, undefined or Infinity\n    capacity = capacity ?? Infinity;\n    if (isInfinity(capacity)) {\n      return;\n    }\n\n    // Case 2: capacity is zero or a safe positive integer\n    if (isNumber(capacity)) {\n      if (!isSafeCount(capacity)) {\n        throw new RangeError(\"Invalid capacity\");\n      }\n      this._capacity = capacity;\n      return;\n    }\n\n    // Case 3: capacity is iterable\n    this.set = new Set(capacity as Iterable<T>);\n    this._capacity = this.set.size;\n  }\n\n  /**\n   * @returns the maximum number of elements that can be stored.\n   */\n  get capacity(): number {\n    return this._capacity;\n  }\n\n  /**\n   * @returns the number of values in the set.\n   */\n  get size(): number {\n    return this.set.size;\n  }\n\n  /**\n   * Return the type of the object.\n   */\n  get [Symbol.toStringTag](): string {\n    return CircularSet.name;\n  }\n\n  /**\n   * The maximum number of elements that can be stored in the set.\n   */\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check if input is valid\n    if (!isInfinity(capacity) && !isSafeCount(capacity)) {\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Check if capacity is changing\n    if (capacity === this._capacity) {\n      return;\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // Check if set is within capacity\n    if (this.size <= capacity) {\n      return;\n    }\n\n    // Check if new capacity is zero\n    if (capacity === 0) {\n      const evicted = Array.from(this.set);\n      this.clear();\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n      return;\n    }\n\n    // Shrink down map.\n    const evicted: T[] = [];\n    const iter = this.set.values();\n    for (let n = this.size - capacity; n > 0; --n) {\n      const value = iter.next().value;\n      this.set.delete(value);\n      evicted.push(value);\n    }\n    this._emitter.emit(BoundedEvent.Overflow, evicted);\n  }\n\n  /**\n   * Adds the specified value to the set.\n   *\n   * @param value - the value to add.\n   */\n  add(value: T): this {\n    // Base case: set has no capacity.\n    if (this.capacity < 1) {\n      this._emitter.emit(BoundedEvent.Overflow, [value]);\n      return this;\n    }\n\n    // Evict excess items\n    const evicted: T[] = [];\n    if (!this.set.delete(value) && this.size >= this.capacity) {\n      const out = this.set.values().next().value;\n      this.set.delete(out);\n      evicted.push(out);\n    }\n\n    // Add value\n    this.set.add(value);\n\n    // Emit evicted\n    if (evicted.length > 0) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes all elements from the set.\n   */\n  clear(): void {\n    this.set.clear();\n  }\n\n  /**\n   * Deletes a specified value from the set.\n   *\n   * @returns `true` if the value existed in the set and has been removed, or `false` otherwise.\n   */\n  delete(value: T): boolean {\n    return this.set.delete(value);\n  }\n\n  /**\n   * Iterate through the set's entries.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of [key, value] pairs for every entry.\n   */\n  entries(): IterableIterator<[T, T]> {\n    return this.set.entries();\n  }\n\n  /**\n   * Performs the specified action for each value in the set.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @param callbackfn - A function that accepts up to three arguments. It is called once per value.\n   * @param thisArg - An object to which the `this` keyword refers to in the `callbackfn` function. Defaults to `undefined`.\n   */\n  forEach(\n    callbackfn: (value: T, key: T, set: this) => void,\n    thisArg?: unknown\n  ): void {\n    for (const key of this.set.keys()) {\n      callbackfn.call(thisArg, key, key, this);\n    }\n  }\n\n  /**\n   * Determines whether a given value is in the set.\n   *\n   * @param value - The value to search for.\n   *\n   * @returns `true` if the value was found, `false` otherwise.\n   */\n  has(value: T): boolean {\n    return this.set.has(value);\n  }\n\n  /**\n   * Iterate through the set's keys.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's keys.\n   */\n  keys(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of the set's values.\n   */\n  values(): IterableIterator<T> {\n    return this.set.keys();\n  }\n\n  /**\n   * Iterate through the set's values.\n   *\n   * **Note:** Modifying the set during iteration may cause unexpected behavior.\n   *\n   * @returns an iterable of values.\n   */\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.set.values();\n  }\n}\n","/**\n * Generates an iterable that yields chunks (arrays) of elements from the input iterable,\n * with each chunk containing up to a specified maximum number of elements. This function\n * is useful for processing or handling large collections of items in smaller, more\n * manageable segments.\n *\n * `chunkSize` is truncated to an integer to ensure expected behavior.\n * If `chunkSize` is less than 1, an empty iterable is generated.\n *\n * Example usage:\n * ```typescript\n * const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n * for (const chunk of chunk(nums, 3)) {\n *   console.log(chunk); // Outputs: [1, 2, 3], [4, 5, 6], [7, 8, 9]\n * }\n * ```\n *\n * @param source - The original iterable to be chunked. Can be any iterable object (e.g., Array, Set, or a custom iterable).\n * @param chunkSize - The maximum size of each chunk. Must be a positive integer; non-integer values are truncated.\n *\n * @returns An iterable iterator that yields each chunk as an array of elements.\n */\nexport function* chunk<T>(\n  source: Iterable<T>,\n  chunkSize: number\n): IterableIterator<T[]> {\n  if (chunkSize < 1) {\n    return;\n  }\n  let chunk: T[] = [];\n  chunkSize = Math.trunc(chunkSize);\n  for (const value of source) {\n    if (chunk.push(value) >= chunkSize) {\n      yield chunk;\n      chunk = [];\n    }\n  }\n  if (chunk.length > 0) {\n    yield chunk;\n  }\n}\n","import { SkipLink, SkipListCore, SkipNode } from \"../types/skipList\";\nimport { log } from \"./math\";\n\n/**\n * Calculates the maximum level for a skip list based on the given probability\n * factor and expected size.\n *\n * The maximum level determines how many forward pointers each element in the\n * skip list can have, which impacts the overall speed of search, insertion,\n * and deletion operations within the list.\n *\n * @param p - The probability factor used for determining the level. It should\n *          be a number between 0 and 1 (exclusive). The probability factor\n *          affects the sparsity of the skip list; a lower value results in a\n *          shorter, less dense list, while a higher value results in a\n *          taller, denser list.\n * @param expectedSize - The expected number of elements in the skip list. It\n *                     should be a positive integer. The expected size\n *                     influences the optimal maximum level for the list.\n *\n * @returns The calculated optimal maximum level for the skip list. Returns 1\n *          if the probability factor is less than or equal to 0 or the\n *          expected size is less than or equal to 1. Returns Infinity if the\n *          probability factor is 1 or more, indicating an unbounded number of\n *          levels, and likely an error in inputs.\n */\nexport function calcMaxLevel(p: number, expectedSize: number): number {\n  if (p <= 0 || expectedSize <= 1) {\n    return 1;\n  }\n  if (p >= 1) {\n    return Infinity;\n  }\n  return Math.ceil(log(expectedSize, 1 / p));\n}\n\n/**\n * Creates a copy of a segment from a skip list, starting at a specified\n * position and including a specified number of nodes.\n *\n * The copied segment is initialized with its own root node and returns\n * the new list's root, tail nodes at each level, and the total number\n * of nodes copied.\n *\n * @param root - The root {@link SkipNode} of the original skip list from\n *               which the copy operation begins.\n * @param start - The zero-based position in the original list from which to\n *                start copying nodes.\n * @param count - The number of nodes to copy from the start position. If the\n *                count exceeds the number of nodes available, only the\n *                available nodes are copied.\n * @returns A tuple containing:\n *          - The root {@link SkipNode} of the newly created skip list.\n *          - An array of {@link SkipNode}s representing the tail nodes at\n *            each level of the new skip list.\n *          - An integer representing the total number of nodes copied.\n */\nexport function copy<T>(\n  root: SkipNode<T>,\n  start: number,\n  count: number\n): SkipListCore<T> {\n  // Create new root\n  let levels = root.levels.length;\n  const segRoot = gen(undefined as T, levels);\n\n  // Check count\n  if (count <= 0) {\n    return { root: segRoot, size: 0, tails: [segRoot] };\n  }\n\n  // Initialize new list\n  const tails = new Array<SkipNode<T>>(levels).fill(segRoot);\n  const indexes = new Array<number>(levels).fill(-1);\n\n  // Get initial node\n  let node: SkipNode<T> | undefined = getClosest(root, start)[0];\n  node = node.levels[0].next;\n\n  // For each node\n  levels = 1;\n  let size = 0;\n  let index = 0;\n  while (node != null && size < count) {\n    // Update maximum level\n    const L = node.levels.length;\n    levels = levels >= L ? levels : L;\n\n    // Create the duplicate node\n    const dupe = gen(node.value, L);\n\n    // Attach the duplicate at each level\n    for (let lvl = 0; lvl < L; ++lvl) {\n      tails[lvl].levels[lvl] = { next: dupe, span: index - indexes[lvl] };\n      tails[lvl] = dupe;\n      indexes[lvl] = index;\n    }\n\n    // Move to the next node\n    const { next, span } = node.levels[0];\n    index += span;\n    node = next;\n    ++size;\n  }\n\n  // Truncate the output list to the maximum level\n  tails.length = levels;\n  segRoot.levels.length = levels;\n\n  // Update the tail pointers\n  index = indexes[0] + 1;\n  for (let i = 0; i < levels; ++i) {\n    tails[i].levels[i] = { next: undefined, span: index - indexes[i] };\n  }\n\n  // Return the copy\n  return { root: segRoot, size, tails };\n}\n\n/**\n * Iterates through a skip list, yielding each node's index\n * (position in the list) and value as a tuple.\n *\n * Iteration starts from the given node and continues the end of the list.\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* entries<T>(node?: SkipNode<T>): Generator<[number, T]> {\n  for (let i = 0; node != null; ++i) {\n    yield [i, node.value];\n    node = node.levels[0].next;\n  }\n}\n\n/**\n * Generates a new skip list node.\n *\n * @param value - The value to be stored in the new skip list node.\n * @param levels - The number of levels the node participates in within the skip list. Defaults to `1`.\n * @param span - The uniform distance to the next node at each level. Defaults to `1`.\n * @param next - The uniform next node at each level. Defaults to `undefined`.\n *\n * @returns A {@link SkipNode} object populated with the specified value and levels array. Each\n *          level in the array is initialized with a `next` pointer and `span` distance set to\n *          the specified values.\n */\nexport function gen<T>(\n  value: T,\n  levels = 1,\n  span = 1,\n  next?: SkipNode<T>\n): SkipNode<T> {\n  const array = new Array<SkipLink<T>>(levels);\n  for (let i = 0; i < levels; ++i) {\n    array[i] = { next, span };\n  }\n  return { value, levels: array };\n}\n\n/**\n * Retrieves the node at the specified distance from the given node.\n *\n * @param node - The node from which to start.\n * @param distance - The forward distance of the node to retrieve.\n *\n * @returns The node at the specified index, or `undefined` if not found.\n */\nexport function get<T>(\n  node: SkipNode<T>,\n  distance: number\n): SkipNode<T> | undefined {\n  [node, distance] = getClosest(node, distance);\n  return distance === 0 ? node : undefined;\n}\n\n/**\n * Retrieves the node at the specified distance from the given node, or the\n * closest node within the intended distance.\n *\n * @param node - The node from which to start.\n * @param distance - The forward distance of the node to retrieve.\n *\n * @returns A tuple of the resulting node and any remaining distance. If the\n * intended node was found, the tuple would be `[intended node, 0]`.\n * Otherwise, the tuple would be `[closest node, distance remaining]`.\n */\nexport function getClosest<T>(\n  node: SkipNode<T>,\n  distance: number\n): [SkipNode<T>, number] {\n  // Check distance\n  if (distance <= 0) {\n    return [node, distance];\n  }\n\n  // Find node\n  let lvl = node.levels.length - 1;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { next, span } = node.levels[lvl];\n    if (span <= distance && next != null) {\n      // Do nothing\n    } else if (--lvl < 0) {\n      return [node, distance];\n    } else {\n      continue;\n    }\n\n    if (span == distance) {\n      return [next, 0];\n    }\n\n    distance -= span;\n    node = next;\n  }\n}\n\n/**\n * Creates a generator that yields each node in a skip list at a specified level.\n *\n * Iteration begins from a given node up to, but not including, an optional end node. Defaults to level `0`.\n *\n * @param node - The starting {@link SkipNode} from which the iteration begins. If not defined, no nodes are yielded.\n * @param end - An optional {@link SkipNode} at which to end the iteration, exclusive. If provided, the iteration\n *              will halt before yielding this node. If `end` is `undefined`, the iteration will continue until\n *              the end of the list.\n * @param level - The level at which to traverse the skip list, starting from 0 for the base level. Defaults to `0`\n *                if not specified. If a negative value is given, or if the start `node` does not reach this level,\n *                no nodes are yielded.\n */\nexport function* getNodes<T>(\n  node?: SkipNode<T>,\n  level = 0\n): Generator<SkipNode<T>> {\n  if (node == null || level < 0 || node.levels.length <= level) {\n    return;\n  }\n  while (node != null) {\n    yield node;\n    node = node.levels[level].next;\n  }\n}\n\n/**\n * Determines whether a skip list contains a node with a specified value.\n *\n * @param node - The node from which to start searching.\n * @param value - The value to search for.\n *\n * @returns `true` if the specified value is found, `false` otherwise.\n */\nexport function has<T>(node: SkipNode<T> | undefined, value: T): boolean {\n  while (node != null) {\n    if (node.value === value) {\n      return true;\n    }\n    node = node.levels[0].next;\n  }\n  return false;\n}\n\n/**\n * Iterates through a skip list, yielding each node's index\n * (position in the list).\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* keys<T>(node?: SkipNode<T>): Generator<number> {\n  for (let i = 0; node != null; ++i) {\n    yield i;\n    node = node!.levels[0].next;\n  }\n}\n\n/**\n * Iterates through a skip list, yielding each node's height.\n *\n * Iteration starts from the `node` node and continues until\n * the end of the list.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* levels<T>(node?: SkipNode<T>): Generator<number> {\n  while (node != null) {\n    yield node.levels.length;\n    node = node.levels[0].next;\n  }\n}\n\n/**\n * Constructs a skip list from an array of levels and an array of values.\n *\n * @param levels - An array of integers that determines the number of\n *                 levels of the corresponding value in the `values` array.\n * @param values - An array of values to be stored in the skip list. Each\n *                 value is assigned to a new node in the list.\n *\n * @returns A tuple containing three elements:\n *          - The first element is the root {@link SkipNode} of the skip list. This is a dummy node immediately\n *            prior to the first value.\n *          - The second element is an array of {@link SkipNode}s representing the tail nodes at each level.\n *          - The third element is an integer `X` representing the number of nodes successfully added to the list,\n *            not including the root node.\n *\n * @remarks\n * - If the lengths of the input arrays do not match, the function operates on the smallest length.\n * - A dummy root node is created and updated to have up to the maximum level in the `levels` array.\n */\nexport function toList<T>(levels: number[], values: T[]): SkipListCore<T> {\n  // Get # of values (X) and max level (Y)\n  let Y = -Infinity;\n  const X = Math.min(levels.length, values.length);\n  for (let x = 0; x < X; ++x) {\n    if (Y < levels[x]) {\n      Y = levels[x];\n    }\n  }\n\n  // Check inputs\n  if (Y <= 0 || X <= 0) {\n    const root = gen(undefined as T);\n    return { root, size: 0, tails: [root] };\n  }\n\n  // Create root node and tails array\n  const root: SkipNode<T> = gen(undefined as T, Y, X + 1);\n  const tails = new Array(Y).fill(root);\n\n  // For each value\n  for (let x = 0; x < X; ++x) {\n    // Create node\n    const span = X - x;\n    const nextY = levels[x];\n    const next = gen(values[x], nextY, span);\n\n    // Add node to list\n    for (let y = 0; y < nextY; ++y) {\n      const levels = tails[y].levels;\n      levels[y] = { next, span: levels[y].span - span };\n      tails[y] = next;\n    }\n  }\n\n  // Return root, tails and list length\n  return { root, size: X, tails };\n}\n\n/**\n * Reduces the height of the skip list to the specified level.\n *\n * @param root - The root node of the skip list.\n * @param level - The target level.\n */\nexport function truncateLevels<T>(\n  root: SkipNode<T> | undefined,\n  level: number\n): void {\n  // Check inputs\n  if (root == null || root.levels.length <= level) {\n    return;\n  }\n\n  // Truncate nodes\n  let node: SkipNode<T> = root;\n  while (node != null) {\n    const next = node.levels[level].next;\n    node.levels.length = level;\n    node = next!;\n  }\n}\n\n/**\n * Iterates through a skip list, yielding each node's value.\n *\n * This generator function provides a convenient way to enumerate all nodes in\n * a skip list, similar to how `Array.prototype.entries()` works for arrays.\n *\n * @param node - The node at which to start iterating.\n */\nexport function* values<T>(node?: SkipNode<T>): Generator<T> {\n  while (node != null) {\n    yield node.value;\n    node = node.levels[0].next;\n  }\n}\n","import { SkipListCore, SkipNode, SkipStack } from \"../types/skipList\";\n\nimport { gen as genNode } from \"./skipNode\";\n\n/**\n * Creates a copy of the provided skip stack.\n *\n * @param stack - The {@link SkipStack} to be cloned.\n * @returns The copy of the input {@link SkipStack}.\n */\nexport function clone<T>(stack: SkipStack<T>): SkipStack<T> {\n  const N = stack.length;\n  const dupe: SkipStack<T> = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    const { index, node } = stack[i];\n    dupe[i] = { index, node };\n  }\n  return dupe;\n}\n\n/**\n * Cuts a segment from a given skip list.\n *\n * The cut starts at the specified position and spans the given distance. The\n * cut segment is returned as a new skip list.\n *\n * @param core - The {@link SkipListCore} representing the skip list from which to cut the segment.\n *               This skip list will be modified to reflect the removal.\n * @param start - The zero-based index indicating the start position of the cut, inclusive.\n * @param distance - The number of elements to be included in the cut segment.\n *\n * @returns A new {@link SkipListCore} representing the skip list segment that has been cut.\n *\n * @remarks\n * - The height (levels) of the original list may be reduced if segment removal results in empty levels.\n * - The cut segment's height (levels) may be less than the original list. It will only contain\n *   levels that include nodes within the segment.\n */\nexport function cut<T>(\n  core: SkipListCore<T>,\n  start: number,\n  distance: number\n): SkipListCore<T> {\n  // Initialize output list\n  const segRoot = genNode(undefined as T);\n  const seg: SkipListCore<T> = { root: segRoot, size: 0, tails: [segRoot] };\n\n  // Check inputs\n  if (distance <= 0) {\n    return seg;\n  }\n\n  // Initialize constants\n  const prevStack = getClosest(gen(core.root, -1), start);\n  const tailStack = getClosest(clone(prevStack), distance);\n  const end = tailStack[0].index + tailStack[0].node.levels[0].span;\n\n  // Update inputs\n  let levels = core.root.levels.length;\n  start = prevStack[0].index + prevStack[0].node.levels[0].span;\n  distance = end - start;\n\n  // Detach segment from participating levels\n  let lvl: number;\n  for (lvl = 0; lvl < levels; ++lvl) {\n    const prev = prevStack[lvl];\n    const tail = tailStack[lvl];\n\n    // Check if segment exists at this level\n    if (prev.index >= tail.index) {\n      break;\n    }\n\n    // Connect segment start to new root\n    let edge = prev.node.levels[lvl];\n    let span = prev.index + edge.span - start;\n    segRoot.levels[lvl] = { next: edge.next, span };\n\n    // Remove segment from list\n    edge = tail.node.levels[lvl];\n    span = tail.index - prev.index + (edge.span - distance);\n    prev.node.levels[lvl] = { next: edge.next, span };\n\n    // Detach segment end\n    tail.node.levels[lvl] = { next: undefined, span: end - tail.index };\n    seg.tails[lvl] = tail.node;\n  }\n\n  if (lvl < levels) {\n    // Remove segment from higher levels\n    while (lvl < levels) {\n      const prev = prevStack[lvl];\n      const { next, span } = prev.node.levels[lvl];\n      prev.node.levels[lvl] = { next: next, span: span - distance };\n      ++lvl;\n    }\n  } else {\n    // Remove empty levels from the source list\n    const links = core.root.levels;\n    while (lvl > 1 && links[lvl - 1].next == null) {\n      --lvl;\n    }\n    levels = lvl;\n    links.length = levels;\n    core.tails.length = levels;\n  }\n\n  // Update tails from source list\n  if (end >= core.size) {\n    for (lvl = 0; lvl < levels; ++lvl) {\n      core.tails[lvl] = prevStack[lvl].node;\n    }\n  }\n\n  // Update source list's size\n  core.size -= distance;\n\n  // Return removed segment\n  seg.size = distance;\n  return seg;\n}\n\n/**\n * Generates a skip stack filled with pointers to the given node and index.\n *\n * @param node - The {@link SkipNode} to which all pointers in the generated stack will point.\n * @param index - The index in the skip list at which the node is located. Defaults to `0`.\n *\n * @returns A {@link SkipStack} array, where each level points to `node` with index `index`.\n *          The length of this array is equal to the number of levels in the input node.\n */\nexport function gen<T>(node: SkipNode<T>, index = 0): SkipStack<T> {\n  const N = node.levels.length;\n  const stack: SkipStack<T> = new Array(N);\n  for (let i = 0; i < N; ++i) {\n    stack[i] = { index, node };\n  }\n  return stack;\n}\n\n/**\n * Moves the input stack to point to the nodes closest to a specified distance.\n *\n * @param stack - The {@link SkipStack} representing the current pointers at various levels of the skip list.\n * @param distance - The forward distance to travel. The starting point is based on `stack`'s lowest level.\n *\n * @returns A {@link SkipStack} with pointers to the nodes closest to the specified distance, based\n *          on the initial positions indicated by the input stack.\n *\n * @remarks\n * - If the specified distance is 0 or negative, the stack is not modified, as no traversal is needed.\n * - If the target distance exceeds the bounds of the skip list, the result will point to the furthest possible\n *   nodes within the list.\n */\nexport function getClosest<T>(\n  stack: SkipStack<T>,\n  distance: number\n): SkipStack<T> {\n  // Check inputs\n  if (distance <= 0 || stack.length <= 0) {\n    return stack;\n  }\n\n  let lvl = stack.length - 1;\n  let ptr = stack[lvl];\n  const target = stack[0].index + distance;\n\n  // Find node\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const { next, span } = ptr.node.levels[lvl];\n    const nextIndex = ptr.index + span;\n\n    if (nextIndex <= target && next != null) {\n      // Do nothing\n    } else if (--lvl < 0) {\n      break;\n    } else {\n      ptr = stack[lvl];\n      continue;\n    }\n\n    ptr = { index: nextIndex, node: next };\n    stack[lvl] = ptr;\n\n    if (nextIndex == target) {\n      break;\n    }\n  }\n\n  for (let i = 0; i < lvl; ++i) {\n    stack[i] = { index: ptr.index, node: ptr.node };\n  }\n\n  return stack;\n}\n\n/**\n * Inserts a skip list segment (`src`) into another skip list (`dest`) at a specified index.\n *\n * @param dest - The {@link SkipListCore} representing the destination skip list into which the segment is to be\n *               inserted. This skip list will be modified to include the nodes from the source segment.\n * @param index - The zero-based position within the destination list at which the source segment is to be inserted.\n * @param src - The {@link SkipListCore} representing the source skip list segment to be inserted into the destination\n *              list. This skip list's tail nodes will be modified to contain links within the destination list.\n *\n * @remarks\n * - The function may increase the height (number of levels) of the destination list if the source segment has\n *   more levels than the destination. This ensures that the merged list can accommodate the full structure of\n *   the segment being inserted.\n */\nexport function insert<T>(\n  dest: SkipListCore<T>,\n  index: number,\n  src: SkipListCore<T>\n): void {\n  // Check source values\n  if (src.size <= 0) {\n    return;\n  }\n\n  // Increase destination's height if necessary\n  const minY = src.tails.length;\n  for (let y = dest.tails.length; y < minY; ++y) {\n    dest.root.levels[y] = { next: undefined, span: dest.size + 1 };\n    dest.tails[y] = dest.root;\n  }\n\n  // Attach segment at given index\n  const prevs = getClosest(gen(dest.root, -1), index);\n  for (let y = 0; y < minY; ++y) {\n    const prev = prevs[y].node;\n    const prevI = prevs[y].index;\n\n    const prevEdge = prev.levels[y];\n    const tail = src.tails[y];\n    const tailEdge = tail.levels[y];\n    const nextI = prevI + prevEdge.span;\n    const nextD = nextI - index;\n    const tailD = tailEdge.span;\n    tail.levels[y] = { next: prevEdge.next, span: nextD + tailD };\n\n    const rootEdge = src.root.levels[y];\n    const headD = rootEdge.span - 1;\n    const prevD = index - prevI;\n    prev.levels[y] = { next: rootEdge.next, span: prevD + headD };\n  }\n\n  // Update higher levels\n  const maxY = dest.tails.length;\n  for (let y = minY; y < maxY; ++y) {\n    const levels = prevs[y].node.levels;\n    const { next, span } = levels[y];\n    levels[y] = { next, span: span + src.size };\n  }\n\n  // Update tail\n  if (index === dest.size) {\n    dest.tails = src.tails;\n  }\n\n  // Update size\n  dest.size += src.size;\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Bounded, BoundedConfig } from \"../types/bounded\";\nimport { ARGS_MAX_LENGTH, LINKED_MAX_LENGTH } from \"../utils/constants\";\nimport {\n  SkipList,\n  SkipListConfig,\n  SkipListCore,\n  SkipNode,\n} from \"../types/skipList\";\n\nimport {\n  isArrayLength,\n  isInfinity,\n  isIterable,\n  isLinkedLength,\n  isNumber,\n} from \"../utils/is\";\nimport { chunk } from \"../utils/iterable\";\nimport {\n  addIfBelow,\n  clamp,\n  isInRange,\n  randomRun,\n  toInteger,\n} from \"../utils/math\";\nimport * as NodeUtils from \"../utils/skipNode\";\nimport * as StackUtils from \"../utils/skipStack\";\n\nimport { CircularBase } from \"./circularBase\";\n\nexport interface CircularSkipListConfig extends BoundedConfig, SkipListConfig {}\n\nexport class CircularSkipList<T>\n  extends CircularBase<T>\n  implements Bounded<T>, SkipList<T>\n{\n  /**\n   * @internal\n   * The maximum number of elements that can be stored in the collection.\n   */\n  protected _capacity: number;\n\n  /**\n   * @internal\n   * Whether capacity is finite (true) or infinite (false).\n   */\n  protected _isFinite: boolean;\n\n  /**\n   * @internal\n   * The maximum number of levels in the skip list.\n   */\n  protected _maxLevel: number;\n\n  /**\n   * @internal\n   * The probability factor used to randomly determine the levels\n   * of new nodes. Should be a value between 0 and 1, where a lower\n   * value results in fewer levels on average.\n   */\n  protected _p: number;\n\n  /**\n   * @internal\n   * The root of the skip list\n   */\n  protected _root: SkipNode<T>;\n\n  /**\n   * @internal\n   * The current size of the list (0 \\<= size \\<= capacity)\n   */\n  protected _size: number;\n\n  /**\n   * @internal\n   * The last nodes in the skip list at each level.\n   */\n  protected _tails: SkipNode<T>[];\n\n  constructor();\n  constructor(capacity?: number | null);\n  constructor(config: CircularSkipListConfig);\n  constructor(items: Iterable<T>);\n  constructor(config?: CircularSkipListConfig | Iterable<T> | null | number) {\n    super();\n\n    // Initialize class variables\n    this._capacity = LINKED_MAX_LENGTH;\n    this._isFinite = false;\n    this._p = 0.5;\n    this._maxLevel = NodeUtils.calcMaxLevel(this._p, LINKED_MAX_LENGTH);\n    this._root = NodeUtils.gen(undefined as T);\n    this._size = 0;\n    this._tails = [this._root];\n\n    // Case 1: input is null or undefined\n    if (config == null) {\n      return;\n    }\n\n    // Case 2: input is capacity\n    if (isNumber(config)) {\n      this.capacity = config;\n      return;\n    }\n\n    // Case 3: input is config\n    if (!isIterable(config)) {\n      this.capacity = config.capacity ?? this._capacity;\n      this.p = config.p ?? this._p;\n      const size = config.expectedSize ?? this._capacity;\n      this.maxLevel = config.maxLevel ?? NodeUtils.calcMaxLevel(this._p, size);\n      return;\n    }\n\n    // Case 4: input is an iterable\n    for (const vals of chunk(config, ARGS_MAX_LENGTH)) {\n      this._insert(this._size, vals);\n    }\n    this._capacity = this._size;\n    this._isFinite = true;\n  }\n\n  get capacity(): number {\n    return this._isFinite ? this._capacity : Infinity;\n  }\n\n  get levels(): number {\n    return this._root.levels.length;\n  }\n\n  get maxLevel(): number {\n    return this._maxLevel;\n  }\n\n  get p(): number {\n    return this._p;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularSkipList.name;\n  }\n\n  set capacity(capacity: number) {\n    // Convert input to a number\n    capacity = +capacity;\n\n    // Check capacity\n    if (isInfinity(capacity)) {\n      // If capacity is Infinity\n      capacity = LINKED_MAX_LENGTH;\n      this._isFinite = false;\n    } else if (isLinkedLength(capacity)) {\n      // If capacity is valid\n      this._isFinite = true;\n    } else {\n      // If capacity is invalid\n      throw new RangeError(\"Invalid capacity\");\n    }\n\n    // Update capacity\n    this._capacity = capacity;\n\n    // If current size fits within new capacity\n    if (this._size <= capacity) {\n      return;\n    }\n\n    // Shrink list and emit discarded items\n    const { root } = this._cut(0, this._size - capacity);\n    this._overflow(NodeUtils.values(root.levels[0].next));\n  }\n\n  set maxLevel(maxLevel: number) {\n    // Convert input to number\n    maxLevel = +maxLevel;\n\n    // If input is invalid\n    if (!isArrayLength(maxLevel) || maxLevel <= 0) {\n      throw new RangeError(\"Invalid maxLevel\");\n    }\n\n    // Update\n    this._maxLevel = maxLevel;\n\n    // Remove excess levels\n    if (maxLevel < this.levels) {\n      NodeUtils.truncateLevels(this._root, maxLevel);\n    }\n  }\n\n  set p(p: number) {\n    // Convert input to number\n    p = +p;\n\n    // If input is invalid\n    if (isNaN(p) || p < 0 || p > 1) {\n      throw new RangeError(\"Invalid p\");\n    }\n\n    // Update\n    this._p = p;\n  }\n\n  at(index: number): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Return value\n    return NodeUtils.get(this._root, index + 1)!.value;\n  }\n\n  clear(): void {\n    this._size = 0;\n    this._tails = [this._root];\n    this._root.levels.length = 1;\n    this._root.levels[0] = { next: undefined, span: 1 };\n  }\n\n  delete(index: number): boolean {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return false;\n    }\n\n    // Delete value\n    this._cut(index, 1);\n\n    // Return success\n    return true;\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return NodeUtils.entries(this._root.levels[0].next);\n  }\n\n  fill(value: T, start?: number, end?: number): this {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n    if (start >= end) {\n      return this;\n    }\n\n    // Fill values\n    let node = NodeUtils.get(this._root, start + 1)!;\n    for (let i = start; i < end; ++i) {\n      node.value = value;\n      node = node.levels[0].next!;\n    }\n\n    // Return list\n    return this;\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, list: this) => void,\n    thisArg?: unknown\n  ): void {\n    let node = this._root;\n    for (let i = 0; i < this._size; ++i) {\n      node = node.levels[0].next!;\n      callbackfn.call(thisArg, node.value, i, this);\n    }\n  }\n\n  has(value: T): boolean {\n    return NodeUtils.has(this._root.levels[0].next, value);\n  }\n\n  keys(): IterableIterator<number> {\n    return NodeUtils.keys(this._root.levels[0].next);\n  }\n\n  pop(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove last value\n    const { root } = this._cut(this._size - 1, 1);\n\n    // Return value\n    return root.levels[0].next!.value;\n  }\n\n  push(...values: T[]): number {\n    // If no values\n    if (values.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return this._size;\n    }\n\n    // Push values\n    this._insert(this._size, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  set(index: number, value: T): T | undefined {\n    // Sanitize input\n    index = addIfBelow(toInteger(index, -Infinity), this._size);\n    if (!isInRange(index, 0, this._size)) {\n      return undefined;\n    }\n\n    // Set value\n    const node = NodeUtils.get(this._root, index + 1)!;\n    const prevValue = node.value;\n    node.value = value;\n\n    // Return previous value\n    return prevValue;\n  }\n\n  shift(): T | undefined {\n    // If list is empty\n    if (this._size <= 0) {\n      return undefined;\n    }\n\n    // Remove first value\n    const { root } = this._cut(0, 1);\n\n    // Return value\n    return root.levels[0].next!.value;\n  }\n\n  slice(start?: number, end?: number): CircularSkipList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    end = clamp(addIfBelow(toInteger(end, size), size), start, size);\n\n    // Return copied segment as a list\n    const core = NodeUtils.copy(this._root, start, end - start);\n    const list = new CircularSkipList<T>({\n      capacity: core.size,\n      p: this._p,\n      maxLevel: this._maxLevel,\n    });\n    list._root = core.root;\n    list._tails = core.tails;\n    list._size = core.size;\n\n    return list;\n  }\n\n  splice(\n    start: number,\n    deleteCount?: number,\n    ...items: T[]\n  ): CircularSkipList<T> {\n    const size = this._size;\n\n    // Sanitize inputs\n    start = clamp(addIfBelow(toInteger(start, 0), size), 0, size);\n    deleteCount = clamp(toInteger(deleteCount, 0), 0, size - start);\n\n    // Remove deleted items\n    const core = this._cut(start, deleteCount);\n\n    // Add new items\n    this._insert(start, items);\n\n    // Return deleted items as a list\n    const list = new CircularSkipList<T>({\n      capacity: deleteCount,\n      p: this._p,\n      maxLevel: this._maxLevel,\n    });\n    list._root = core.root;\n    list._tails = core.tails;\n    list._size = core.size;\n\n    return list;\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.values();\n  }\n\n  unshift(...values: T[]): number {\n    // If no values\n    if (values.length <= 0) {\n      return this._size;\n    }\n\n    // If no capacity\n    if (this._capacity <= 0) {\n      this._overflow(values);\n      return this._size;\n    }\n\n    // Presert values\n    this._presert(0, values);\n\n    // Return new size\n    return this._size;\n  }\n\n  values(): IterableIterator<T> {\n    return NodeUtils.values(this._root.levels[0].next);\n  }\n\n  /**\n   * @internal\n   */\n  protected _cut(start: number, count: number): SkipListCore<T> {\n    // Create list core\n    const core = { root: this._root, size: this._size, tails: this._tails };\n\n    // Cut and get removed segment\n    const seg = StackUtils.cut(core, start, count);\n\n    // Update list state\n    this._size = core.size;\n    this._tails = core.tails;\n\n    // Return cut segment\n    return seg;\n  }\n\n  /**\n   * @internal\n   */\n  protected _insert(index: number, values: T[]): void {\n    const N = values.length;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(index, values.slice(0, free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from head\n    if (index > 0) {\n      const shifted = Math.min(index, N - free);\n      const { root } = this._cut(0, shifted);\n      this._overflow(NodeUtils.values(root.levels[0].next));\n      index -= shifted;\n      free += shifted;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    const mid = values.length - free;\n    this._overflow(values.slice(0, mid));\n    this._safeInsert(0, values.slice(mid));\n  }\n\n  /**\n   * @internal\n   *\n   * Emit an overflow event containing the items evicted from the collection.\n   *\n   * @param evicted - The items evicted from the collection.\n   */\n  protected _overflow(evicted: Iterable<T>): void {\n    if (Array.isArray(evicted)) {\n      this._emitter.emit(BoundedEvent.Overflow, evicted);\n    } else {\n      for (const array of chunk(evicted, ARGS_MAX_LENGTH)) {\n        this._emitter.emit(BoundedEvent.Overflow, array);\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected _presert(index: number, values: T[]): void {\n    const N = values.length;\n\n    // Check free space\n    let free = this._capacity - this._size;\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Check if \"infinite\" capacity yet not enough space\n    if (!this._isFinite) {\n      this._safeInsert(0, values.slice(values.length - free));\n      throw new Error(\"Out of memory\");\n    }\n\n    // Remove from tail\n    if (index < this._size) {\n      const popped = Math.min(this._size - index, N - free);\n      const { root } = this._cut(this._size - popped, popped);\n      this._overflow(NodeUtils.values(root.levels[0].next));\n      free += popped;\n    }\n\n    // Check free space\n    if (free >= N) {\n      this._safeInsert(index, values);\n      return;\n    }\n\n    // Remove from items and insert remaining\n    this._overflow(values.slice(free));\n    this._safeInsert(this._size, values.slice(0, free));\n  }\n\n  /**\n   * @internal\n   */\n  protected _safeInsert(index: number, values: T[]): void {\n    // Create levels\n    const N = values.length;\n    const levels = new Array<number>(N);\n    for (let i = 0; i < N; ++i) {\n      levels[i] = randomRun(this._p, 1, this._maxLevel);\n    }\n\n    // Create segment\n    const seg = NodeUtils.toList(levels, values);\n\n    // Insert segment\n    const core = { root: this._root, size: this._size, tails: this._tails };\n    StackUtils.insert(core, index, seg);\n\n    // Update list state\n    this._size = core.size;\n    this._tails = core.tails;\n  }\n}\n","import { BoundedEvent } from \"../types/boundedEvent\";\nimport { Stack } from \"../types/stack\";\nimport { Bounded } from \"../types/bounded\";\nimport { CircularArrayList } from \"./circularArrayList\";\n\n/**\n * A circular stack is similar to a traditional stack, but uses a fixed-size,\n * circular buffer. When the stack reaches its maximum capacity and a new\n * element is added, the oldest is discarded, thus maintaining its size.\n *\n * This structure efficiently utilizes memory for applications where only the\n * most recent additions are of interest and older data can be discarded.\n *\n * @see {@link https://en.wikipedia.org/wiki/Circular_buffer | Wikipedia}\n */\nexport class CircularStack<T> implements Bounded<T>, Stack<T> {\n  /**\n   * @internal\n   */\n  protected list: CircularArrayList<T>;\n\n  /**\n   * Creates a new stack. Default `capacity` is `Infinity`.\n   */\n  constructor();\n  /**\n   * Creates a new stack with the given capacity.\n   *\n   * @param capacity - the stack's capacity.\n   */\n  constructor(capacity?: number | null);\n  /**\n   * Creates a new stack from the given items. `capacity` will equal the number of items.\n   *\n   * @param items - the initial values in the stack.\n   */\n  constructor(items: Iterable<T>);\n  constructor(capacity?: number | null | Iterable<T>) {\n    this.list = new CircularArrayList(capacity as number);\n  }\n\n  get capacity(): number {\n    return this.list.capacity;\n  }\n\n  get size(): number {\n    return this.list.size;\n  }\n\n  get [Symbol.toStringTag](): string {\n    return CircularStack.name;\n  }\n\n  set capacity(capacity: number) {\n    this.list.capacity = capacity;\n  }\n\n  clear(): void {\n    this.list.clear();\n  }\n\n  entries(): IterableIterator<[number, T]> {\n    return this.list.entries();\n  }\n\n  forEach(\n    callbackfn: (value: T, index: number, collection: this) => void,\n    thisArg?: unknown\n  ): void {\n    return this.list.forEach((v, i) => callbackfn.call(thisArg, v, i, this));\n  }\n\n  has(value: T): boolean {\n    return this.list.has(value);\n  }\n\n  keys(): IterableIterator<number> {\n    return this.list.keys();\n  }\n\n  last(): T | undefined {\n    return this.list.last();\n  }\n\n  pop(): T | undefined {\n    return this.list.pop();\n  }\n\n  push(...elems: T[]): number {\n    return this.list.push(...elems);\n  }\n\n  [Symbol.iterator](): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  top(): T | undefined {\n    return this.list.last();\n  }\n\n  values(): IterableIterator<T> {\n    return this.list.values();\n  }\n\n  addListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.addListener(event, listener);\n    return this;\n  }\n\n  on(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.on(event, listener);\n    return this;\n  }\n\n  prependListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.prependListener(event, listener);\n    return this;\n  }\n\n  removeListener(\n    event: typeof BoundedEvent.Overflow,\n    listener: (elems: T[]) => void\n  ): this {\n    this.list.removeListener(event, listener);\n    return this;\n  }\n}\n"],"names":["BoundedEvent","EventEmitter","CircularBase","emitter","__publicField","event","listener","ARGS_MAX_LENGTH","ARRAY_MAX_LENGTH","LINKED_MAX_LENGTH","isArrayLength","value","isInfinity","isIterable","isLinkedLength","isNumber","isSafeCount","addIfBelow","addend","target","clamp","min","max","isInRange","log","base","randomRun","probability","randomFn","toInteger","defaultValue","CircularArrayList","capacity","index","start","end","vals","ranges","i","deleteCount","ext","size","callbackfn","thisArg","N","newSize","items","prevValue","from","to","j","out","addCount","replaceCount","a","b","free","shifted","mid","vIndex","popped","newHead","evicted","temp","diff","tail","externalIndex","head","CircularDeque","v","elems","cut","prev","count","get","entries","node","has","keys","toArray","array","toList","values","root","singlyCut","singlyGet","CircularDoublyLinkedList","next","curr","CircularLinkedDeque","CircularLinkedList","minIndex","CircularLinkedQueue","CircularLinkedStack","CircularMap","iter","n","entry","key","CircularQueue","CircularSet","chunk","source","chunkSize","calcMaxLevel","p","expectedSize","copy","levels","segRoot","gen","tails","indexes","getClosest","L","dupe","lvl","span","distance","Y","X","x","nextY","y","truncateLevels","level","clone","stack","core","genNode","seg","prevStack","tailStack","edge","links","ptr","nextIndex","insert","dest","src","minY","prevs","prevI","prevEdge","tailEdge","nextD","tailD","rootEdge","headD","prevD","maxY","CircularSkipList","config","NodeUtils.calcMaxLevel","NodeUtils.gen","NodeUtils.values","maxLevel","NodeUtils.truncateLevels","NodeUtils.get","NodeUtils.entries","NodeUtils.has","NodeUtils.keys","NodeUtils.copy","list","StackUtils.cut","NodeUtils.toList","StackUtils.insert","CircularStack"],"mappings":"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"}